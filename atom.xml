<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pena&#39;s Blog</title>
  
  <subtitle>莫道君行早，更有早行人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pengwenwu.github.io/"/>
  <updated>2018-07-03T15:33:14.417Z</updated>
  <id>https://pengwenwu.github.io/</id>
  
  <author>
    <name>pengwenwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP静态变量</title>
    <link href="https://pengwenwu.github.io/2018/07/03/PHP%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/"/>
    <id>https://pengwenwu.github.io/2018/07/03/PHP静态变量/</id>
    <published>2018-07-03T15:31:53.000Z</published>
    <updated>2018-07-03T15:33:14.417Z</updated>
    
    <content type="html"><![CDATA[<p>通常意义上的静态变量是静态分配，他们的生命周期和程序的生命周期一样，只有在程序退出的时候才结束生命周期。  </p><p>php的静态变量可以分为：  </p><ul><li>静态全局变量：php中的全局变量也可以理解为静态全局变量，因为除非明确unset释放，在程序运行过程中始终存在  </li><li>静态局部变量：即函数内定义的静态变量，函数在执行时对变量的操作会保持到下一次函数执行，直到程序终止  </li><li>静态成员变量：在类中定义的静态变量，和实例变量相对应，静态成员变量可以在所有实例中共享  </li></ul><p>静态局部变量<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> $b = <span class="number">0</span>;</span><br><span class="line">    $b = $b + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">echo</span> $b;</span><br><span class="line">    <span class="keyword">return</span> $b;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// 1</span></span><br><span class="line">test(); <span class="comment">// 2</span></span><br><span class="line">test(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>静态变量只能被初始化一次：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">static</span> $a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">$a = <span class="number">10</span>;</span><br><span class="line">var_dump($a); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> $a = <span class="number">0</span>;</span><br><span class="line">var_dump($a); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p><p>静态成员变量<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$foo1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">echo</span> $foo1::$a; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">$foo2 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">echo</span> $foo2::$a; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> FOO::$a; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>修改静态成员变量<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$foo1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">echo</span> $foo1::$a; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">$foo1::$a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">echo</span> $foo1::$a; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">$foo2 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">echo</span> $foo2::$a; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> FOO::$a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><blockquote><p>参考链接：<a href="http://www.php-internals.com/book/?p=chapt03/03-04-static-var" target="_blank" rel="noopener">《深入理解PHP内核 - 静态变量》</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常意义上的静态变量是静态分配，他们的生命周期和程序的生命周期一样，只有在程序退出的时候才结束生命周期。  &lt;/p&gt;
&lt;p&gt;php的静态变量可以分为：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态全局变量：php中的全局变量也可以理解为静态全局变量，因为除非明确unset释放，在程序
      
    
    </summary>
    
      <category term="后端" scheme="https://pengwenwu.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="PHP" scheme="https://pengwenwu.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>CI框架3.x源码阅读笔记-1</title>
    <link href="https://pengwenwu.github.io/2018/07/02/CI%E6%A1%86%E6%9E%B63.x%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://pengwenwu.github.io/2018/07/02/CI框架3.x源码阅读笔记-1/</id>
    <published>2018-07-02T14:27:08.000Z</published>
    <updated>2018-07-02T14:45:42.477Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当前框架版本define(‘CI_VERSION’, ‘3.0.2’);  </p></blockquote><h1 id="入口文件index-php"><a href="#入口文件index-php" class="headerlink" title="入口文件index.php"></a>入口文件index.php</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对比项目跟原框架增加下列代码</span></span><br><span class="line"><span class="keyword">include_once</span> dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/../etc/environment.php'</span>;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">include_once</span> dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/../vendor/autoload.php'</span>;</span><br><span class="line"><span class="keyword">include_once</span> dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/../etc/load_all.php'</span>;</span><br></pre></td></tr></table></figure><h2 id="加载环境配置文件"><a href="#加载环境配置文件" class="headerlink" title="加载环境配置文件"></a>加载环境配置文件</h2><p>通过environment文件判断并设置当前的环境<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_once</span> dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/../etc/environment.php'</span>;</span><br></pre></td></tr></table></figure></p><ul><li><p>通过修改apache或nginx配置，设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apache</span></span><br><span class="line"><span class="comment"># SetEnv key=value</span></span><br><span class="line">SetEnv CI_ENV development_beta</span><br><span class="line"></span><br><span class="line"><span class="comment"># nginx</span></span><br><span class="line"><span class="comment"># key value</span></span><br><span class="line">fastcgi_param CI_ENV beta;</span><br></pre></td></tr></table></figure></li><li><p>在通过<code>cli</code>运行时，通过<code>$_SERVER[&#39;argv&#39;]</code>获取传递给脚本的参数<code>数组</code>，第一个肯定为当前脚本名。  </p></li></ul><h2 id="加载composer"><a href="#加载composer" class="headerlink" title="加载composer"></a>加载composer</h2><p>各种包的加载<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_once</span> dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/../vendor/autoload.php'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="其余初始化的文件加载"><a href="#其余初始化的文件加载" class="headerlink" title="其余初始化的文件加载"></a>其余初始化的文件加载</h2><p>包括一些监控、报警、调用链追踪<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_once</span> dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/../etc/load_all.php'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="加载核心文件"><a href="#加载核心文件" class="headerlink" title="加载核心文件"></a>加载核心文件</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require_once</span> BASEPATH.<span class="string">'core/CodeIgniter.php'</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;当前框架版本define(‘CI_VERSION’, ‘3.0.2’);  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;入口文件index-php&quot;&gt;&lt;a href=&quot;#入口文件index-php&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="后端" scheme="https://pengwenwu.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="PHP" scheme="https://pengwenwu.github.io/tags/PHP/"/>
    
      <category term="CodeIgniter" scheme="https://pengwenwu.github.io/tags/CodeIgniter/"/>
    
  </entry>
  
  <entry>
    <title>workerman入门</title>
    <link href="https://pengwenwu.github.io/2018/06/27/workerman%E5%85%A5%E9%97%A8/"/>
    <id>https://pengwenwu.github.io/2018/06/27/workerman入门/</id>
    <published>2018-06-27T15:38:55.000Z</published>
    <updated>2018-06-27T15:40:12.264Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于php不像nodejs、java一样可以常驻内存，没有现成的websock io，需要通过原生的php socket去实现服务端websocket的通信。对于菜鸟而言，还是使用现成的框架更方便，等水平足够了，才需要去考虑这些底层的实现  </p></blockquote><h1 id="什么是workerman？"><a href="#什么是workerman？" class="headerlink" title="什么是workerman？"></a>什么是workerman？</h1><p>Workerman是一款纯PHP开发的开源高性能的<code>PHP socket</code> 服务器框架。本身是一个PHP多进程服务器框架，具有PHP进程管理以及socket通信的模块，所以不依赖php-fpm、nginx或者apache等这些容器便可以独立运行。  </p><blockquote><p>官网：<a href="http://www.workerman.net/workerman" target="_blank" rel="noopener">http://www.workerman.net/workerman</a><br>workerman手册：<a href="http://doc.workerman.net/640361" target="_blank" rel="noopener">http://doc.workerman.net/640361</a>  </p></blockquote><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ol><li>纯PHP开发</li><li>支持PHP多进程</li><li>支持TCP、UDP</li><li>支持长连接</li><li>支持各种应用层协议</li><li>支持高并发</li><li>支持服务平滑重启</li><li>支持文件更新检测及自动加载</li><li>支持以指定用户运行子进程</li><li>支持对象或者资源永久保持</li><li>高性能</li><li>支持HHVM</li><li>支持分布式部署</li><li>支持守护进程化</li><li>支持多端口监听</li><li>支持标准输入输出重定向</li></ol><h1 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h1><h2 id="Linux用户-含Mac-OS"><a href="#Linux用户-含Mac-OS" class="headerlink" title="Linux用户(含Mac OS)"></a>Linux用户(含Mac OS)</h2><ol><li>安装PHP&gt;=5.3.3，并安装了pcntl、posix扩展</li><li>建议安装event或者libevent扩展，但不是必须的（注意event扩展需要PHP&gt;=5.4）</li></ol><h2 id="Linux环境检查脚本"><a href="#Linux环境检查脚本" class="headerlink" title="Linux环境检查脚本"></a>Linux环境检查脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -Ss http://www.workerman.net/check.php | php</span><br></pre></td></tr></table></figure><p>如果脚本中全部提示ok，则代表满足WorkerMan运行环境  </p><p>注意：检测脚本中没有检测event扩展或者libevent扩展，如果并发连接数大于1024建议安装event扩展或者libevent扩展  </p><h2 id="如何安装扩展"><a href="#如何安装扩展" class="headerlink" title="如何安装扩展"></a>如何安装扩展</h2><p>参考文档：<a href="http://doc.workerman.net/appendices/install-extension.html" target="_blank" rel="noopener">http://doc.workerman.net/appendices/install-extension.html</a></p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>普通安装可以参照官网，通过git下载</p><p>也可以通过composer安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require workerman/workerman</span><br></pre></td></tr></table></figure></p><h2 id="开发实例"><a href="#开发实例" class="headerlink" title="开发实例"></a>开发实例</h2><h3 id="websocket实例"><a href="#websocket实例" class="headerlink" title="websocket实例"></a>websocket实例</h3><p>服务端实现<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="string">'./vendor/autoload.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Workerman</span>\<span class="title">Worker</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：这里与上个例子不同，使用的是websocket协议</span></span><br><span class="line">$ws_worker = <span class="keyword">new</span> Worker(<span class="string">"websocket://0.0.0.0:9501"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动4个进程对外提供服务</span></span><br><span class="line">$ws_worker-&gt;count = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当收到客户端发来的数据后返回hello $data给客户端</span></span><br><span class="line">$ws_worker-&gt;onMessage = <span class="function"><span class="keyword">function</span> <span class="params">($connection, $data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向客户端发送hello $data</span></span><br><span class="line">    $connection-&gt;send(<span class="string">'hello '</span> . $data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行worker</span></span><br><span class="line">Worker::runAll();</span><br></pre></td></tr></table></figure></p><p>客户端实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:9501"</span>);</span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"连接成功"</span>);</span><br><span class="line">    ws.send(<span class="string">'tom'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"给服务端发送一个字符串：tom"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"收到服务端的消息："</span> + e.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="启动与停止"><a href="#启动与停止" class="headerlink" title="启动与停止"></a>启动与停止</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>以debug(调试)方式启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php start.php start</span><br></pre></td></tr></table></figure></p><p>以daemon(守护进程)方式启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php start.php start -d</span><br></pre></td></tr></table></figure></p><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php start.php stop</span><br></pre></td></tr></table></figure><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php start.php restart</span><br></pre></td></tr></table></figure><h3 id="平滑重启"><a href="#平滑重启" class="headerlink" title="平滑重启"></a>平滑重启</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php start.php reload</span><br></pre></td></tr></table></figure><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php start.php status</span><br></pre></td></tr></table></figure><h3 id="查看连接状态"><a href="#查看连接状态" class="headerlink" title="查看连接状态"></a>查看连接状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php start.php connections</span><br></pre></td></tr></table></figure><h3 id="debug和daemon方式区别"><a href="#debug和daemon方式区别" class="headerlink" title="debug和daemon方式区别"></a>debug和daemon方式区别</h3><ol><li>以debug方式启动，代码中echo、var_dump、print等打印函数会直接输出在终端  </li><li>以daemon方式启动，代码中echo、var_dump、print等打印会默认重定向到/dev/null文件，可以通过设置<code>Worker::$stdoutFile = &#39;/your/path/file&#39;;</code>来设置这个文件路径  </li><li>以debug方式启动，终端关闭后workerman会随之关闭并退出  </li><li>以daemon方式启动，终端关闭后workerman继续后台正常运行  </li></ol><h3 id="什么是平滑重启？"><a href="#什么是平滑重启？" class="headerlink" title="什么是平滑重启？"></a>什么是平滑重启？</h3><p>平滑重启不同于普通的重启，平滑重启可以做到在不影响用户的情况下重启服务，以便重新载入PHP程序，完成业务代码更新。</p><p>平滑重启一般应用于业务更新或者版本发布过程中，能够避免因为代码发布重启服务导致的暂时性服务不可用的影响。  </p><p><strong>注意：只有子进程运行过程中载入的文件支持reload，主进程载入的文件不支持reload。或者说Worker::runAll执行完后workerman运行过程中动态加载的文件支持reload，Worker::runAll执行前就载入的文件代码不支持reload</strong>  </p><h3 id="平滑重启原理"><a href="#平滑重启原理" class="headerlink" title="平滑重启原理"></a>平滑重启原理</h3><p>WorkerMan分为主进程和子进程，主进程负责监控子进程，子进程负责接收客户端的连接和连接上发来的请求数据，做相应的处理并返回数据给客户端。当业务代码更新时，其实我们只要更新子进程，便可以达到更新代码的目的。  </p><p>当WorkerMan主进程收到平滑重启信号时，主进程会向其中一个子进程发送安全退出(让对应进程处理完毕当前请求后才退出)信号，当这个进程退出后，主进程会重新创建一个新的子进程（这个子进程载入了新的PHP代码），然后主进程再次向另外一个旧的进程发送停止命令，这样一个进程一个进程的重启，直到所有旧的进程全部被置换为止。  </p><p>我们看到平滑重启实际上是让旧的业务进程逐个退出然后并逐个创建新的进程做到的。为了在平滑重启时不影响客用户，这就要求进程中不要保存用户相关的状态信息，即业务进程最好是无状态的，避免由于进程退出导致信息丢失。  </p><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="平滑重启-1"><a href="#平滑重启-1" class="headerlink" title="平滑重启"></a>平滑重启</h4><p>注意：只有在on{…}回调中载入的文件平滑重启后才会自动更新，启动脚本中直接载入的文件或者写死的代码运行reload不会自动更新。</p><h4 id="区分主进程和子进程"><a href="#区分主进程和子进程" class="headerlink" title="区分主进程和子进程"></a>区分主进程和子进程</h4><p>有必要注意下代码是运行在主进程还是子进程，一般来说在<code>Worker::runAll();</code>调用前运行的代码都是在<code>主进程</code>运行的，<code>onXXX</code>回调运行的代码都属于<code>子进程</code>。注意写在<code>Worker::runAll();</code>后面的代码永远不会被执行。  </p><p>注意： 不要在主进程中初始化数据库、memcache、redis等连接资源，因为主进程初始化的连接可能会被子进程自动继承（尤其是使用单例的时候），所有进程都持有同一个连接，服务端通过这个连接返回的数据在多个进程上都可读，会导致数据错乱。同样的，如果任何一个进程关闭连接(例如daemon模式运行时主进程会退出导致连接关闭)，都导致所有子进程的连接都被一起关闭，并发生不可预知的错误，例如mysql gone away 错误。</p><p>推荐在onWorkerStart里面初始化连接资源。  </p><h2 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>初始化一个Worker容器实例，可以设置容器的一些属性和回调接口，完成特定功能。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Worker::__construct([string <span class="variable">$listen</span> , array <span class="variable">$context</span>])</span><br></pre></td></tr></table></figure></p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h5 id="listen-（可选参数，不填写表示不监听任何端口）"><a href="#listen-（可选参数，不填写表示不监听任何端口）" class="headerlink" title="$listen （可选参数，不填写表示不监听任何端口）"></a><code>$listen</code> （可选参数，不填写表示不监听任何端口）</h5><p>$listen 的格式为 <code>&lt;协议&gt;://&lt;监听地址&gt;</code>  </p><h5 id="context"><a href="#context" class="headerlink" title="$context"></a><code>$context</code></h5><p>一个数组。用于传递socket的上下文选项。  </p><p>比如传递ssl证书<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">'/Workerman/Autoloader.php'</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Workerman</span>\<span class="title">Worker</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 证书最好是申请的证书</span></span><br><span class="line">$context = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">'ssl'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'local_cert'</span> =&gt; <span class="string">'/etc/nginx/conf.d/ssl/server.pem'</span>, <span class="comment">// 也可以是crt文件</span></span><br><span class="line">        <span class="string">'local_pk'</span>   =&gt; <span class="string">'/etc/nginx/conf.d/ssl/server.key'</span>,</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 这里设置的是websocket协议</span></span><br><span class="line">$worker = <span class="keyword">new</span> Worker(<span class="string">'websocket://0.0.0.0:4431'</span>, $context);</span><br><span class="line"><span class="comment">// 设置transport开启ssl，websocket+ssl即wss</span></span><br><span class="line">$worker-&gt;transport = <span class="string">'ssl'</span>;</span><br><span class="line">$worker-&gt;onMessage = <span class="function"><span class="keyword">function</span><span class="params">($con, $msg)</span> </span>&#123;</span><br><span class="line">    $con-&gt;send(<span class="string">'ok'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Worker::runAll();</span><br></pre></td></tr></table></figure></p><h3 id="部分常用属性"><a href="#部分常用属性" class="headerlink" title="部分常用属性"></a>部分常用属性</h3><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int Worker::<span class="variable">$id</span></span><br></pre></td></tr></table></figure><p>当前worker进程的id编号，范围为0到$worker-&gt;count-1  </p><p>这个属性对于区分worker进程非常有用，例如1个worker实例有多个进程，开发者只想在其中一个进程中设置定时器，则可以通过识别进程编号id来做到这一点，比如只在该worker实例id编号为0的进程设置定时器  </p><p><strong>注意</strong>：进程重启后id编号值是不变的。进程编号id的分配是基于每个worker实例的。每个worker实例都从0开始给自己的进程编号，所以worker实例间进程编号会有重复，但是一个worker实例中的进程编号不会重复。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Workerman</span>\<span class="title">Worker</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Workerman</span>\<span class="title">Lib</span>\<span class="title">Timer</span>;</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">'./Workerman/Autoloader.php'</span>;</span><br><span class="line"></span><br><span class="line">$worker = <span class="keyword">new</span> Worker(<span class="string">'tcp://0.0.0.0:8585'</span>);</span><br><span class="line">$worker-&gt;count = <span class="number">4</span>;</span><br><span class="line">$worker-&gt;onWorkerStart = <span class="function"><span class="keyword">function</span><span class="params">($worker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 只在id编号为0的进程上设置定时器，其它1、2、3号进程不设置定时器</span></span><br><span class="line">    <span class="keyword">if</span>($worker-&gt;id === <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Timer::add(<span class="number">1</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"4个worker进程，只在0号进程设置定时器\n"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 运行worker</span></span><br><span class="line">Worker::runAll();</span><br></pre></td></tr></table></figure></p><h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int Worker::<span class="variable">$count</span></span><br></pre></td></tr></table></figure><p>设置当前Worker实例启动多少个进程，不设置时默认为1。  </p><p><strong>注意</strong>：此属性必须在<code>Worker::runAll();</code>运行前设置才有效。windows系统不支持此特性。</p><p>设置规则：  </p><ul><li>每个进程占用内存之和需要小于总内存（一般来说每个业务进程占用内存大概40M左右）  </li><li>如果是<code>IO密集型</code>，也就是业务中涉及到一些<code>阻塞式IO</code>，比如一般的访问Mysql、Redis等存储都是阻塞式访问的，进程数可以开大一些，如<code>配置成CPU核数的3倍</code>。注意<code>非阻塞式IO</code>属于<code>CPU密集型</code>，而不属于IO密集型。  </li><li>如果是CPU密集型，也就是业务中没有阻塞式IO开销，例如使用异步IO读取网络资源，进程不会被业务代码阻塞的情况下，可以把<code>进程数设置成和CPU核数一样</code>  </li><li>WorkerMan自身的IO都是<code>非阻塞</code>的，例如<code>Connection-&gt;send</code>等都是非阻塞的，属于<code>CPU密集型</code>操作。如果不清楚自己业务偏向于哪种类型，可设置进程数为<code>CPU核数的2倍</code>左右即可。  </li></ul><h4 id="transport"><a href="#transport" class="headerlink" title="transport"></a>transport</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string Worker::<span class="variable">$transport</span></span><br></pre></td></tr></table></figure><p>设置当前Worker实例所使用的<code>传输层协议</code>，目前只支持3种(<code>tcp</code>、<code>udp</code>、<code>ssl</code>)。不设置默认为<code>tcp</code>。  </p><p>注意：ssl需要Workerman版本&gt;=3.3.7</p><h4 id="connections"><a href="#connections" class="headerlink" title="connections"></a>connections</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array Worker::<span class="variable">$connections</span></span><br></pre></td></tr></table></figure><p>此属性中存储了当前进程的所有的<code>客户端连接对象</code>，其中id为connection的id编号</p><p>格式为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array(id=&gt;connection, id=&gt;connection, ...)</span><br></pre></td></tr></table></figure></p><h4 id="stdoutFile"><a href="#stdoutFile" class="headerlink" title="stdoutFile"></a>stdoutFile</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static string Worker::<span class="variable">$stdoutFile</span></span><br></pre></td></tr></table></figure><p>此属性为<code>全局静态属性</code>，如果以<code>守护进程</code>方式(-d启动)运行，则所有向终端的输出(echo var_dump等)都会被<code>重定向</code>到stdoutFile指定的文件中。</p><p>如果不设置，并且是以守护进程方式运行，则所有终端输出全部重定向到/dev/null</p><p>注意：此属性必须在Worker::runAll();运行前设置才有效。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">Workerman</span>\<span class="title">Worker</span>;</span><br><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">'/Workerman/Autoloader.php'</span>;</span><br><span class="line"></span><br><span class="line">Worker::$daemonize = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 所有的打印输出全部保存在/tmp/stdout.log文件中</span></span><br><span class="line">Worker::$stdoutFile = <span class="string">'/tmp/stdout.log'</span>;</span><br><span class="line">$worker = <span class="keyword">new</span> Worker(<span class="string">'text://0.0.0.0:8484'</span>);</span><br><span class="line">$worker-&gt;onWorkerStart = <span class="function"><span class="keyword">function</span><span class="params">($worker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Worker start\n"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 运行worker</span></span><br><span class="line">Worker::runAll();</span><br></pre></td></tr></table></figure><h4 id="reloadable"><a href="#reloadable" class="headerlink" title="reloadable"></a>reloadable</h4><p>设置当前Worker实例是否可以reload，即收到reload信号后<code>是否退出重启</code>。不设置默认为true，收到reload信号后自动重启进程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool Worker::<span class="variable">$reloadable</span></span><br></pre></td></tr></table></figure></p><h4 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a>daemonize</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static bool Worker::<span class="variable">$daemonize</span></span><br></pre></td></tr></table></figure><p>此属性为<code>全局静态属性</code>，表示是否以daemon(守护进程)方式运行。如果启动命令使用了 <code>-d</code> 参数，则该属性会自动设置为true。也可以代码中手动设置</p><h3 id="回调属性"><a href="#回调属性" class="headerlink" title="回调属性"></a>回调属性</h3><h4 id="onWorkerStart"><a href="#onWorkerStart" class="headerlink" title="onWorkerStart"></a>onWorkerStart</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback Worker::<span class="variable">$onWorkerStart</span></span><br></pre></td></tr></table></figure><p>设置<code>Worker子进程</code>启动时的回调函数，每个子进程启动时都会执行。  </p><p>注意：onWorkerStart是在子进程启动时运行的，如果开启了多个子进程($worker-&gt;count &gt; 1)，每个子进程运行一次，则总共会运行$worker-&gt;count次。</p><p><strong>回调函数的参数:</strong>   </p><p>$worker: Worker对象</p><h4 id="onWorkerReload"><a href="#onWorkerReload" class="headerlink" title="onWorkerReload"></a>onWorkerReload</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback Worker::<span class="variable">$onWorkerReload</span></span><br></pre></td></tr></table></figure><p>设置Worker收到reload信号后执行的回调。 </p><p>可以利用onWorkerReload回调做很多事情，例如在不需要重启进程的情况下重新加载业务配置文件。</p><p><strong>注意：</strong>  </p><p>子进程收到reload信号默认的动作是退出重启，以便新进程重新加载业务代码完成代码更新。所以reload后子进程在执行完onWorkerReload回调后便立刻退出是正常现象。</p><p>如果在收到reload信号后只想让子进程执行onWorkerReload，不想退出，可以在初始化Worker实例时设置对应的Worker实例的reloadable属性为false。  </p><p><strong>回调函数的参数:</strong>   </p><p>$worker: Worker对象</p><h4 id="onConnect"><a href="#onConnect" class="headerlink" title="onConnect"></a>onConnect</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback Worker::<span class="variable">$onConnect</span></span><br></pre></td></tr></table></figure><p>当客户端与Workerman建立连接时(TCP三次握手完成后)触发的回调函数。每个连接只会触发<code>一次</code>onConnect回调。  </p><p>注意：onConnect事件仅仅代表客户端与Workerman完成了TCP三次握手，这时客户端还没有发来任何数据，此时除了通过$connection-&gt;getRemoteIp()获得对方ip，没有其他可以鉴别客户端的数据或者信息，所以在onConnect事件里无法确认对方是谁。要想知道对方是谁，需要客户端发送鉴权数据，例如某个token或者用户名密码之类，在<code>onMessage</code>回调里做鉴权。  </p><p><strong>回调函数的参数:</strong>   </p><p>$connection: 连接对象</p><h4 id="onMessage"><a href="#onMessage" class="headerlink" title="onMessage"></a>onMessage</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback Worker::<span class="variable">$onMessage</span></span><br></pre></td></tr></table></figure><p>当客户端通过连接发来数据时(Workerman收到数据时)触发的回调函数  </p><p><strong>回调函数的参数:</strong>   </p><p>$connection: 连接对象  </p><p>$data: 客户端连接上发来的数据  </p><h4 id="onClose"><a href="#onClose" class="headerlink" title="onClose"></a>onClose</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback Worker::<span class="variable">$onClose</span></span><br></pre></td></tr></table></figure><p>当客户端连接与Workerman断开时触发的回调函数。不管连接是如何断开的，只要断开就会触发onClose。每个连接只会触发一次onClose。  </p><p>注意：如果对端是由于断网或者断电等极端情况断开的连接，这时由于无法及时发送tcp的fin包给workerman，workerman就无法得知连接已经断开，也就无法及时触发onClose。这种情况需要通过应用层<code>心跳</code>来解决。  </p><p><strong>回调函数的参数:</strong>   </p><p>$connection: 连接对象  </p><h4 id="onBufferDrain"><a href="#onBufferDrain" class="headerlink" title="onBufferDrain"></a>onBufferDrain</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback Worker::<span class="variable">$onBufferDrain</span></span><br></pre></td></tr></table></figure><p>每个连接都有一个单独的应用层发送缓冲区，缓冲区大小由TcpConnection::$maxSendBufferSize决定，默认值为1MB，可以手动设置更改大小，更改后会对所有连接生效。  </p><p>该回调可能会在调用Connection::send后立刻被触发，比如发送大数据或者连续快速的向对端发送数据，由于网络等原因数据被大量积压在对应连接的发送缓冲区，当超过TcpConnection::$maxSendBufferSize上限时触发。</p><p><strong>回调函数的参数:</strong>   </p><p>$connection: 连接对象</p><h4 id="onBufferDrain-1"><a href="#onBufferDrain-1" class="headerlink" title="onBufferDrain"></a>onBufferDrain</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback Worker::<span class="variable">$onBufferDrain</span></span><br></pre></td></tr></table></figure><p>该回调在应用层发送缓冲区数据全部发送完毕后触发。一般与onBufferFull配合使用，例如在onBufferFull时停止向对端继续send数据，在onBufferDrain恢复写入数据。</p><p><strong>回调函数的参数:</strong>   </p><p>$connection: 连接对象</p><h4 id="onError"><a href="#onError" class="headerlink" title="onError"></a>onError</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback Worker::<span class="variable">$onError</span></span><br></pre></td></tr></table></figure><p>当客户端的连接上发生错误时触发。  </p><p>目前错误类型有</p><ol><li><p>调用Connection::send由于客户端连接断开导致的失败（紧接着会触发onClose回调） (code:WORKERMAN_SEND_FAIL msg:client closed)  </p></li><li><p>在触发onBufferFull后(发送缓冲区已满)，仍然调用Connection::send，并且发送缓冲区仍然是满的状态导致发送失败(不会触发onClose回调)(code:WORKERMAN_SEND_FAIL msg:send buffer full and drop package)  </p></li><li><p>使用AsyncTcpConnection异步连接失败时(紧接着会触发onClose回调) (code:WORKERMAN_CONNECT_FAIL msg:stream_socket_client返回的错误消息)  </p></li></ol><p><strong>回调函数的参数:</strong>   </p><p>$connection: 连接对象<br>$code: 错误码<br>$msg: 错误消息  </p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="runAll"><a href="#runAll" class="headerlink" title="runAll"></a>runAll</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Worker::runAll(void)</span><br></pre></td></tr></table></figure><p>运行所有Worker实例。</p><p><strong>注意：</strong></p><p>Worker::runAll()执行后将<code>永久阻塞</code>，也就是说位于Worker::runAll()后面的代码将不会被执行。所有Worker实例化应该都在Worker::runAll()前进行。  </p><h4 id="stopAll"><a href="#stopAll" class="headerlink" title="stopAll"></a>stopAll</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Worker::stopAll(void)</span><br></pre></td></tr></table></figure><p>停止当前进程（子进程）的<code>所有Worker实例</code>并退出。  </p><p>此方法用于安全退出当前子进程，作用相当于调用exit/die退出当前子进程。</p><p>与直接调用exit/die区别是，直接调用exit或者die无法触发onWorkerStop回调，并且会导致一条WORKER EXIT UNEXPECTED错误日志。</p><h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Worker::listen(void)</span><br></pre></td></tr></table></figure><p>用于实例化Worker后执行监听。  </p><h2 id="Connection类"><a href="#Connection类" class="headerlink" title="Connection类"></a>Connection类</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="id-1"><a href="#id-1" class="headerlink" title="id"></a>id</h4><h4 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string Connection::<span class="variable">$protocol</span></span><br></pre></td></tr></table></figure><p>设置当前连接的协议类</p><h4 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Worker Connection::<span class="variable">$worker</span></span><br></pre></td></tr></table></figure><p>此属性为只读属性，即当前connection对象所属的worker实例  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Workerman</span>\<span class="title">Worker</span>;</span><br><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">'/Workerman/Autoloader.php'</span>;</span><br><span class="line"></span><br><span class="line">$worker = <span class="keyword">new</span> Worker(<span class="string">'websocket://0.0.0.0:8484'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一个客户端发来数据时，转发给当前进程所维护的其它所有客户端</span></span><br><span class="line">$worker-&gt;onMessage = <span class="function"><span class="keyword">function</span><span class="params">($connection, $data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span>($connection-&gt;worker-&gt;connections <span class="keyword">as</span> $con)</span><br><span class="line">    &#123;</span><br><span class="line">        $con-&gt;send($data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 运行worker</span></span><br><span class="line">Worker::runAll();</span><br></pre></td></tr></table></figure><h4 id="maxSendBufferSize"><a href="#maxSendBufferSize" class="headerlink" title="maxSendBufferSize"></a>maxSendBufferSize</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int Connection::<span class="variable">$maxSendBufferSize</span></span><br></pre></td></tr></table></figure><p>此属性用来设置当前连接的应用层发送缓冲区大小。不设置默认为Connection::$defaultMaxSendBufferSize(1MB)。  </p><h4 id="defaultMaxSendBufferSize"><a href="#defaultMaxSendBufferSize" class="headerlink" title="defaultMaxSendBufferSize"></a>defaultMaxSendBufferSize</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int Connection::<span class="variable">$defaultMaxSendBufferSize</span></span><br></pre></td></tr></table></figure><p>此属性为全局静态属性，用来设置所有连接的默认应用层发送缓冲区大小。不设置默认为1MB。 Connection::$defaultMaxSendBufferSize可以动态设置，设置后只对之后产生的新连接有效  </p><h4 id="maxPackageSize"><a href="#maxPackageSize" class="headerlink" title="maxPackageSize"></a>maxPackageSize</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int Connection::<span class="variable">$maxPackageSize</span></span><br></pre></td></tr></table></figure><p>此属性为全局静态属性，用来设置每个连接能够接收的最大包包长。不设置默认为10MB。  </p><h3 id="回调属性-1"><a href="#回调属性-1" class="headerlink" title="回调属性"></a>回调属性</h3><p>与worker的回调属性作用相同  </p><h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><h4 id="getRemoteIp"><a href="#getRemoteIp" class="headerlink" title="getRemoteIp"></a>getRemoteIp</h4><h4 id="etRemotePort"><a href="#etRemotePort" class="headerlink" title="etRemotePort"></a>etRemotePort</h4><h3 id="Timer定时器类"><a href="#Timer定时器类" class="headerlink" title="Timer定时器类"></a>Timer定时器类</h3><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int \Workerman\Lib\Timer::add(<span class="built_in">float</span> <span class="variable">$time_interval</span>, callable <span class="variable">$callback</span> [,<span class="variable">$args</span> = array(), bool <span class="variable">$persistent</span> = <span class="literal">true</span>])</span><br></pre></td></tr></table></figure><p>定时执行某个函数或者类方法  </p><p>注意：定时器是在当前进程中运行的，workerman中不会创建新的进程或者线程去运行定时器。  </p><p><strong>参数</strong><br>time_interval: 多长时间执行一次，单位秒，支持小数，可以精确到0.001，即精确到毫秒级别  </p><p>callback: 回调函数注意：如果回调函数是类的方法，则方法必须是public属性  </p><p>args: 回调函数的参数，必须为数组，数组元素为参数值  </p><p>persistent: 是否是持久的，如果只想定时执行一次，则传递false（只执行一次的任务在执行完毕后会自动销毁，不必调用Timer::del()）。默认是<code>true</code>，即一直定时执行  </p><p><strong>返回值</strong><br>返回一个整数，代表计时器的timerid，可以通过调用Timer::del($timerid)销毁这个计时器。  </p><p><strong>示例</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">use \Workerman\Worker;</span><br><span class="line">use \Workerman\Lib\Timer;</span><br><span class="line">require_once __DIR__ . <span class="string">'/Workerman/Autoloader.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$ws_worker</span> = new Worker(<span class="string">'websocket://0.0.0.0:8080'</span>);</span><br><span class="line"><span class="variable">$ws_worker</span>-&gt;count = 8;</span><br><span class="line">// 连接建立时给对应连接设置定时器</span><br><span class="line"><span class="variable">$ws_worker</span>-&gt;onConnect = <span class="keyword">function</span>(<span class="variable">$connection</span>)</span><br><span class="line">&#123;</span><br><span class="line">    // 每10秒执行一次</span><br><span class="line">    <span class="variable">$time_interval</span> = 10;</span><br><span class="line">    <span class="variable">$connect_time</span> = time();</span><br><span class="line">    // 给connection对象临时添加一个timer_id属性保存定时器id</span><br><span class="line">    <span class="variable">$connection</span>-&gt;timer_id = Timer::add(<span class="variable">$time_interval</span>, <span class="keyword">function</span>()use(<span class="variable">$connection</span>, <span class="variable">$connect_time</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="variable">$connection</span>-&gt;send(<span class="variable">$connect_time</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">// 连接关闭时，删除对应连接的定时器</span><br><span class="line"><span class="variable">$ws_worker</span>-&gt;onClose = <span class="keyword">function</span>(<span class="variable">$connection</span>)</span><br><span class="line">&#123;</span><br><span class="line">    // 删除定时器</span><br><span class="line">    Timer::del(<span class="variable">$connection</span>-&gt;timer_id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 运行worker</span><br><span class="line">Worker::runAll();</span><br></pre></td></tr></table></figure></p><blockquote><p>更多示例：<a href="http://doc.workerman.net/timer/add.html" target="_blank" rel="noopener">http://doc.workerman.net/timer/add.html</a>  </p></blockquote><h4 id="del"><a href="#del" class="headerlink" title="del"></a>del</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean \Workerman\Lib\Timer::del(int <span class="variable">$timer_id</span>)</span><br></pre></td></tr></table></figure><p>删除某个定时器  </p><p><strong>示例</strong><br>定时器回调中删除当前定时器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">use \Workerman\Worker;</span><br><span class="line">use \Workerman\Lib\Timer;</span><br><span class="line">require_once __DIR__ . <span class="string">'/Workerman/Autoloader.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$task</span> = new Worker();</span><br><span class="line"><span class="variable">$task</span>-&gt;onWorkerStart = <span class="keyword">function</span>(<span class="variable">$task</span>)</span><br><span class="line">&#123;</span><br><span class="line">    // 注意，回调里面使用当前定时器id必须使用引用(&amp;)的方式引入</span><br><span class="line">    <span class="variable">$timer_id</span> = Timer::add(1, <span class="keyword">function</span>()use(&amp;<span class="variable">$timer_id</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        static <span class="variable">$i</span> = 0;</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$i</span>++.<span class="string">"\n"</span>;</span><br><span class="line">        // 运行10次后删除定时器</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$i</span> === 10)</span><br><span class="line">        &#123;</span><br><span class="line">            Timer::del(<span class="variable">$timer_id</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 运行worker</span><br><span class="line">Worker::runAll();</span><br></pre></td></tr></table></figure></p><h4 id="定时器注意事项"><a href="#定时器注意事项" class="headerlink" title="定时器注意事项"></a>定时器注意事项</h4><ol><li>只能在<code>onXXXX</code>回调中添加定时器。全局的定时器推荐在onWorkerStart回调中设置，针对某个连接的定时器推荐在onConnect中设置。  </li><li>添加的定时任务在当前进程执行(不会启动新的进程或者线程)，如果任务很重（特别是涉及到网络IO的任务），可能会导致该进程阻塞，暂时无法处理其它业务。所以最好将耗时的任务放到单独的进程运行，例如建立一个/多个Worker进程运行  </li><li>当前进程忙于其它业务时或者当一个任务没有在预期的时间运行完，这时又到了下一个运行周期，则会等待当前任务完成才会运行，这会导致定时器没有按照预期时间间隔运行。也就是说当前进程的业务都是串行执行的，如果是多进程则进程间的任务运行是并行的。  </li><li>多进程设置了定时任务造可能会造成并发问题  </li><li>可能会有1毫秒左右的误差  </li><li>定时器不能跨进程删除，例如a进程设置的定时器无法在b进程直接调用Timer::del接口删除  </li><li>不同进程间的定时器id可能会重复，但是同一个进程内产生的定时器id不会重复  </li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><p>注意：长连接应用必须加心跳，否则连接可能由于长时间未通讯被路由节点强行断开。  </p><p>心跳作用主要有两个：  </p><ol><li>客户端定时给服务端发送点数据，防止连接由于长时间没有通讯而被某些节点的防火墙关闭导致连接断开的情况。  </li><li>服务端可以通过心跳来判断客户端是否在线，如果客户端在规定时间内没有发来任何数据，就认为客户端下线。这样可以检测到客户端由于极端情况(断电、断网等)下线的事件。  </li></ol><p>建议值：<br>建议心跳间隔小于60秒  </p><p><strong>示例</strong><br>自动断开连接<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PhpStorm.</span></span><br><span class="line"><span class="comment"> * User: pengwenwu</span></span><br><span class="line"><span class="comment"> * Date: 2018/6/23</span></span><br><span class="line"><span class="comment"> * Time: 23:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="string">'./vendor/autoload.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Workerman</span>\<span class="title">Worker</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Workerman</span>\<span class="title">Lib</span>\<span class="title">Timer</span>;</span><br><span class="line"></span><br><span class="line">$ws_worker = <span class="keyword">new</span> Worker(<span class="string">"websocket://0.0.0.0:9501"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动4个进程对外提供服务</span></span><br><span class="line">$ws_worker-&gt;count = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 心跳间隔25秒</span></span><br><span class="line">define(<span class="string">'HEARTBEAT_TIME'</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">$ws_worker-&gt;onMessage = <span class="function"><span class="keyword">function</span> <span class="params">($connection, $data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给connection临时设置一个lastMessageTime属性，用来记录上次收到消息的时间</span></span><br><span class="line">    $connection-&gt;lastMessageTime = time();</span><br><span class="line">    <span class="comment">// 其它业务逻辑...</span></span><br><span class="line">    $connection-&gt;send(<span class="string">'hello'</span> . $data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程启动后设置一个每秒运行一次的定时器</span></span><br><span class="line">$ws_worker-&gt;onWorkerStart = <span class="function"><span class="keyword">function</span> <span class="params">($worker)</span> </span>&#123;</span><br><span class="line">    Timer::add(<span class="number">1</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($worker)</span> </span>&#123;</span><br><span class="line">        $time_now = time();</span><br><span class="line">        <span class="keyword">foreach</span> ($worker-&gt;connections <span class="keyword">as</span> $connection) &#123;</span><br><span class="line">            <span class="comment">// 有可能该connection还没收到过消息，则lastMessageTime设置为当前时间</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">empty</span>($connection-&gt;lastMessageTime)) &#123;</span><br><span class="line">                $connection-&gt;lastMessageTime = $time_now;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上次通讯时间间隔大于心跳间隔，则认为客户端已经下线，关闭连接</span></span><br><span class="line">            <span class="keyword">if</span> ($time_now - $connection-&gt;lastMessageTime &gt; HEARTBEAT_TIME) &#123;</span><br><span class="line">                $connection-&gt;close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Worker::runAll();</span><br></pre></td></tr></table></figure></p><blockquote><p>更多详细请参考官方手册</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;由于php不像nodejs、java一样可以常驻内存，没有现成的websock io，需要通过原生的php socket去实现服务端websocket的通信。对于菜鸟而言，还是使用现成的框架更方便，等水平足够了，才需要去考虑这些底层的实现  &lt;/p
      
    
    </summary>
    
      <category term="后端" scheme="https://pengwenwu.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="workerman" scheme="https://pengwenwu.github.io/tags/workerman/"/>
    
      <category term="websocket" scheme="https://pengwenwu.github.io/tags/websocket/"/>
    
      <category term="php" scheme="https://pengwenwu.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket入门</title>
    <link href="https://pengwenwu.github.io/2018/06/18/WebSocket%E5%85%A5%E9%97%A8/"/>
    <id>https://pengwenwu.github.io/2018/06/18/WebSocket入门/</id>
    <published>2018-06-18T14:21:16.000Z</published>
    <updated>2018-06-18T14:22:44.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要WebSocket？"><a href="#为什么需要WebSocket？" class="headerlink" title="为什么需要WebSocket？"></a>为什么需要WebSocket？</h1><p>虽然有HTTP协议，但是一个很明显的缺点是：所有请求只能有客户端发起，向服务端请求。而服务端有任何状态变化，无法直接通知到客户端。简单处理的方法就是<code>轮询</code>，连续不断发起请求，但是这个非常浪费资源，因为需要不断请求连接。最常见的例子就是聊天室。  </p><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>优点：</p><ul><li>支持双向通信，实时性更强  </li><li>更好的支持二进制  </li><li>较少的控制开销，数据交换时，数据包请求头较小</li><li>支持更多扩展</li></ul><p>websocket也是通过http请求去建立连接，请求格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET ws://localhost:3000/ws/chat HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Origin: http://localhost:3000</span><br><span class="line">Sec-WebSocket-Key: client-random-string</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></p><p>跟普通http请求的区别：  </p><ul><li>GET请求的地址不是类似<code>/path/</code>，而是以<code>ws://</code>开头的地址  </li><li>请求头<code>Upgrade: websocket</code>和<code>Connection: Upgrade</code>表示这个连接将要被转换为WebSocket连接  </li><li><code>Sec-WebSocket-Key</code>是用于标识这个连接，并非用于加密数据  </li><li><code>Sec-WebSocket-Version</code>指定了WebSocket的协议版本  </li><li>协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。  </li></ul><p>服务器返回数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: server-random-string</span><br></pre></td></tr></table></figure></p><p>该响应代码<code>101</code>表示本次连接的HTTP协议即将被更改，更改后的协议就是<code>Upgrade: websocket</code>指定的WebSocket协议  </p><p>成功建立连接后，客户端和服务端就可以直接主动发消息给对方。消息传递的格式有两种：文本，二进制数据.通常可以发送JSON数据，方便处理  </p><h2 id="WebSocket对象"><a href="#WebSocket对象" class="headerlink" title="WebSocket对象"></a>WebSocket对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSokcet(url, [protocol])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://echo.websocket.org'</span>, [<span class="string">'myProtocol1'</span>, <span class="string">'myProtocol2'</span>])</span><br></pre></td></tr></table></figure><p>WebSocket 构造函数可接受两个参数，其中，第一个参数必须是以 <code>ws://</code> 或 <code>wss://</code> 开头的完全限定的 URL<br>第二个为非必要参数，用于指定可接受的子协议，有两种可能的类型:  </p><ul><li>String 类型，值为客户端和服务器端均能理解的协议  </li><li>Arrary 类型，包含一组客户端支持的协议（String 类型）  </li></ul><h2 id="WebSocket-属性"><a href="#WebSocket-属性" class="headerlink" title="WebSocket 属性"></a>WebSocket 属性</h2><h3 id="Socket-readyState"><a href="#Socket-readyState" class="headerlink" title="Socket.readyState"></a>Socket.readyState</h3><p>只读属性 <code>readyState</code> 表示连接状态，可以是以下值：</p><ul><li>0 | WebSocket.CONNECTING：表示连接尚未建立  </li><li>1 | WebSocket.OPEN：表示连接已经建立  </li><li>2 | WebSocket.CLOSEING：表示连接正在关闭  </li><li>3 | WebSocket.CLOSED: 表示连接已经关闭或者连接不能打开  </li></ul><h3 id="bufferedAmount"><a href="#bufferedAmount" class="headerlink" title="bufferedAmount"></a>bufferedAmount</h3><p>WebSocket 对象的 <code>bufferedAmount</code> 属性可以用检查已经进入发送队列，但是还未发送到服务器的字节数。可以用来判断发送是否结束    </p><h3 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h3><p>WebSocket 对象的 <code>protocol</code> 属性值为 WebSocket 打开连接握手期间，服务器端所选择的<code>协议名</code>  </p><p>protocol 属性在最初的握手完成之前为空，如果服务器没有选择客户端提供的某个协议，则该属性保持空值</p><h2 id="WebSockets事件处理"><a href="#WebSockets事件处理" class="headerlink" title="WebSockets事件处理"></a>WebSockets事件处理</h2><p>WebSocket 对象具有以下 4 个事件：  </p><h3 id="open-事件"><a href="#open-事件" class="headerlink" title="open 事件"></a>open 事件</h3><p>当服务器响应了 WebSocket 连接请求，触发<code>open</code>事件并建立一个连接，此时WebSocket已经准备好发送和接收数据，open事件对应的回调函数是<code>onopen()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开启连接'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">ws.addEventListener(<span class="string">'open'</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开启连接'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><h3 id="message事件"><a href="#message事件" class="headerlink" title="message事件"></a>message事件</h3><p><code>message</code>事件在接收到消息是触发，消息内容存储在事件对象<code>event</code>的<code>data</code>中，对应的回调函数是<code>onmessage()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> event.data === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'接收到的string消息内容为：'</span> + event.data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'其他类型消息'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了普通文件，WebSocket消息内容还可以是二进制，这种数据作为<code>Blob</code>消息或者<code>ArraryBuffer</code>消息处理。暂不赘述。  </p><h3 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h3><p><code>error</code>事件在响应意外发生故障时触发，对应的回调函数是<code>onerror()</code>。错误会导致WebSocket连接关闭。  </p><h3 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h3><p><code>close</code>事件在连接关闭时触发，对应的回调函数是<code>onclose()</code>。一旦连接关闭，客户端和服务器端不在接续接收和发送消息。<br><code>close</code>事件的3个常用属性：  </p><ul><li><code>wasClean</code>：布尔值，表示连接是否被正确关闭。如果是来自服务器的close帧的响应，则为true；如果是因为其他原因关闭，则为false  </li><li><code>code</code>：服务器发送的关闭连接握手状态码  </li><li><code>reason</code>：服务器发送的关闭连接握手状态  </li></ul><h2 id="WebSocket方法"><a href="#WebSocket方法" class="headerlink" title="WebSocket方法"></a>WebSocket方法</h2><p>WebSocket API提供两个方法供调用。</p><h3 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h3><p>使用<code>send()</code>方法可以从客户端向服务端发送消息。前提是必须当WebSocket在客户端和服务端建立全双工双向连接后，才可以调用该方法。所以一般是在<code>open</code>事件触发之后，<code>close</code>触发之前调用<code>send()</code>发送消息<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = (event) &#123;</span><br><span class="line">    ws.send(<span class="string">'hello websocket'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>通过使用<code>close()</code>方法，可以人为的手动关闭WebSocket连接或者终止连接尝试。如果连接已关闭，则该方法什么也不做  </p><p>可以向<code>close()</code>方法传递两个参数：  </p><ul><li><code>code</code>：Number类型，状态代码  </li><li><code>reason</code>: String类型，文本字符串，传递一些关于关闭连接的信息  </li></ul><blockquote><p>参考链接：<br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">《WebSocket 教程 -  阮一峰》</a><br><a href="https://lfkid.github.io/2016/11/29/WebSocket%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E7%A8%8B/" target="_blank" rel="noopener">《WebSocket客户端编程》</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么需要WebSocket？&quot;&gt;&lt;a href=&quot;#为什么需要WebSocket？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要WebSocket？&quot;&gt;&lt;/a&gt;为什么需要WebSocket？&lt;/h1&gt;&lt;p&gt;虽然有HTTP协议，但是一个很明显的
      
    
    </summary>
    
      <category term="后端" scheme="https://pengwenwu.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="WebSocket" scheme="https://pengwenwu.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>使用laradock配置LNMP环境</title>
    <link href="https://pengwenwu.github.io/2018/06/10/%E4%BD%BF%E7%94%A8laradock%E9%85%8D%E7%BD%AELNMP%E7%8E%AF%E5%A2%83/"/>
    <id>https://pengwenwu.github.io/2018/06/10/使用laradock配置LNMP环境/</id>
    <published>2018-06-10T13:53:22.000Z</published>
    <updated>2018-06-10T14:00:48.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>laradock</code>是一个为php配置的完整的docker环境，可以通过修改配置文件，完成对不同版本、不同扩展、不同框架的php docker环境配置。从此对虚拟机说再见  </p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="clone到项目的同级目录"><a href="#clone到项目的同级目录" class="headerlink" title="clone到项目的同级目录"></a>clone到项目的同级目录</h2><p>或者使用<code>Git 子模块</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Laradock/laradock.git laradock</span><br></pre></td></tr></table></figure></p><p>这里使用CodeIgniter框架举个例子，目录结构是这样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|--- CodeIgniter</span><br><span class="line">|--- laradock</span><br></pre></td></tr></table></figure></p><h2 id="复制配置文件"><a href="#复制配置文件" class="headerlink" title="复制配置文件"></a>复制配置文件</h2><p><code>.env</code> 才是配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入laradockm目录</span></span><br><span class="line"><span class="built_in">cd</span> laradock</span><br><span class="line">cp env-example .env</span><br></pre></td></tr></table></figure></p><h2 id="增加配置参数"><a href="#增加配置参数" class="headerlink" title="增加配置参数"></a>增加配置参数</h2><p>如果需要使用mysql，redis等，<code>.env</code>需要新增配置HOST地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .env 末尾新增</span></span><br><span class="line">DB_HOST=mysql</span><br><span class="line">REDIS_HOST=redis</span><br><span class="line">QUEUE_HOST=rabbitmq</span><br></pre></td></tr></table></figure></p><h2 id="修改nginx默认挂在目录"><a href="#修改nginx默认挂在目录" class="headerlink" title="修改nginx默认挂在目录"></a>修改nginx默认挂在目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim laradock/nginx/sites/default.conf</span><br></pre></td></tr></table></figure><p>修改<code>default.conf</code>配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原配置</span></span><br><span class="line"><span class="comment"># root /var/www/public</span></span><br><span class="line">root /var/www/CodeIgniter</span><br></pre></td></tr></table></figure></p><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>这里有个坑，由于最近更新了mysql8，而laradoc的mysql中的Dockerfile默认是from latest拉去最新镜像，会导致<strong>mysql无法后台运行</strong>，秒退，应该是旧配置挂载问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d nginx mysql phpmyadmin redis workspace</span><br></pre></td></tr></table></figure></p><p>这里需要重新构建mysql<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build --build-arg MYSQL_VERSION=5.7 mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建完，重启容器</span></span><br><span class="line">docker-compose up -d mysql</span><br></pre></td></tr></table></figure></p><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>可以通过<code>docker-compose ps</code>查看各个容器运行状态，以及暴露的端口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        Name                      Command               State                    Ports</span><br><span class="line">--------------------------------------------------------------------------------------------------------</span><br><span class="line">laradoc_mysql_1        docker-entrypoint.sh mysqld      Up      0.0.0.0:3306-&gt;3306/tcp</span><br><span class="line">laradoc_nginx_1        nginx                            Up      0.0.0.0:443-&gt;443/tcp, 0.0.0.0:80-&gt;80/tcp</span><br><span class="line">laradoc_php-fpm_1      docker-php-entrypoint php-fpm    Up      9000/tcp</span><br><span class="line">laradoc_phpmyadmin_1   /run.sh phpmyadmin               Up      0.0.0.0:8080-&gt;80/tcp, 9000/tcp</span><br><span class="line">laradoc_redis_1        docker-entrypoint.sh redis ...   Up      0.0.0.0:6379-&gt;6379/tcp</span><br><span class="line">laradoc_workspace_1    /sbin/my_init                    Up      0.0.0.0:2222-&gt;22/tcp</span><br></pre></td></tr></table></figure></p><p>这里看到，nginx默认80端口，打开浏览器，输入localhost即可访问，正常返回的是CI框架的默认首页  </p><blockquote><p>Welcome to CodeIgniter!  </p></blockquote><p>phpmyadmin的端口是8080，浏览器输入localhost:8080，则可以访问phpmyadmin。服务器地址是之前配置的 DB_HOST = <code>mysql</code>，账号密码可以查看<code>.env</code>配置文件，默认是<code>root</code> <code>root</code>，这些都是可以在启动命令的参数里设置</p><p>参考链接：<a href="http://laradock.io/" target="_blank" rel="noopener">《Laradock》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;laradock&lt;/code&gt;是一个为php配置的完整的docker环境，可以通过修改配置文件，完成对不同版本、不同扩展、不同框
      
    
    </summary>
    
      <category term="Docker" scheme="https://pengwenwu.github.io/categories/Docker/"/>
    
    
      <category term="PHP" scheme="https://pengwenwu.github.io/tags/PHP/"/>
    
      <category term="Docker" scheme="https://pengwenwu.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>git子模块</title>
    <link href="https://pengwenwu.github.io/2018/06/10/git%E5%AD%90%E6%A8%A1%E5%9D%97/"/>
    <id>https://pengwenwu.github.io/2018/06/10/git子模块/</id>
    <published>2018-06-10T04:53:12.000Z</published>
    <updated>2018-06-10T05:03:17.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h1><p>文档：<a href="https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">Git 工具 - 子模块</a>  </p><blockquote><p>在一个项目中要引入另外一个项目，比如我在当前项目里，想要引入laradock docker环境，需要怎么操作？难道需要copy一份代码过来？怎么保证同步更新？  </p></blockquote><h2 id="添加子模块"><a href="#添加子模块" class="headerlink" title="添加子模块"></a>添加子模块</h2><p>在当前项目中执行<code>git submodule add</code>命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/Laradock/laradock.git laradock</span><br></pre></td></tr></table></figure></p><p>此时，会在当前项目下新建一个<code>laradock</code>项目，执行<code>git status</code>会看到下面两项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   .gitmodules</span><br><span class="line">        new file:   laradock</span><br></pre></td></tr></table></figure></p><p><code>.gitmodules</code>是一个配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitmodules</span><br><span class="line">[submodule <span class="string">"laradock"</span>]</span><br><span class="line">        path = laradock</span><br><span class="line">        url = https://github.com/Laradock/laradock.git</span><br></pre></td></tr></table></figure></p><p>如果此时，同时修改原项目文件，以及子项目文件，执行<code>git diff</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index e02af03..a6a0276 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1,2 +1,4 @@</span><br><span class="line"> <span class="comment"># bbs</span></span><br><span class="line"> 基于CodeIgniter框架开发的bbs系统</span><br><span class="line">+</span><br><span class="line">+&gt; 新增laradock项目引入</span><br><span class="line">diff --git a/laradock b/laradock</span><br><span class="line">--- a/laradock</span><br><span class="line">+++ b/laradock</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-Subproject commit 66c61d9a72ea52ab04ddb1999b0998f7ba10a0e4</span><br><span class="line">+Subproject commit 66c61d9a72ea52ab04ddb1999b0998f7ba10a0e4-dirty</span><br></pre></td></tr></table></figure></p><h2 id="修改submodule"><a href="#修改submodule" class="headerlink" title="修改submodule"></a>修改submodule</h2><p>需要进入到对应的子项目目录去修改,提交完毕之后，回到父级项目提交。</p><h2 id="新clone-submodule项目"><a href="#新clone-submodule项目" class="headerlink" title="新clone submodule项目"></a>新clone submodule项目</h2><p>先clone父级项目，然后进入子项目，发现时空文件夹，需要依次执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在子项目目录</span></span><br><span class="line">git submodule init  </span><br><span class="line"></span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure></p><h2 id="删除submodule"><a href="#删除submodule" class="headerlink" title="删除submodule"></a>删除submodule</h2><p>git 并不支持<code>直接删除</code>Submodule, 需要手动删除对应的文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入父级项目</span></span><br><span class="line">git rm --cached pod-library</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除子项目</span></span><br><span class="line">rm -rf pod-library</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除子项目配置文件</span></span><br><span class="line">rm .gitmodules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改git的配置文件config:</span></span><br><span class="line">vim .git/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除父级项目git配置中的子项目配置</span></span><br><span class="line">[submodule <span class="string">"pod-library"</span>]</span><br><span class="line">  url = git@github.com:jjz/pod-library.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成新的提交</span></span><br></pre></td></tr></table></figure></p><p>参考资料：<a href="https://segmentfault.com/a/1190000003076028" target="_blank" rel="noopener">使用Git Submodule管理子模块</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;子模块&quot;&gt;&lt;a href=&quot;#子模块&quot; class=&quot;headerlink&quot; title=&quot;子模块&quot;&gt;&lt;/a&gt;子模块&lt;/h1&gt;&lt;p&gt;文档：&lt;a href=&quot;https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-
      
    
    </summary>
    
      <category term="Git" scheme="https://pengwenwu.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://pengwenwu.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>dokcer入门篇</title>
    <link href="https://pengwenwu.github.io/2018/06/07/dokcer%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>https://pengwenwu.github.io/2018/06/07/dokcer入门篇/</id>
    <published>2018-06-07T12:35:34.000Z</published>
    <updated>2018-06-07T12:56:30.005Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://docker_practice.gitee.io/" target="_blank" rel="noopener">阅读《Docker — 从入门到实践》</a>  </p></blockquote><h1 id="windows使用"><a href="#windows使用" class="headerlink" title="windows使用"></a>windows使用</h1><ul><li>下载docker for windows，安装 </li><li>使用镜像加速，我自己使用的是<a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云镜像加速</a>setting-&gt;Daemon-&gt;Registry mirrors-&gt;粘贴自己的加速器地址 </li><li>可以使用gui界面，Kitematic</li></ul><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>可以使用<code>docker pull --help</code>查看<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br><span class="line"></span><br><span class="line"><span class="comment"># etc</span></span><br><span class="line">docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm ubuntu:16.04 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前系统版本</span></span><br><span class="line">cat /etc/os-release</span><br></pre></td></tr></table></figure><ul><li><code>-it</code>: <code>-i</code>: 交互式操作, <code>-t</code>: 终端 </li><li><code>--rm</code>: 执行退出后删除该容器实例</li><li><code>bash</code>: shell使用的方式 </li></ul><h2 id="镜像列表"><a href="#镜像列表" class="headerlink" title="镜像列表"></a>镜像列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># etc</span></span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span><br></pre></td></tr></table></figure><p>各列意义：<code>仓库名</code>, <code>标签</code>, <code>镜像id</code>, <code>创建时间</code>, <code>解压后文件大小</code><br><strong>镜像ID 则是镜像的唯一标识，一个镜像可以对应多个标签</strong> </p><h2 id="镜像大小"><a href="#镜像大小" class="headerlink" title="镜像大小"></a>镜像大小</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><h2 id="启动已终止的container镜像"><a href="#启动已终止的container镜像" class="headerlink" title="启动已终止的container镜像"></a>启动已终止的container镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] start</span><br></pre></td></tr></table></figure><h2 id="后台运行容器"><a href="#后台运行容器" class="headerlink" title="后台运行容器"></a>后台运行容器</h2><p><code>-d</code>参数能够让容器后台运行，保证输出结果不会打印出来。但容器是否长久运行（一直后台挂起），跟<code>-d</code>参数无关，需要一直有指令执行，才不会“秒退”<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -c exec执行</span></span><br><span class="line">docker run ubuntu:17.10 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line">docker run -d ubuntu:17.10 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure></p><p>可以通过<code>docker [container] logs</code>去查看容器输出信息 </p><h2 id="终止运行"><a href="#终止运行" class="headerlink" title="终止运行"></a>终止运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [contanier] stop</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker attach </span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐使用</span></span><br><span class="line">docker <span class="built_in">exec</span> -it [container id] /bin/bash</span><br></pre></td></tr></table></figure><p>两者的区别：前者exit退出后，会停止当前容器；而<code>exec</code>仍然会保持运行 </p><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container rm </span><br><span class="line"></span><br><span class="line"><span class="comment"># 清楚所有处于终止状态的容器</span></span><br><span class="line">docker container prune</span><br></pre></td></tr></table></figure><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p><strong>为什么不建议使用<code>docker commit</code>?</strong><br>使用<code>docker commit</code>提交后，对于其他使用者而言，这个image镜像是一个黑箱，别人无处得知执行过什么命令、如何生成的镜像 </p><h2 id="Dokcerfile-定制镜像"><a href="#Dokcerfile-定制镜像" class="headerlink" title="Dokcerfile 定制镜像"></a>Dokcerfile 定制镜像</h2><h3 id="FROM指定基础镜像"><a href="#FROM指定基础镜像" class="headerlink" title="FROM指定基础镜像"></a>FROM指定基础镜像</h3><h3 id="RUN执行命令"><a href="#RUN执行命令" class="headerlink" title="RUN执行命令"></a>RUN执行命令</h3><ul><li>shell格式：<code>RUN &lt;命令&gt;</code> </li><li>exec格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code> </li></ul><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># etc, 注意镜像构建上下文(context)</span></span><br><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h2><h3 id="CMD-启动命令"><a href="#CMD-启动命令" class="headerlink" title="CMD 启动命令"></a>CMD 启动命令</h3><p><code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的，也分为<code>shell</code>格式以及<code>exec</code>格式 </p><ul><li>shell格式：CMD &lt;命令&gt; </li><li>exec格式：CMD [“可执行文件”, “参数1”, “参数2”…] </li><li>参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数 </li></ul><p>一般<code>推荐</code>使用<code>exec</code>格式，这类格式在解析时会被解析成JSON数组，因此要使用<code>双引号</code> </p><p>如果是<code>shell</code>格式，实际会被包装成<code>sh -c</code>的格式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD <span class="built_in">echo</span> <span class="variable">$HOME</span></span><br></pre></td></tr></table></figure></p><p>实际执行会变成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo <span class="variable">$HOME</span>"</span> ]</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：Docker不是虚拟机，容器中的应用都是<code>前台执行</code>，没有后台服务的概念 </p><p>错误示范：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure></p><p>这里容器执行后会秒退出，因为上面的命令会被转化为<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start]</code>，主进程是<code>sh</code>，当service nginx start执行结束后，sh也就结束了，sh作为主进程结束，所以容器也会退出</p><p>正确做法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ <span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span> ]</span><br></pre></td></tr></table></figure></p><p>这边执行<code>docker run</code>的时候，不需要再跟<code>/bin/bash</code>启动命令，因为会覆盖。否则就是秒结束进程</p><h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p>如果指定了<code>ENTRYPOINT</code>，<code>CMD</code>就不会直接执行命令，而是讲内容作为参数传给<code>ENTRYPOINT</code>，实际执行指令会变为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT <span class="string">"&lt;CMD&gt;"</span></span><br></pre></td></tr></table></figure></p><h4 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run myip -i</span><br></pre></td></tr></table></figure><h4 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h4><p>在启动主进程之前，需要一些准备工作，比如数据库的配置、初始化 </p><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>两种格式：</p><ul><li>ENV \<key\> \<value\></value\></key\></li><li>ENV \<key1\>=\<value1\> \<key2>=\<value2\> … <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 含有空格的值使用双引号</span></span><br><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">    NAME=<span class="string">"Happy Feet"</span></span><br></pre></td></tr></table></figure></value2\></key2></value1\></key1\></li></ul><h3 id="ARG构建参数"><a href="#ARG构建参数" class="headerlink" title="ARG构建参数"></a>ARG构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code> </p><p>构建参数和ENV效果一样，都是设置环境变量，唯一的区别是，<code>ARG</code>构建的环境变量，在将来容器运行的时候，不会存储这些环境变量 </p><p><code>Dokcerfile</code>中的<code>ARG</code>指令是定义参数名称，以及其默认值。可以通过构建命令<code>docker build</code>中用<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖 </p><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p><ul><li>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]</li><li>VOLUME &lt;路径&gt; </li></ul><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure><p>这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure><p>这里mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置 </p><h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式为：<code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code> </p><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处: </p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射 </li><li>在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口 </li></ul><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 </p><h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为: <code>WORKDIR &lt;工作目录路径&gt;</code> </p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录 </p><h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式：<code>USER &lt;用户名&gt;</code> </p><p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份 </p><h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h3><p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常 </p><p>格式： </p><ul><li>HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</li><li>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 </li></ul><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code> </p><p><code>NOBUILD</code>指令是别人定制镜像。即使用<code>FROM</code>的时候，才执行的命令 </p><h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先打标签</span></span><br><span class="line">docker tag ubuntu:17.10 username/ubuntu:17.10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在push</span></span><br><span class="line">docker push username/ubuntu:17.10</span><br></pre></td></tr></table></figure><h2 id="配置私有仓库"><a href="#配置私有仓库" class="headerlink" title="配置私有仓库"></a>配置私有仓库</h2><p><a href="https://docker_practice.gitee.io/repository/registry.html" target="_blank" rel="noopener">配置私有仓库</a> </p><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录： </p><ul><li><code>数据卷</code>可以在容器之间共享和重用 </li><li>对 <code>数据卷</code> 的修改会立马生效 </li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会一直存在，即使容器被删除 <blockquote><p>注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷。 </p></blockquote></li></ul><h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>使用<code>- P</code>标记时，Docker会随机映射 <code>49000~49900</code> 的端口到内部容器开放的网络端口 </p><p><code>- p</code>可以指定要映射的端口，也可以指定地址<br><code>ip:hostPort:containerPort</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p><code>docker port</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port nostalgic_morse 5000</span><br></pre></td></tr></table></figure></p><ul><li>容器有自己的内部网络和 ip 地址 </li><li><code>-p</code> 标记可以多次使用来绑定多个端口 </li></ul><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><h3 id="查看已有网络"><a href="#查看已有网络" class="headerlink" title="查看已有网络"></a>查看已有网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><h3 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge my-net</span><br></pre></td></tr></table></figure><p><code>-d</code> 可以指定Docker网络类型，有<code>bridge</code>, <code>overlay</code>，其中 <code>overlay</code> 网络类型用于 <code>Swarm mode</code>(<strong>集群服务</strong>) </p><h3 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h3><p>运行一个容器并连接到新建的 <code>my-net</code> 网络<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --name busybox1 --network my-net busybox sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再运行一个容器</span></span><br><span class="line">docker run -it --rm --name busybox2 --network my-net busybox sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试连接</span></span><br><span class="line"><span class="comment"># 在busybox1 容器里，执行</span></span><br><span class="line"><span class="comment"># /ping busybox2</span></span><br><span class="line">PING busybox2 (172.19.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.060 ms</span><br><span class="line">64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.046 ms</span><br><span class="line">64 bytes from 172.19.0.3: seq=2 ttl=64 time=0.075 ms</span><br></pre></td></tr></table></figure></p><h1 id="Compose-项目"><a href="#Compose-项目" class="headerlink" title="Compose 项目"></a>Compose 项目</h1><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。<br><code>Compose</code> 中有两个重要的概念： </p><ul><li><code>服务 (service)</code>：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。 </li><li><code>项目 (project)</code>：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。 </li></ul><p><code>Compose</code> 的默认管理对象是<code>项目</code>，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><h2 id="Compose-命令说明"><a href="#Compose-命令说明" class="headerlink" title="Compose 命令说明"></a>Compose 命令说明</h2><h3 id="命令对象与格式"><a href="#命令对象与格式" class="headerlink" title="命令对象与格式"></a>命令对象与格式</h3><p><code>docker-compose</code> 命令的基本的使用格式是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure></p><h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><ul><li>-f, –file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。 </li><li>-p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。 </li><li>–x-networking 使用 Docker 的可拔插网络后端特性 </li><li>–x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge </li><li>–verbose 输出更多调试信息。 </li><li>-v, –version 打印版本并退出 </li></ul><h3 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h3><p><strong>Tips</strong>: 这里的<code>service name</code>是指<code>服务</code>的名称，不是container name 或者 container id</p><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>构建（重新构建）项目中的服务容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build [options] [SERVICE...]</span><br></pre></td></tr></table></figure></p><p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db<br>选项包括：</p><ul><li><code>--force-rm</code> 删除构建过程中的临时容器 </li><li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程） </li><li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像</li></ul><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因 </p><h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络 </p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>进入指定的容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果执行/bin/bash失败，报错OCI runtime exec failed,是因为bash不存在，替换成sh   </span></span><br><span class="line"></span><br><span class="line">docker-compose <span class="built_in">exec</span> web /bin/sh</span><br></pre></td></tr></table></figure></p><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><p>列出 Compose 文件中包含的镜像 </p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>格式为 <code>docker-compose kill [options] [SERVICE...]</code> </p><p>通过发送 SIGKILL 信号来强制停止服务容器 </p><p>支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose <span class="built_in">kill</span> -s SIGINT</span><br></pre></td></tr></table></figure><h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><p>查看服务容器的输出。<br>默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 –no-color 来关闭颜色。  </p><p>格式为：<code>docker-compose logs [options] [SERVICE...]</code> </p><h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h3><p>暂停服务<br>格式为：<code>docker-compose pause [SERVICE...]</code> </p><h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>打印某个容器端口所映射的公共端口 </p><p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code> </p><p>选项：</p><ul><li>–protocol=proto 指定端口协议，tcp（默认值）或者 udp。</li><li>–index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1） </li></ul><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run ubuntu ping docker.com</span><br></pre></td></tr></table></figure></p><p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p><p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p><p>两个不同点：</p><p>给定命令将会覆盖原有的自动运行命令；</p><p>不会自动创建端口，以避免冲突。</p><p>如果不希望自动启动关联的容器，可以使用 –no-deps 选项，例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run --no-deps web python manage.py shell</span><br></pre></td></tr></table></figure></p><p>将不会启动 web 容器所关联的其它容器. </p><p>选项：</p><ul><li>-d 后台运行容器。</li><li>–name NAME 为容器指定一个名字。</li><li>–entrypoint CMD 覆盖默认的容器启动指令。</li><li>-e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。</li><li>-u, –user=”” 指定运行容器的用户名或者 uid。</li><li>–no-deps 不自动启动关联的服务容器。</li><li>–rm 运行命令后自动删除容器，d 模式下将忽略。</li><li>-p, –publish=[] 映射容器端口到本地主机。</li><li>–service-ports 配置服务端口并映射到本地主机。</li><li>-T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。 </li></ul><h3 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h3><p>设置指定服务运行的容器个数 </p><p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code> </p><p>通过 <code>service=num</code> 的参数来设置数量。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose scale web=3 db=2</span><br></pre></td></tr></table></figure></p><p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。 </p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><h3 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a>unpause</h3><p>启动已暂停的服务 </p><h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><p>格式为 <code>docker-compose up [options] [SERVICE...]</code> </p><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作 </p><p>链接的服务都将会被自动启动，除非已经处于运行状态 </p><p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试 </p><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。 </p><p>选项：</p><ul><li>-d 在后台运行服务容器。</li><li>–no-color 不使用颜色来区分不同的服务的控制台输出。</li><li>–no-deps 不启动服务所链接的容器。</li><li>–force-recreate 强制重新创建容器，不能与 –no-recreate 同时使用。</li><li>–no-recreate 如果容器已经存在了，则不重新创建，不能与 –force-recreate 同时使用。</li><li>–no-build 不自动构建缺失的服务镜像。</li><li>-t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）</li></ul><h2 id="Compose-模板文件"><a href="#Compose-模板文件" class="headerlink" title="Compose 模板文件"></a>Compose 模板文件</h2><p>模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 docker run 相关参数的含义都是类似的。 </p><p>默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure></p><p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像 </p><p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中再次设置。 </p><h3 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h3><p>指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。 </p><p>可以使用 <code>context</code> 指令指定 Dockerfile 所在文件夹的路径 </p><p>使用 <code>dockerfile</code> 指令指定 Dockerfile 文件名 </p><p>使用 <code>arg</code> 指令指定构建镜像时的变量 </p><p>使用 <code>cache_from</code> 指定构建镜像的缓存<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  cache_from:</span><br><span class="line">    - alpine:latest</span><br><span class="line">    - corp/web_app:3.14</span><br></pre></td></tr></table></figure></p><h3 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a>cap_add, cap_drop</h3><p>指定容器的内核能力（capacity）分配 </p><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>覆盖容器启动后默认执行的命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span>: <span class="built_in">echo</span> <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure></p><h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: docker-web-container</span><br></pre></td></tr></table></figure></p><blockquote><p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称 </p></blockquote><h3 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h3><p>指定设备映射关系。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices:</span><br><span class="line">  - <span class="string">"/dev/ttyUSB1:/dev/ttyUSB0"</span></span><br></pre></td></tr></table></figure></p><h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h3><p>解决容器的依赖、启动先后的问题。<br>以下例子中会先启动 redis db 再启动 web<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。 </p></blockquote><h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h3><p>自定义 <code>DNS</code> 服务器。可以是一个值，也可以是一个列表。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 114.114.114.114</span><br></pre></td></tr></table></figure></p><h3 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h3><p>从文件中获取环境变量，可以为单独的文件路径或列表。 </p><p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径 </p><p>如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure><p>环境变量文件中每一行必须符合格式，支持 # 开头的注释行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure></p><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>设置环境变量。可以使用数组或字典两种格式 </p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SESSION_SECRET:</span><br><span class="line"></span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SESSION_SECRET</span><br></pre></td></tr></table></figure><p>如果变量名称或者值中用到 true|false，yes|no 等表达 <code>布尔</code> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。 </p><h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>暴露端口，但不映射到宿主机，只被连接的服务访问 </p><p>仅可以指定内部端口为参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - <span class="string">"3000"</span></span><br><span class="line"> - <span class="string">"8000"</span></span><br></pre></td></tr></table></figure><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>指定为镜像名称或镜像 ID </p><h3 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h3><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。 </p><p>例如，下面的 Compose 文件将从运行它的环境中读取变量 <code>${MONGO_VERSION}</code> 的值，并写入执行的指令中。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"3"</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">db:</span><br><span class="line">  image: <span class="string">"mongo:<span class="variable">$&#123;MONGO_VERSION&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>如果执行 <code>MONGO_VERSION=3.2</code> <code>docker-compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；如果执行 <code>MONGO_VERSION=2.8</code> docker-compose up 则会启动一个 <code>mongo:2.8</code> 镜像的容器。 </p><p>若当前目录存在 <code>.env</code> 文件，执行 docker-compose 命令时将从该文件中读取变量。</p><p>在当前目录新建 <code>.env</code> 文件并写入以下内容。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持 # 号注释</span></span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure></p><p>执行 docker-compose up 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="常见问题总结"><a href="#常见问题总结" class="headerlink" title="常见问题总结"></a>常见问题总结</h2><p><a href="https://docker_practice.gitee.io/appendix/faq/" target="_blank" rel="noopener">常见问题总结</a></p><h2 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h2><p><a href="https://docker_practice.gitee.io/appendix/resources/" target="_blank" rel="noopener">资源链接</a> </p><h2 id="进阶深入"><a href="#进阶深入" class="headerlink" title="进阶深入"></a>进阶深入</h2><p>进阶深入，参考原文档<a href="https://docker_practice.gitee.io/" target="_blank" rel="noopener">《Docker — 从入门到实践》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://docker_practice.gitee.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阅读《Docker — 从入门到实践》&lt;/a&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 i
      
    
    </summary>
    
      <category term="后端" scheme="https://pengwenwu.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Docker" scheme="https://pengwenwu.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>js和php闭包使用和区别</title>
    <link href="https://pengwenwu.github.io/2018/05/25/js%E5%92%8Cphp%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>https://pengwenwu.github.io/2018/05/25/js和php闭包使用和区别/</id>
    <published>2018-05-24T16:14:40.000Z</published>
    <updated>2018-06-07T12:43:06.466Z</updated>
    
    <content type="html"><![CDATA[<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><blockquote><p>如果只是省去函数名，单纯的当作一个函数式方法返回，只能称为匿名函数（闭包需要将匿名函数当作结果返回），比如：  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>));  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// php</span></span><br><span class="line">$foo = <span class="function"><span class="keyword">function</span><span class="params">($a, $b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $a + $b;</span><br><span class="line">&#125;; <span class="comment">// 一定要加分号</span></span><br><span class="line"><span class="keyword">echo</span> $foo(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote><p>闭包通常是用来创建内部变量，使得这些变量不得被外部随意修改，而只能通过指定的函数接口去修改  </p></blockquote><h4 id="js闭包"><a href="#js闭包" class="headerlink" title="js闭包"></a>js闭包</h4><p>这里举一个阮老师博客里的例子，<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html?20120612141317#comments" target="_blank" rel="noopener">阮老师博客：学习Javascript闭包（Closure）</a>  </p><h5 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a>js基础</h5><p>参考链接：<a href="https://github.com/creeperyang/blog/issues/16" target="_blank" rel="noopener">深入理解JS中声明提升、作用域（链）和<code>this</code>关键字</a>  </p><ul><li>js比较特殊的一点是：函数内部可以直接读取到全局变量（对于阮老师的这句话不是很能理解，大概是想表达的意思：父作用域的变量可以在子作用域直接访问，而不需要去声明访问真正的全局变量？） <ul><li>大部分语言，变量都是先声明在使用，而对于js，具有声明提升的特性（不管在哪里声明，都会在代码执行前处理）</li><li>函数和变量的声明总是会隐式地被移动到当前作用域的顶部，函数的声明优先级高于变量的声明</li><li>var 会在当前作用域声明一个变量，而未声明的变量，会隐式地创建一个全局变量  </li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明提升</span></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// 1, 未报错</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上文链接中的例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testOrder</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg); <span class="comment">// arg是形参，不会被重新定义</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 因为函数声明比变量声明优先级高，所以这里a是函数</span></span><br><span class="line">    <span class="keyword">var</span> arg = <span class="string">'hello'</span>; <span class="comment">// var arg;变量声明被忽略， arg = 'hello'被执行</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// var a;被忽视; a = 10被执行，a变成number</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fun'</span>);</span><br><span class="line">    &#125; <span class="comment">// 被提升到作用域顶部</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 输出10</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg); <span class="comment">// 输出hello</span></span><br><span class="line">&#125;; </span><br><span class="line">testOrder(<span class="string">'hi'</span>);</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">hi </span></span><br><span class="line"><span class="comment">function a() &#123;</span></span><br><span class="line"><span class="comment">        console.log('fun');</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">10 </span></span><br><span class="line"><span class="comment">hello </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 局部作用域</span></span><br><span class="line">    foo = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">foo; <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line">foo = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 局部作用域</span></span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">foo; <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><ul><li>js变量的查找是从里往外的，直到最顶层（全局作用域），并且一旦找到，即停止向上查找。所有内部函数可以访问函数外部的变量，反之无效  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    bar(b * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//a is not defined</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    addNum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 这里未通过var去声明，默认是全局变量</span></span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foo2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tmp = foo1();</span><br><span class="line">tmp();  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">addNum();</span><br><span class="line">tmp(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>这里第二次调用foo2函数，foo1函数的局部变量num并没有被初始化为0，说明打印的是内存中的num。正常函数在每次调用结束后都会销毁局部变量，在重新调用的时候会再次声明变量；而这边没有重新声明的原因是：把foo2函数赋值给了一个全局变量tmp，导致foo2函数一直存在内存中，而foo2函数依赖于foo1函数存在，所以foo1函数也存在内存中，并没有被销毁，所以foo1的局部变量也是存在内存中。  </p></blockquote><ul><li><code>this</code>的上下文基于函数调用的情况。和函数在哪定义无关，而和函数怎么调用有关。<ul><li>在全局上下文（任何函数以外），this指向全局对象(windows)</li><li>在函数内部时，this由函数怎么调用来确定<ul><li>当函数作为对象方法调用时，this指向该对象  </li></ul></li></ul></li></ul><p>下面是阮老师博客里的两个思考题：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">　　name : <span class="string">"My Object"</span>,</span><br><span class="line">　　getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">// The Window</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">"My Object"</span>,</span><br><span class="line">　　getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　    <span class="keyword">return</span> that.name;</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());<span class="comment">// My Object</span></span><br></pre></td></tr></table></figure><blockquote><p><code>this</code>的作用域好像一直是个比较奇怪的东西，对于上面两个例子，我的理解是：第一个例子，是在方法里调用的<code>this</code>，而这个<code>this</code>并没有<code>声明</code>，会隐式地创建一个全局变量，所以调用的全局的name；第二个，调用的<code>that</code>的时候，会向顶级链式查找是否声明<code>that</code>，而这个that有this赋值，这里的this又是通过对象方法调用，则该this指向这个object对象，所有最终调用的是object作用域内的name。不知道这么理解是不是有问题，还望大神指正。  </p></blockquote><p><strong>那其实js闭包的主要目的：访问函数内部的局部变量，即延长作用域链</strong><br>参考链接：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">js闭包MDN文档</a>  </p><h4 id="php闭包"><a href="#php闭包" class="headerlink" title="php闭包"></a>php闭包</h4><h5 id="php回调函数"><a href="#php回调函数" class="headerlink" title="php回调函数"></a>php回调函数</h5><p><a href="http://php.net/manual/zh/function.call-user-func.php" target="_blank" rel="noopener">mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $… ]] )</a><br><a href="http://php.net/manual/zh/function.call-user-func-array.php" target="_blank" rel="noopener">mixed call_user_func_array ( callable $callback , array $param_arr )</a>  </p><p>这两个函数都是把第一个参数作为回调函数d调用，后面接收参数，区别就是第二个函数第二参数接收数组；在使用上唯一的区别就是，<code>call_user_func</code>函数无法接收<code>引用传递</code>; 个人觉得同样是使用，call_user_func 相比call_user_func_array完全可以被替代，不知道是不是有一些性能上的优势。具体使用样例，请参考官方文档。  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(&amp;$a, &amp;$b)</span> </span>&#123;</span><br><span class="line">    $a ++;</span><br><span class="line">    $b --;</span><br><span class="line">&#125;;</span><br><span class="line">$a = $b = <span class="number">10</span>;</span><br><span class="line">call_user_func_array(<span class="string">'foo'</span>, [&amp;$a, &amp;$b]);</span><br><span class="line"><span class="keyword">echo</span> $a.<span class="string">"\n"</span>, $b; <span class="comment">// 11, 9</span></span><br></pre></td></tr></table></figure><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>基本用法，跟js的闭包类似  </p><ul><li>普通调用  </li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">global</span> $tmp = <span class="string">'hello world'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    var_dump(<span class="keyword">global</span> $tmp);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// null, 函数内部无法直接调用上级作用域的变量，除非声明为全局变量</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$foo1 = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $a = <span class="number">10</span>;</span><br><span class="line">    $foo2 = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        var_dump($a);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> $foo2;</span><br><span class="line">&#125;;</span><br><span class="line">$tmp = $foo1();</span><br><span class="line">$tmp();  <span class="comment">// null，原因同上</span></span><br></pre></td></tr></table></figure><ul><li>php想要能够获取上级作用域的变量，需要通过use传递  </li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$foo1 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $a = <span class="number">10</span>;</span><br><span class="line">    $foo2 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($a)</span> </span>&#123;</span><br><span class="line">        var_dump($a);</span><br><span class="line">        $a ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    $foo2();</span><br><span class="line">    <span class="keyword">return</span> $foo2;</span><br><span class="line">&#125;;</span><br><span class="line">$tmp = $foo1();</span><br><span class="line">$tmp();  <span class="comment">// 10, 10,  use并不能实际改变变量的值，只是值传递</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$foo1 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $a = <span class="number">10</span>;</span><br><span class="line">    $foo2 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">(&amp;$a)</span> </span>&#123;</span><br><span class="line">        var_dump($a);</span><br><span class="line">        $a ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    $foo2();</span><br><span class="line">    <span class="keyword">return</span> $foo2;</span><br><span class="line">&#125;;</span><br><span class="line">$tmp = $foo1();</span><br><span class="line">$tmp();  <span class="comment">// 10, 11,  通过值传递改变变量的值</span></span><br></pre></td></tr></table></figure><ul><li>下面两段代码的区别，不是很明白，望大佬指点，为什么后一个值传递就可以获取到已经改变后变量的值。好像都是在调用方法之前，已经执行过变量的递增了吧？  </li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 值传递</span></span><br><span class="line">$foo1 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $a = <span class="number">10</span>;</span><br><span class="line">    $foo2 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($a)</span> </span>&#123;</span><br><span class="line">        var_dump($a);</span><br><span class="line">    &#125;;</span><br><span class="line">    $a ++;</span><br><span class="line">    <span class="keyword">return</span> $foo2;</span><br><span class="line">&#125;;</span><br><span class="line">$tmp = $foo1();</span><br><span class="line">$tmp();  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 引用传递</span></span><br><span class="line">$foo1 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $a = <span class="number">10</span>;</span><br><span class="line">    $foo2 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">(&amp;$a)</span> </span>&#123;</span><br><span class="line">        var_dump($a);</span><br><span class="line">    &#125;;</span><br><span class="line">    $a ++;</span><br><span class="line">    <span class="keyword">return</span> $foo2;</span><br><span class="line">&#125;;</span><br><span class="line">$tmp = $foo1();</span><br><span class="line">$tmp();  <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><ul><li>正确使用  </li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 值传递</span></span><br><span class="line">$foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $a = <span class="number">10</span>;</span><br><span class="line">    $foo2 = <span class="function"><span class="keyword">function</span> <span class="params">($num)</span> <span class="title">use</span> <span class="params">($a)</span> </span>&#123;</span><br><span class="line">        var_dump($num + $a);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> $foo2;</span><br><span class="line">&#125;;</span><br><span class="line">$tmp = $foo();</span><br><span class="line">$tmp(<span class="number">100</span>); <span class="comment">// 110</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 引用传递</span></span><br><span class="line">$foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $a = <span class="number">10</span>;</span><br><span class="line">    $foo2 = <span class="function"><span class="keyword">function</span> <span class="params">($num)</span> <span class="title">use</span> <span class="params">(&amp;$a)</span> </span>&#123;</span><br><span class="line">        var_dump($num + $a);</span><br><span class="line">$a ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> $foo2;</span><br><span class="line">&#125;;</span><br><span class="line">$tmp = $foo();</span><br><span class="line">$tmp(<span class="number">100</span>); <span class="comment">// 110</span></span><br><span class="line">$tmp(<span class="number">100</span>); <span class="comment">// 111</span></span><br><span class="line">$tmp(<span class="number">100</span>); <span class="comment">// 112  跟js类似，保证变量常驻内存</span></span><br></pre></td></tr></table></figure><h5 id="php-Closure-类"><a href="#php-Closure-类" class="headerlink" title="php Closure 类"></a>php Closure 类</h5><ul><li><p><a href="http://php.net/manual/zh/closure.bind.php" target="_blank" rel="noopener">Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域</a><br>public static Closure Closure::bind ( Closure $closure , object $newthis [, mixed $newscope = ‘static’ ] )</p></li><li><p><a href="http://php.net/manual/zh/closure.bindto.php" target="_blank" rel="noopener">Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域</a><br>public Closure Closure::bindTo ( object $newthis [, mixed $newscope = ‘static’ ] )<br>对这两个方法不是很能理解。。。求指教  </p></li></ul><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>都是为了扩展作用域，获取内部变量  </p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>js能够在方法内部直接获取到父级作用域的变量，而php需要通过use声明，并且默认是值传递  </p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>不是很能理解应用场景，搜索了一下，很多只是写了一个闭包实现的购物车，感觉并不是那么的实用。</li><li>如果只是单纯的使用匿名函数，感觉还不如封装成一个私有方法  <blockquote><p>这些只是个人粗鄙的理解，望指正.</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;匿名函数&quot;&gt;&lt;a href=&quot;#匿名函数&quot; class=&quot;headerlink&quot; title=&quot;匿名函数&quot;&gt;&lt;/a&gt;匿名函数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如果只是省去函数名，单纯的当作一个函数式方法返回，只能称为匿名函数（闭包需要将匿名函数当作结果返回
      
    
    </summary>
    
      <category term="PHP" scheme="https://pengwenwu.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://pengwenwu.github.io/tags/PHP/"/>
    
      <category term="JS" scheme="https://pengwenwu.github.io/tags/JS/"/>
    
      <category term="闭包" scheme="https://pengwenwu.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>phpstorm或vscode使用psr2规范</title>
    <link href="https://pengwenwu.github.io/2018/05/14/phpstorm%E6%88%96vscode%E4%BD%BF%E7%94%A8psr2%E8%A7%84%E8%8C%83/"/>
    <id>https://pengwenwu.github.io/2018/05/14/phpstorm或vscode使用psr2规范/</id>
    <published>2018-05-13T16:16:13.000Z</published>
    <updated>2018-05-13T16:19:13.177Z</updated>
    
    <content type="html"><![CDATA[<ul><li>安装composer</li><li>全局安装phpcs</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer global require squizlabs/php_codesniffer</span><br></pre></td></tr></table></figure><h3 id="vscode直接插件搜索phpcs安装"><a href="#vscode直接插件搜索phpcs安装" class="headerlink" title="vscode直接插件搜索phpcs安装"></a>vscode直接插件搜索phpcs安装</h3><h3 id="phpstorm"><a href="#phpstorm" class="headerlink" title="phpstorm"></a>phpstorm</h3><p>全局安装phpcs后，会在<strong>C:\Users{user name}\AppData\Roaming\Composer\vendor\bin</strong>下生成一个<code>phpcs.bat</code>，后面会用到</p><ul><li>phpstorm -&gt; setting</li><li>languages &amp; Frameworks-&gt;PHP-&gt;Code Sniffer点击Configuration右侧的按钮</li><li>找到刚才的phpcs.bat，点击<code>Validate</code>，确认</li><li>Editor-&gt;Inspection-&gt;PHP</li><li>双击PHP Code Sniffer validation，点击Coding standard右侧的刷新按钮，然后选择psr2，确定</li></ul><p><strong>参考链接</strong>: <a href="https://laravel-china.org/topics/1692/how-to-use-phpstorm-gracefully" target="_blank" rel="noopener">如何优雅地使用phpstorm?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;安装composer&lt;/li&gt;
&lt;li&gt;全局安装phpcs&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp
      
    
    </summary>
    
      <category term="PHP" scheme="https://pengwenwu.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://pengwenwu.github.io/tags/PHP/"/>
    
      <category term="PSR" scheme="https://pengwenwu.github.io/tags/PSR/"/>
    
  </entry>
  
  <entry>
    <title>array_map, array_walk, array_filter的区别及使用</title>
    <link href="https://pengwenwu.github.io/2018/05/13/array-map-array-walk-array-filter%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>https://pengwenwu.github.io/2018/05/13/array-map-array-walk-array-filter的区别及使用/</id>
    <published>2018-05-13T08:33:22.000Z</published>
    <updated>2018-05-13T16:15:45.409Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>array_map, array_walk, array_filter的区别及使用</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// array_map, array_walk, array_filter的区别</span></span><br><span class="line">$arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">($value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $value * $value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span><span class="params">($value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $value &gt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span><span class="params">(&amp;$value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $value = $value * $value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// array_map 会返回新的数组, 不对原数组产生影响</span></span><br><span class="line">$new_arr = array_map(<span class="string">'foo'</span>, $arr);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'原数组:'</span>.var_export($arr, <span class="number">1</span>).<span class="string">"\n"</span>, <span class="string">'array_map修改后的数组：'</span>.var_export($new_arr, <span class="number">1</span>).<span class="string">"\n"</span>.<span class="string">"&lt;hr/&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// array_walk 返回bool值，callback需要通过值传递改变原有数组</span></span><br><span class="line">$res = array_walk($arr, <span class="string">'walk'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'修改后的数组:'</span>.var_export($arr, <span class="number">1</span>).<span class="string">"\n"</span>, <span class="string">'array_walk返回结果：'</span>.var_export($res, <span class="number">1</span>).<span class="string">"\n"</span>.<span class="string">"&lt;hr/&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// array_filter 返回筛选后的新数组，不对原数组产生影响</span></span><br><span class="line">$new_arr = array_filter($arr, <span class="string">'filter'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'原数组:'</span>.var_export($arr, <span class="number">1</span>).<span class="string">"\n"</span>, <span class="string">'array_filter返回结果：'</span>.var_export($new_arr, <span class="number">1</span>).<span class="string">"\n"</span>.<span class="string">"&lt;hr/&gt;"</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;array_map, array_walk, array_filter的区别及使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="PHP" scheme="https://pengwenwu.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://pengwenwu.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>windows下cmd/powershell中文乱码解决方法</title>
    <link href="https://pengwenwu.github.io/2018/05/13/windows%E4%B8%8Bcmd-powershell%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://pengwenwu.github.io/2018/05/13/windows下cmd-powershell中文乱码解决方法/</id>
    <published>2018-05-13T08:09:01.000Z</published>
    <updated>2018-05-13T08:13:21.915Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>windows下cmd或者powershell运行php文件中文乱码  </p></blockquote><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>执行下面的命令，切换成utf-8编码</p><pre><code>chcp 65001</code></pre><p>这个指标不治本，查了说是可以修改注册表，但是好像又会带来其他的坑（中文软件乱码、nodejs乱码），未测试过，不予评价。参考链接：<a href="https://www.zhihu.com/question/54724102" target="_blank" rel="noopener">https://www.zhihu.com/question/54724102</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;windows下cmd或者powershell运行php文件中文乱码  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方
      
    
    </summary>
    
      <category term="环境配置" scheme="https://pengwenwu.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="中文乱码" scheme="https://pengwenwu.github.io/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>hexo常用命令</title>
    <link href="https://pengwenwu.github.io/2018/05/13/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://pengwenwu.github.io/2018/05/13/hexo常用命令/</id>
    <published>2018-05-13T06:21:59.000Z</published>
    <updated>2018-06-07T12:42:55.389Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>hexo常用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;博客名称&quot;  =&gt; hexo new &quot;博客名称&quot; </span><br><span class="line">hexo clean # 清楚缓存</span><br><span class="line">hexo g  =&gt; hexo generate  #生成</span><br><span class="line">hexo p  =&gt; hexo publish # 发布</span><br><span class="line">hexo s  =&gt; hexo server  #启动服务预览</span><br><span class="line">hexo d  =&gt; hexo deploy  #部署</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>发布流程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;hexo常用命令&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
      <category term="Git" scheme="https://pengwenwu.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://pengwenwu.github.io/tags/Git/"/>
    
      <category term="Hexo" scheme="https://pengwenwu.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>git reset 和 revert 的区别和使用</title>
    <link href="https://pengwenwu.github.io/2018/05/13/git-reset-%E5%92%8C-revert-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://pengwenwu.github.io/2018/05/13/git-reset-和-revert-的区别和使用/</id>
    <published>2018-05-13T06:17:37.000Z</published>
    <updated>2018-05-13T06:22:41.234Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>git <code>revert</code> 撤销某次提交, 保留之前的commit, 同时创建一个新的commit(可用于<strong>公共分支</strong>)<br>git <code>reset</code> 撤销某个提交， 删除之前的commit, head回退 (多用于<strong>私有分支</strong>)<br><strong>区别</strong>: git revert 只是撤销某个commit, 保留该commit之前的提交结果</p></blockquote><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><blockquote><p>commit3: add log3<br>commit2: add log2<br>commit1: add log1</p></blockquote><h3 id="HEAD用法"><a href="#HEAD用法" class="headerlink" title="HEAD用法"></a>HEAD用法</h3><ul><li>HEAD^: 指向上一次commit</li><li>HEAD~100: 指向前第一百个commit</li><li>HEAD commit_id: 直接指向某个commit  </li></ul><h3 id="–soft、–mixed-默认-、–hard的区别"><a href="#–soft、–mixed-默认-、–hard的区别" class="headerlink" title="–soft、–mixed(默认)、–hard的区别"></a>–soft、–mixed(默认)、–hard的区别</h3><ul><li>–soft: 只是重置HEAD到某一个commit, 其余不会有任何变化(缓存区和工作目录都不会被改变)</li><li>–mixed(默认): 重置HEAD, 文件修改都将保存到缓存区(缓存区和你指定的提交同步，但工作目录不受影响)</li><li>–hard: 修改当前所有内容, 所有本地修改都将丢失(缓存区和工作目录都同步到你指定的提交). 找回执行命令: git reflow</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;git &lt;code&gt;revert&lt;/code&gt; 撤销某次提交, 保留之前的commit, 同时创建一个新的commit(可用于&lt;strong&gt;公共分支&lt;/strong&gt;)&lt;br&gt;git &lt;code&gt;reset&lt;/code&gt; 撤销某个提交， 删除之前
      
    
    </summary>
    
      <category term="Git" scheme="https://pengwenwu.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://pengwenwu.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git pull更新指定文件</title>
    <link href="https://pengwenwu.github.io/2018/05/13/git-pull%E6%9B%B4%E6%96%B0%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6/"/>
    <id>https://pengwenwu.github.io/2018/05/13/git-pull更新指定文件/</id>
    <published>2018-05-13T06:07:42.000Z</published>
    <updated>2018-05-13T06:17:02.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经常会遇到，几个文件一起提交了，但是某些文件是要先执行的，不然一起pull下来会加载报错</p><h3 id="更新git指定文件"><a href="#更新git指定文件" class="headerlink" title="更新git指定文件"></a>更新git指定文件</h3><p>git fetch<br>git checkout origin/master – path/to/file</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;经常会遇到，几个文件一起提交了，但是某些文件是要先执行的，不然一起pull下来会加载报错&lt;/p&gt;
&lt;h3 id=&quot;更新git指定文件&quot;&gt;&lt;a href=&quot;#更新git指定文件&quot; class=&quot;headerlink&quot; title=&quot;更新git指定文件
      
    
    </summary>
    
      <category term="Git" scheme="https://pengwenwu.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://pengwenwu.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>阅读《微服务设计》笔记</title>
    <link href="https://pengwenwu.github.io/2018/03/03/%E9%98%85%E8%AF%BB%E3%80%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://pengwenwu.github.io/2018/03/03/阅读《微服务设计》笔记/</id>
    <published>2018-03-03T10:14:59.000Z</published>
    <updated>2018-06-07T12:43:14.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录阅读《微服务设计》收获的点  </p></blockquote><h2 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a>什么是微服务？</h2><p><strong>一些协同工作的小而自治的服务</strong></p><h2 id="打破外键关系"><a href="#打破外键关系" class="headerlink" title="打破外键关系"></a>打破外键关系</h2><p><strong>对于有外键关系的表如何做服务拆分？</strong><br>通过api调用访问  </p><ul><li>优点：数据表拆分，进而服务拆分</li><li>缺点：增加了数据库的调用，会影响性能。需要测试是否在可接受范围内，权衡拆分服务带来的好处</li></ul><h2 id="共享表拆分"><a href="#共享表拆分" class="headerlink" title="共享表拆分"></a>共享表拆分</h2><p><strong>共享表拆分后，如何保证插入数据的一致性？</strong><br>设计之初为了减少数据库的调用，必然会建立基于外键的共享表。拆分之后，如何保证同时插入多张表数据的一致性？（某张表插入失败）  </p><ul><li>通过<code>事务</code>处理  </li><li>推荐对及时性较弱的操作，异常捕获后放入队列或者日志文件中进行延迟处理，保证<code>最终一致性</code>  </li><li>终止整个操作，再发起<code>补偿事务</code>来抵消之前的操作（自动化处理）</li><li><p><code>分布式事务</code>。通过专门的事务管理器工具来协调底层事务（不推荐，易出错，难扩展）</p><blockquote><p>阅读完感觉云里雾里，可能是自己的水平还没到达那个深度。收获大概是：了解了后端的架构，后期拓展可能会遇到的问题，以及解决这样问题的思路。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录阅读《微服务设计》收获的点  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是微服务？&quot;&gt;&lt;a href=&quot;#什么是微服务？&quot; class=&quot;headerlink&quot; title=&quot;什么是微服务？&quot;&gt;&lt;/a&gt;什么是微服务？&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="后端" scheme="https://pengwenwu.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="微服务" scheme="https://pengwenwu.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://pengwenwu.github.io/2018/01/21/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://pengwenwu.github.io/2018/01/21/Linux常用命令/</id>
    <published>2018-01-21T13:27:15.000Z</published>
    <updated>2018-03-05T15:19:56.078Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一些阅读《鸟哥的Linux私房菜-基础学习篇》中不太熟悉的命令  </p></blockquote><h3 id="软连接、硬链接"><a href="#软连接、硬链接" class="headerlink" title="软连接、硬链接"></a>软连接、硬链接</h3><blockquote><p><strong>软连接</strong>：连接文件的内容只会写上目标文件的“文件名”，实际是通过记录的目标文件地址去访问实际存储内容。大小就是文件名大小。如果删除目标文件，则当前文件无法访问。(等同于windows的快捷方式)  </p><p> <strong>硬连接</strong>：只能针对单个文件，实际会创建一个一模一样的“文件”(权限、大小)，连接数增加。连接到同一个地址，只是使用了不同的文件名，均可以对源文件进行数据修改，删除任意一个，不影响其余文件访问</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp -s test test1  </span><br><span class="line">ln -s test test1  # 软连接(快捷方式)</span><br><span class="line"></span><br><span class="line">cp -l demo.php demo1.php </span><br><span class="line">ln -l demo.php demo1.php # 硬链接(只支持单个文件)</span><br></pre></td></tr></table></figure><h3 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a>查看分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#-z gzip压缩，-j bzip2压缩</span><br><span class="line">tar -zcvf [newfilename] filename </span><br><span class="line">tar -zxvf filename.tar.gz [-C 目录] 解压要到指定目录</span><br></pre></td></tr></table></figure><h3 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type name</span><br></pre></td></tr></table></figure><h3 id="命名别名"><a href="#命名别名" class="headerlink" title="命名别名"></a>命名别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias rm=&apos;rm -i&apos;</span><br><span class="line">alias st=&apos;status&apos;</span><br><span class="line"></span><br><span class="line">unalias rm  #取消别名</span><br></pre></td></tr></table></figure><h3 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h3><blockquote><p>标准输入：&lt;或&lt;&lt; (将由键盘输入的数据由文件代替/<strong>结束输入</strong>)<br>标准输出：&gt;或&gt;&gt; (覆盖/追加)<br>标准错误输出：2&gt;或2&gt;&gt; (覆盖/追加)  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; catfile &lt;&lt; eof</span><br><span class="line">&gt;This is a test.</span><br><span class="line">&gt;Ok now stop</span><br><span class="line">&gt;eof</span><br></pre></td></tr></table></figure><h3 id="命令执行判断：-amp-amp"><a href="#命令执行判断：-amp-amp" class="headerlink" title="命令执行判断：; || &amp;&amp;"></a>命令执行判断：; || &amp;&amp;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#依次执行</span><br><span class="line">echo 1; echo 2; echo 3 </span><br><span class="line"></span><br><span class="line">#若cmd1正确执行，则开始执行cmd2</span><br><span class="line">#若cmd1执行错误，则cmd2不执行</span><br><span class="line">cmd1 &amp;&amp; cmd2   </span><br><span class="line">               </span><br><span class="line">#若cmd1正确执行，则不执行cmd2</span><br><span class="line">#若cmd1执行错误，则开始执行cmd2</span><br><span class="line">cmd1 || cmd2</span><br></pre></td></tr></table></figure><h3 id="选取命令：cut-grep"><a href="#选取命令：cut-grep" class="headerlink" title="选取命令：cut, grep"></a>选取命令：cut, grep</h3><blockquote><p>cut:<br>  -d：分割字符，与-f一起用<br>  -f：取出第几段<br>  -c：取出固定字符区间  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 列出第三段，第五段</span><br><span class="line">echo $PATH | cut -d &apos;:&apos; -f 3,5 </span><br><span class="line"></span><br><span class="line"># 取得第5字符之后</span><br><span class="line">echo $PATH | cut -c 5-</span><br></pre></td></tr></table></figure><h3 id="排序命令-sort-wc-uniq"><a href="#排序命令-sort-wc-uniq" class="headerlink" title="排序命令:sort, wc, uniq"></a>排序命令:sort, wc, uniq</h3><blockquote><p>sort [-fbMnrtuk]<br>uniq [-ic]<br>-c：进行计数  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每个人登录的次数</span><br><span class="line">last | cut -d &apos; &apos; -f 1 | sort | uniq -c</span><br></pre></td></tr></table></figure><blockquote><p>wc [-lwm]<br>-l：仅列出行<br>-w：仅列出多少字<br>-m：多少字符</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录一些阅读《鸟哥的Linux私房菜-基础学习篇》中不太熟悉的命令  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;软连接、硬链接&quot;&gt;&lt;a href=&quot;#软连接、硬链接&quot; class=&quot;headerlink&quot; title=&quot;软连接、硬链接&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://pengwenwu.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://pengwenwu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>hexo + github搭建个人博客教程</title>
    <link href="https://pengwenwu.github.io/2018/01/14/hexo%20+%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    <id>https://pengwenwu.github.io/2018/01/14/hexo + github搭建个人博客教程/</id>
    <published>2018-01-14T08:09:07.000Z</published>
    <updated>2018-06-07T12:42:44.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一年前，临近毕业。为了准备面试，才刻意去准备了<code>github</code>以及<code>blog</code>。<br>自从找到工作后，这两个基本没怎么维护过，想想未免太功利了点。</p><p>主要是前几天，又踩到坑了，想去找以前的记录，很麻烦。<br>之前虽然每天都会写工作总结，一些踩过的坑记在为知笔记上，没有<code>分类</code>、<code>标签</code>，后面再想去找很困难。<br>痛定思痛，该记的东西少不掉，索性优雅一点。</p><p>之前用的是博客园，但是那个账号密码老记不住，干脆自己搭建一个吧，好歹也是一个码农。<br>然后花了两个晚上加一个上午，通过<code>hexo</code>和<code>github</code>搭建了一个个人博客。<br>网上教程、文档那么多，为什么花这么久时间？当然是踩坑了啊。<br>所以下面会记录一些遇到的问题和坑。<br>如果你看完这边文章，那你只需要<code>两个小时</code>就能搭建成功。欢迎有兴趣的小伙伴尝试一下。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><strong>node.js</strong></li><li><strong>git</strong></li></ol><p>这两个应用windows用户直接搜索下载安装就可以。<br>如果习惯了使用linux命令的朋友，推荐windows神器<code>cmder</code>。<br>可以直接在windows环境下使用linux命令，样式可调，再也不要用黑乎乎的cmd了，而且自带git，完全可以不用下载windows git。</p><h3 id="正式安装hexo"><a href="#正式安装hexo" class="headerlink" title="正式安装hexo"></a>正式安装hexo</h3><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方中文文档</a></p><p>在node.js安装好的前提下，全局安装hexo<br>如何判断node.js是否安装成功？执行以下命令，如果能够看到版本号则说明安装成功了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure></p><p>安装<code>hexo</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><p>自选合适的目录，新建文件夹&lt;folder&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;folder&gt;</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>不再赘述，直接看官方文档。</p><h3 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h3><p>新建仓库，仓库名必须为<strong>[your_name.github.io]</strong></p><blockquote><p>补充：本地配置github ssh连接，方便自动部署，以及clone你喜欢的主题(theme)</p></blockquote><p>windows用户直接在<code>c:/用户/youername/.ssh/</code>下查看是否有<code>id_rsa.pub</code>文件。<br>没有的话命令行执行命令<code>ssh-keygen -t rsa -C &quot;your eamil&quot;</code>，会自动生成<code>id_rsa.pub</code>文件，打开后复制。</p><p>github-&gt;头像-&gt;Settings→SSH kyes→Add SSH key，粘贴复制的内容。</p><p>配置本地账户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name “your_username”  #设置用户名</span><br><span class="line">git config --global user.email “your_email”  #设置邮箱地址,最好使用注册邮箱地址</span><br></pre></td></tr></table></figure></p><p>测试是否配置成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><h3 id="hexo配置以及使用"><a href="#hexo配置以及使用" class="headerlink" title="hexo配置以及使用"></a>hexo配置以及使用</h3><p>有两个配置文件：</p><ul><li>一个是根目录下的<code>_config.yml</code>称为<code>站点配置</code>文件</li><li>一个是<code>themes/landscape/_config.yml</code>称为<code>主题配置</code>文件(默认主题：landscape)</li></ul><p>站点配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url: https://yourname.github.io/</span><br><span class="line">theme: landscape #选择你想用的主题，我用的是indigo</span><br><span class="line">deploy:</span><br><span class="line">    type: git   # 不要使用github</span><br><span class="line">    repo: git@github.com:pengwenwu/pengwenwu.github.io.git # 使用ssh连接</span><br><span class="line">    branch: master  # 默认master分支</span><br><span class="line">    message: add new blog # 自动部署commit备注，可不填</span><br></pre></td></tr></table></figure><h4 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h4><p><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">hexo命令参考</a></p><p><code>hexo n &quot;我的博客&quot;</code> == <code>hexo new &quot;我的博客&quot;</code> #新建文章<br><code>hexo p</code> == <code>hexo publish</code><br><code>hexo g</code> == <code>hexo generate</code> #生成<br><code>hexo s</code> == <code>hexo server</code> #启动服务本地预览<br><code>hexo d</code> == <code>hexo deploy</code> #部署<br><code>hexo clean</code> #清除缓存 网页正常情况下可以忽略此条命令  </p><p><code>hexo server</code> #Hexo 会监视文件变动并自动更新，您无须重启服务器。<br><code>hexo server -s</code> #静态模式<br><code>hexo server -p 5000</code> #更改端口<br><code>hexo server -i 192.168.1.1</code> #自定义 IP</p><p>在执行之前，记得安装自动部署  (–save 加不加的区别在于是否写入到依赖文件package.json中)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>正常本地预览，直接执行<code>hexo s</code>,如果要发布话最好执行<code>clean</code>命令，会去删除生成的public文件，完整部署命令:<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>。或者直接<code>hexo d -g</code></p><h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><p>安装完自动部署后，是不需要本地git init新建仓库的。执行<code>hexo g</code>会在根目录生成public文件夹，自动部署，<br>本质是将public文件夹内容全部提交到仓库中去，默认会访问编译好的index.html。</p><p>如果部署完，访问your_name.github.io 404,可能有下面几个原因</p><ol><li>首先检查仓库文件，是不是全都是public的文件内容，如果整个本地blog文件夹都提交了，首先清空<br>仓库，然后删除本地<code>.deploy_git</code>文件夹，再重新部署</li><li>文件有报错，本地<code>hexo s</code>观察是否有报错。</li></ol><p>不喜欢原主题的朋友，可以github去找喜欢的主题。执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone XXXX.next.git themes\next</span><br></pre></td></tr></table></figure></p><p>这个会将新的主题下载到themes下对应的next目录，next为主题的名字。</p><p>主题的配置，可以看文档，修改对应的<code>主题配置</code>文件。<br>我使用的主题是<code>indigo</code>,详细文档<a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">indigo</a></p><p><code>markdown</code>不会使用的朋友，参考链接<a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">markdown中文文档</a><br>如果没有ide的话，可以使用在线预览<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">Cmd Markdown</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一年前，临近毕业。为了准备面试，才刻意去准备了&lt;code&gt;github&lt;/code&gt;以及&lt;code&gt;blog&lt;/code&gt;。&lt;br&gt;自从找到
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://pengwenwu.github.io/tags/Hexo/"/>
    
      <category term="Github" scheme="https://pengwenwu.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>如何将一个数组乱序？</title>
    <link href="https://pengwenwu.github.io/2018/01/13/%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F%EF%BC%9F/"/>
    <id>https://pengwenwu.github.io/2018/01/13/如何将一个数组乱序？/</id>
    <published>2018-01-13T13:55:11.000Z</published>
    <updated>2018-01-14T08:13:34.204Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是很久以前博客园的博客，打个小样。</p></blockquote><p>前几天php实习面试，问到一个问题：<strong>如何将一个数组乱序？</strong><br>答：使用自带的array_rand()或者shuffle()函数，或者用随机数取值赋值给新的数组。<br>又问：万一一直随机到同一个数怎么办？<br>那就进行判断，如果已经取过的位置，重新选取随机数。<br>这样问题就来了：随着新数组长度增加，原数组中的随机数选取碰撞几率会原来越大，最后几乎是一直碰撞的。也没有想出更好的办法。</p><p>后来回家后查了一下，总结一下，有以下几种方法：</p><ol><li><p>使用自带的函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle_rand1</span><span class="params">($arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"原来数组为："</span>;</span><br><span class="line">print_r($arr);</span><br><span class="line">shuffle($arr);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;乱序数组为："</span>;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第一时间想到的方法，就是随机取值，赋值给新的数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle_rand2</span><span class="params">($arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"原来数组为："</span>;</span><br><span class="line">print_r($arr);</span><br><span class="line">$len = count($arr);</span><br><span class="line">$shuffle_arr = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">while</span>(count($shuffle_arr)&lt;$len)&#123;</span><br><span class="line">$index = rand(<span class="number">0</span>,$len<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(!in_array($index, $shuffle_arr))&#123;</span><br><span class="line">$shuffle_arr[] = $index;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$newarr = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">foreach</span> ($shuffle_arr <span class="keyword">as</span> $v) &#123;</span><br><span class="line">$newarr[] = $arr[$v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;新的数组为："</span>;</span><br><span class="line">print_r($newarr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组中随机取一个元素赋值给新的数组，然后将原数组最后一位赋值到该位置,数组长度减一，继续重复上述步奏</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle_rand3</span><span class="params">($arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"原来数组为："</span>;</span><br><span class="line">print_r($arr);</span><br><span class="line">$len = count($arr);</span><br><span class="line">$shuffle_arr = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">while</span>($len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">$index = rand(<span class="number">0</span>,$len<span class="number">-1</span>);</span><br><span class="line">$shuffle_arr[] = $arr[$index];</span><br><span class="line">$arr[$index] = $arr[$len<span class="number">-1</span>];</span><br><span class="line">$len--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;新的数组为："</span>;</span><br><span class="line">print_r($shuffle_arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在具有n个元素的数组中，对0到n-1一次进行与一个随机位置元素进行交换,这种方法不需要新建一个数组，直接在原数组中进行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle_rand4</span><span class="params">($arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"原来数组为："</span>;</span><br><span class="line">print_r($arr);</span><br><span class="line">$len = count($arr);</span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;$len;$i++)&#123;</span><br><span class="line">$index = rand(<span class="number">0</span>,$len<span class="number">-1</span>);</span><br><span class="line">$temp = $arr[$i];</span><br><span class="line">$arr[$i] = $arr[$index];</span><br><span class="line">$arr[$index] = $temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;新的数组为："</span>;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是很久以前博客园的博客，打个小样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前几天php实习面试，问到一个问题：&lt;strong&gt;如何将一个数组乱序？&lt;/strong&gt;&lt;br&gt;答：使用自带的array_rand()或者shuffle()函数，或者
      
    
    </summary>
    
      <category term="算法" scheme="https://pengwenwu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PHP" scheme="https://pengwenwu.github.io/tags/PHP/"/>
    
      <category term="算法" scheme="https://pengwenwu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://pengwenwu.github.io/2018/01/10/hello-world/"/>
    <id>https://pengwenwu.github.io/2018/01/10/hello-world/</id>
    <published>2018-01-10T15:18:30.173Z</published>
    <updated>2018-01-10T15:18:30.173Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
