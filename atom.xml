<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pena&#39;s Blog</title>
  
  <subtitle>莫道君行早，更有早行人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pengwenwu.github.io/"/>
  <updated>2018-06-07T12:56:30.005Z</updated>
  <id>https://pengwenwu.github.io/</id>
  
  <author>
    <name>pengwenwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>dokcer入门篇</title>
    <link href="https://pengwenwu.github.io/2018/06/07/dokcer%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>https://pengwenwu.github.io/2018/06/07/dokcer入门篇/</id>
    <published>2018-06-07T12:35:34.000Z</published>
    <updated>2018-06-07T12:56:30.005Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://docker_practice.gitee.io/" target="_blank" rel="noopener">阅读《Docker — 从入门到实践》</a>  </p></blockquote><h1 id="windows使用"><a href="#windows使用" class="headerlink" title="windows使用"></a>windows使用</h1><ul><li>下载docker for windows，安装 </li><li>使用镜像加速，我自己使用的是<a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云镜像加速</a>setting-&gt;Daemon-&gt;Registry mirrors-&gt;粘贴自己的加速器地址 </li><li>可以使用gui界面，Kitematic</li></ul><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>可以使用<code>docker pull --help</code>查看<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br><span class="line"></span><br><span class="line"><span class="comment"># etc</span></span><br><span class="line">docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm ubuntu:16.04 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前系统版本</span></span><br><span class="line">cat /etc/os-release</span><br></pre></td></tr></table></figure><ul><li><code>-it</code>: <code>-i</code>: 交互式操作, <code>-t</code>: 终端 </li><li><code>--rm</code>: 执行退出后删除该容器实例</li><li><code>bash</code>: shell使用的方式 </li></ul><h2 id="镜像列表"><a href="#镜像列表" class="headerlink" title="镜像列表"></a>镜像列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># etc</span></span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span><br></pre></td></tr></table></figure><p>各列意义：<code>仓库名</code>, <code>标签</code>, <code>镜像id</code>, <code>创建时间</code>, <code>解压后文件大小</code><br><strong>镜像ID 则是镜像的唯一标识，一个镜像可以对应多个标签</strong> </p><h2 id="镜像大小"><a href="#镜像大小" class="headerlink" title="镜像大小"></a>镜像大小</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><h2 id="启动已终止的container镜像"><a href="#启动已终止的container镜像" class="headerlink" title="启动已终止的container镜像"></a>启动已终止的container镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] start</span><br></pre></td></tr></table></figure><h2 id="后台运行容器"><a href="#后台运行容器" class="headerlink" title="后台运行容器"></a>后台运行容器</h2><p><code>-d</code>参数能够让容器后台运行，保证输出结果不会打印出来。但容器是否长久运行（一直后台挂起），跟<code>-d</code>参数无关，需要一直有指令执行，才不会“秒退”<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -c exec执行</span></span><br><span class="line">docker run ubuntu:17.10 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line">docker run -d ubuntu:17.10 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure></p><p>可以通过<code>docker [container] logs</code>去查看容器输出信息 </p><h2 id="终止运行"><a href="#终止运行" class="headerlink" title="终止运行"></a>终止运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [contanier] stop</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker attach </span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐使用</span></span><br><span class="line">docker <span class="built_in">exec</span> -it [container id] /bin/bash</span><br></pre></td></tr></table></figure><p>两者的区别：前者exit退出后，会停止当前容器；而<code>exec</code>仍然会保持运行 </p><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container rm </span><br><span class="line"></span><br><span class="line"><span class="comment"># 清楚所有处于终止状态的容器</span></span><br><span class="line">docker container prune</span><br></pre></td></tr></table></figure><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p><strong>为什么不建议使用<code>docker commit</code>?</strong><br>使用<code>docker commit</code>提交后，对于其他使用者而言，这个image镜像是一个黑箱，别人无处得知执行过什么命令、如何生成的镜像 </p><h2 id="Dokcerfile-定制镜像"><a href="#Dokcerfile-定制镜像" class="headerlink" title="Dokcerfile 定制镜像"></a>Dokcerfile 定制镜像</h2><h3 id="FROM指定基础镜像"><a href="#FROM指定基础镜像" class="headerlink" title="FROM指定基础镜像"></a>FROM指定基础镜像</h3><h3 id="RUN执行命令"><a href="#RUN执行命令" class="headerlink" title="RUN执行命令"></a>RUN执行命令</h3><ul><li>shell格式：<code>RUN &lt;命令&gt;</code> </li><li>exec格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code> </li></ul><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># etc, 注意镜像构建上下文(context)</span></span><br><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h2><h3 id="CMD-启动命令"><a href="#CMD-启动命令" class="headerlink" title="CMD 启动命令"></a>CMD 启动命令</h3><p><code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的，也分为<code>shell</code>格式以及<code>exec</code>格式 </p><ul><li>shell格式：CMD &lt;命令&gt; </li><li>exec格式：CMD [“可执行文件”, “参数1”, “参数2”…] </li><li>参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数 </li></ul><p>一般<code>推荐</code>使用<code>exec</code>格式，这类格式在解析时会被解析成JSON数组，因此要使用<code>双引号</code> </p><p>如果是<code>shell</code>格式，实际会被包装成<code>sh -c</code>的格式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD <span class="built_in">echo</span> <span class="variable">$HOME</span></span><br></pre></td></tr></table></figure></p><p>实际执行会变成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo <span class="variable">$HOME</span>"</span> ]</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：Docker不是虚拟机，容器中的应用都是<code>前台执行</code>，没有后台服务的概念 </p><p>错误示范：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure></p><p>这里容器执行后会秒退出，因为上面的命令会被转化为<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start]</code>，主进程是<code>sh</code>，当service nginx start执行结束后，sh也就结束了，sh作为主进程结束，所以容器也会退出</p><p>正确做法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ <span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span> ]</span><br></pre></td></tr></table></figure></p><p>这边执行<code>docker run</code>的时候，不需要再跟<code>/bin/bash</code>启动命令，因为会覆盖。否则就是秒结束进程</p><h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p>如果指定了<code>ENTRYPOINT</code>，<code>CMD</code>就不会直接执行命令，而是讲内容作为参数传给<code>ENTRYPOINT</code>，实际执行指令会变为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT <span class="string">"&lt;CMD&gt;"</span></span><br></pre></td></tr></table></figure></p><h4 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run myip -i</span><br></pre></td></tr></table></figure><h4 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h4><p>在启动主进程之前，需要一些准备工作，比如数据库的配置、初始化 </p><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>两种格式：</p><ul><li>ENV \<key\> \<value\></value\></key\></li><li>ENV \<key1\>=\<value1\> \<key2>=\<value2\> … <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 含有空格的值使用双引号</span></span><br><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">    NAME=<span class="string">"Happy Feet"</span></span><br></pre></td></tr></table></figure></value2\></key2></value1\></key1\></li></ul><h3 id="ARG构建参数"><a href="#ARG构建参数" class="headerlink" title="ARG构建参数"></a>ARG构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code> </p><p>构建参数和ENV效果一样，都是设置环境变量，唯一的区别是，<code>ARG</code>构建的环境变量，在将来容器运行的时候，不会存储这些环境变量 </p><p><code>Dokcerfile</code>中的<code>ARG</code>指令是定义参数名称，以及其默认值。可以通过构建命令<code>docker build</code>中用<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖 </p><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p><ul><li>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]</li><li>VOLUME &lt;路径&gt; </li></ul><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure><p>这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure><p>这里mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置 </p><h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式为：<code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code> </p><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处: </p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射 </li><li>在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口 </li></ul><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 </p><h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为: <code>WORKDIR &lt;工作目录路径&gt;</code> </p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录 </p><h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式：<code>USER &lt;用户名&gt;</code> </p><p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份 </p><h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h3><p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常 </p><p>格式： </p><ul><li>HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</li><li>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 </li></ul><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code> </p><p><code>NOBUILD</code>指令是别人定制镜像。即使用<code>FROM</code>的时候，才执行的命令 </p><h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先打标签</span></span><br><span class="line">docker tag ubuntu:17.10 username/ubuntu:17.10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在push</span></span><br><span class="line">docker push username/ubuntu:17.10</span><br></pre></td></tr></table></figure><h2 id="配置私有仓库"><a href="#配置私有仓库" class="headerlink" title="配置私有仓库"></a>配置私有仓库</h2><p><a href="https://docker_practice.gitee.io/repository/registry.html" target="_blank" rel="noopener">配置私有仓库</a> </p><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录： </p><ul><li><code>数据卷</code>可以在容器之间共享和重用 </li><li>对 <code>数据卷</code> 的修改会立马生效 </li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会一直存在，即使容器被删除 <blockquote><p>注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷。 </p></blockquote></li></ul><h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>使用<code>- P</code>标记时，Docker会随机映射 <code>49000~49900</code> 的端口到内部容器开放的网络端口 </p><p><code>- p</code>可以指定要映射的端口，也可以指定地址<br><code>ip:hostPort:containerPort</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p><code>docker port</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port nostalgic_morse 5000</span><br></pre></td></tr></table></figure></p><ul><li>容器有自己的内部网络和 ip 地址 </li><li><code>-p</code> 标记可以多次使用来绑定多个端口 </li></ul><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><h3 id="查看已有网络"><a href="#查看已有网络" class="headerlink" title="查看已有网络"></a>查看已有网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><h3 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge my-net</span><br></pre></td></tr></table></figure><p><code>-d</code> 可以指定Docker网络类型，有<code>bridge</code>, <code>overlay</code>，其中 <code>overlay</code> 网络类型用于 <code>Swarm mode</code>(<strong>集群服务</strong>) </p><h3 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h3><p>运行一个容器并连接到新建的 <code>my-net</code> 网络<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --name busybox1 --network my-net busybox sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再运行一个容器</span></span><br><span class="line">docker run -it --rm --name busybox2 --network my-net busybox sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试连接</span></span><br><span class="line"><span class="comment"># 在busybox1 容器里，执行</span></span><br><span class="line"><span class="comment"># /ping busybox2</span></span><br><span class="line">PING busybox2 (172.19.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.060 ms</span><br><span class="line">64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.046 ms</span><br><span class="line">64 bytes from 172.19.0.3: seq=2 ttl=64 time=0.075 ms</span><br></pre></td></tr></table></figure></p><h1 id="Compose-项目"><a href="#Compose-项目" class="headerlink" title="Compose 项目"></a>Compose 项目</h1><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。<br><code>Compose</code> 中有两个重要的概念： </p><ul><li><code>服务 (service)</code>：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。 </li><li><code>项目 (project)</code>：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。 </li></ul><p><code>Compose</code> 的默认管理对象是<code>项目</code>，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><h2 id="Compose-命令说明"><a href="#Compose-命令说明" class="headerlink" title="Compose 命令说明"></a>Compose 命令说明</h2><h3 id="命令对象与格式"><a href="#命令对象与格式" class="headerlink" title="命令对象与格式"></a>命令对象与格式</h3><p><code>docker-compose</code> 命令的基本的使用格式是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure></p><h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><ul><li>-f, –file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。 </li><li>-p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。 </li><li>–x-networking 使用 Docker 的可拔插网络后端特性 </li><li>–x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge </li><li>–verbose 输出更多调试信息。 </li><li>-v, –version 打印版本并退出 </li></ul><h3 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h3><p><strong>Tips</strong>: 这里的<code>service name</code>是指<code>服务</code>的名称，不是container name 或者 container id</p><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>构建（重新构建）项目中的服务容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build [options] [SERVICE...]</span><br></pre></td></tr></table></figure></p><p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db<br>选项包括：</p><ul><li><code>--force-rm</code> 删除构建过程中的临时容器 </li><li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程） </li><li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像</li></ul><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因 </p><h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络 </p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>进入指定的容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果执行/bin/bash失败，报错OCI runtime exec failed,是因为bash不存在，替换成sh   </span></span><br><span class="line"></span><br><span class="line">docker-compose <span class="built_in">exec</span> web /bin/sh</span><br></pre></td></tr></table></figure></p><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><p>列出 Compose 文件中包含的镜像 </p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>格式为 <code>docker-compose kill [options] [SERVICE...]</code> </p><p>通过发送 SIGKILL 信号来强制停止服务容器 </p><p>支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose <span class="built_in">kill</span> -s SIGINT</span><br></pre></td></tr></table></figure><h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><p>查看服务容器的输出。<br>默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 –no-color 来关闭颜色。  </p><p>格式为：<code>docker-compose logs [options] [SERVICE...]</code> </p><h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h3><p>暂停服务<br>格式为：<code>docker-compose pause [SERVICE...]</code> </p><h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>打印某个容器端口所映射的公共端口 </p><p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code> </p><p>选项：</p><ul><li>–protocol=proto 指定端口协议，tcp（默认值）或者 udp。</li><li>–index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1） </li></ul><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run ubuntu ping docker.com</span><br></pre></td></tr></table></figure></p><p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p><p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p><p>两个不同点：</p><p>给定命令将会覆盖原有的自动运行命令；</p><p>不会自动创建端口，以避免冲突。</p><p>如果不希望自动启动关联的容器，可以使用 –no-deps 选项，例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run --no-deps web python manage.py shell</span><br></pre></td></tr></table></figure></p><p>将不会启动 web 容器所关联的其它容器. </p><p>选项：</p><ul><li>-d 后台运行容器。</li><li>–name NAME 为容器指定一个名字。</li><li>–entrypoint CMD 覆盖默认的容器启动指令。</li><li>-e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。</li><li>-u, –user=”” 指定运行容器的用户名或者 uid。</li><li>–no-deps 不自动启动关联的服务容器。</li><li>–rm 运行命令后自动删除容器，d 模式下将忽略。</li><li>-p, –publish=[] 映射容器端口到本地主机。</li><li>–service-ports 配置服务端口并映射到本地主机。</li><li>-T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。 </li></ul><h3 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h3><p>设置指定服务运行的容器个数 </p><p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code> </p><p>通过 <code>service=num</code> 的参数来设置数量。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose scale web=3 db=2</span><br></pre></td></tr></table></figure></p><p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。 </p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><h3 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a>unpause</h3><p>启动已暂停的服务 </p><h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><p>格式为 <code>docker-compose up [options] [SERVICE...]</code> </p><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作 </p><p>链接的服务都将会被自动启动，除非已经处于运行状态 </p><p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试 </p><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。 </p><p>选项：</p><ul><li>-d 在后台运行服务容器。</li><li>–no-color 不使用颜色来区分不同的服务的控制台输出。</li><li>–no-deps 不启动服务所链接的容器。</li><li>–force-recreate 强制重新创建容器，不能与 –no-recreate 同时使用。</li><li>–no-recreate 如果容器已经存在了，则不重新创建，不能与 –force-recreate 同时使用。</li><li>–no-build 不自动构建缺失的服务镜像。</li><li>-t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）</li></ul><h2 id="Compose-模板文件"><a href="#Compose-模板文件" class="headerlink" title="Compose 模板文件"></a>Compose 模板文件</h2><p>模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 docker run 相关参数的含义都是类似的。 </p><p>默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure></p><p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像 </p><p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中再次设置。 </p><h3 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h3><p>指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。 </p><p>可以使用 <code>context</code> 指令指定 Dockerfile 所在文件夹的路径 </p><p>使用 <code>dockerfile</code> 指令指定 Dockerfile 文件名 </p><p>使用 <code>arg</code> 指令指定构建镜像时的变量 </p><p>使用 <code>cache_from</code> 指定构建镜像的缓存<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  cache_from:</span><br><span class="line">    - alpine:latest</span><br><span class="line">    - corp/web_app:3.14</span><br></pre></td></tr></table></figure></p><h3 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a>cap_add, cap_drop</h3><p>指定容器的内核能力（capacity）分配 </p><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>覆盖容器启动后默认执行的命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span>: <span class="built_in">echo</span> <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure></p><h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: docker-web-container</span><br></pre></td></tr></table></figure></p><blockquote><p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称 </p></blockquote><h3 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h3><p>指定设备映射关系。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices:</span><br><span class="line">  - <span class="string">"/dev/ttyUSB1:/dev/ttyUSB0"</span></span><br></pre></td></tr></table></figure></p><h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h3><p>解决容器的依赖、启动先后的问题。<br>以下例子中会先启动 redis db 再启动 web<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。 </p></blockquote><h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h3><p>自定义 <code>DNS</code> 服务器。可以是一个值，也可以是一个列表。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 114.114.114.114</span><br></pre></td></tr></table></figure></p><h3 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h3><p>从文件中获取环境变量，可以为单独的文件路径或列表。 </p><p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径 </p><p>如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure><p>环境变量文件中每一行必须符合格式，支持 # 开头的注释行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure></p><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>设置环境变量。可以使用数组或字典两种格式 </p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SESSION_SECRET:</span><br><span class="line"></span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SESSION_SECRET</span><br></pre></td></tr></table></figure><p>如果变量名称或者值中用到 true|false，yes|no 等表达 <code>布尔</code> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。 </p><h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>暴露端口，但不映射到宿主机，只被连接的服务访问 </p><p>仅可以指定内部端口为参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - <span class="string">"3000"</span></span><br><span class="line"> - <span class="string">"8000"</span></span><br></pre></td></tr></table></figure><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>指定为镜像名称或镜像 ID </p><h3 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h3><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。 </p><p>例如，下面的 Compose 文件将从运行它的环境中读取变量 <code>${MONGO_VERSION}</code> 的值，并写入执行的指令中。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"3"</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">db:</span><br><span class="line">  image: <span class="string">"mongo:<span class="variable">$&#123;MONGO_VERSION&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>如果执行 <code>MONGO_VERSION=3.2</code> <code>docker-compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；如果执行 <code>MONGO_VERSION=2.8</code> docker-compose up 则会启动一个 <code>mongo:2.8</code> 镜像的容器。 </p><p>若当前目录存在 <code>.env</code> 文件，执行 docker-compose 命令时将从该文件中读取变量。</p><p>在当前目录新建 <code>.env</code> 文件并写入以下内容。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持 # 号注释</span></span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure></p><p>执行 docker-compose up 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="常见问题总结"><a href="#常见问题总结" class="headerlink" title="常见问题总结"></a>常见问题总结</h2><p><a href="https://docker_practice.gitee.io/appendix/faq/" target="_blank" rel="noopener">常见问题总结</a></p><h2 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h2><p><a href="https://docker_practice.gitee.io/appendix/resources/" target="_blank" rel="noopener">资源链接</a> </p><h2 id="进阶深入"><a href="#进阶深入" class="headerlink" title="进阶深入"></a>进阶深入</h2><p>进阶深入，参考原文档<a href="https://docker_practice.gitee.io/" target="_blank" rel="noopener">《Docker — 从入门到实践》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://docker_practice.gitee.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阅读《Docker — 从入门到实践》&lt;/a&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 i
      
    
    </summary>
    
      <category term="后端" scheme="https://pengwenwu.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Docker" scheme="https://pengwenwu.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>js和php闭包使用和区别</title>
    <link href="https://pengwenwu.github.io/2018/05/25/js%E5%92%8Cphp%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>https://pengwenwu.github.io/2018/05/25/js和php闭包使用和区别/</id>
    <published>2018-05-24T16:14:40.000Z</published>
    <updated>2018-06-07T12:43:06.466Z</updated>
    
    <content type="html"><![CDATA[<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><blockquote><p>如果只是省去函数名，单纯的当作一个函数式方法返回，只能称为匿名函数（闭包需要将匿名函数当作结果返回），比如：  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>));  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// php</span></span><br><span class="line">$foo = <span class="function"><span class="keyword">function</span><span class="params">($a, $b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $a + $b;</span><br><span class="line">&#125;; <span class="comment">// 一定要加分号</span></span><br><span class="line"><span class="keyword">echo</span> $foo(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote><p>闭包通常是用来创建内部变量，使得这些变量不得被外部随意修改，而只能通过指定的函数接口去修改  </p></blockquote><h4 id="js闭包"><a href="#js闭包" class="headerlink" title="js闭包"></a>js闭包</h4><p>这里举一个阮老师博客里的例子，<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html?20120612141317#comments" target="_blank" rel="noopener">阮老师博客：学习Javascript闭包（Closure）</a>  </p><h5 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a>js基础</h5><p>参考链接：<a href="https://github.com/creeperyang/blog/issues/16" target="_blank" rel="noopener">深入理解JS中声明提升、作用域（链）和<code>this</code>关键字</a>  </p><ul><li>js比较特殊的一点是：函数内部可以直接读取到全局变量（对于阮老师的这句话不是很能理解，大概是想表达的意思：父作用域的变量可以在子作用域直接访问，而不需要去声明访问真正的全局变量？） <ul><li>大部分语言，变量都是先声明在使用，而对于js，具有声明提升的特性（不管在哪里声明，都会在代码执行前处理）</li><li>函数和变量的声明总是会隐式地被移动到当前作用域的顶部，函数的声明优先级高于变量的声明</li><li>var 会在当前作用域声明一个变量，而未声明的变量，会隐式地创建一个全局变量  </li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明提升</span></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// 1, 未报错</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上文链接中的例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testOrder</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg); <span class="comment">// arg是形参，不会被重新定义</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 因为函数声明比变量声明优先级高，所以这里a是函数</span></span><br><span class="line">    <span class="keyword">var</span> arg = <span class="string">'hello'</span>; <span class="comment">// var arg;变量声明被忽略， arg = 'hello'被执行</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// var a;被忽视; a = 10被执行，a变成number</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fun'</span>);</span><br><span class="line">    &#125; <span class="comment">// 被提升到作用域顶部</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 输出10</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg); <span class="comment">// 输出hello</span></span><br><span class="line">&#125;; </span><br><span class="line">testOrder(<span class="string">'hi'</span>);</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">hi </span></span><br><span class="line"><span class="comment">function a() &#123;</span></span><br><span class="line"><span class="comment">        console.log('fun');</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">10 </span></span><br><span class="line"><span class="comment">hello </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 局部作用域</span></span><br><span class="line">    foo = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">foo; <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line">foo = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 局部作用域</span></span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">foo; <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><ul><li>js变量的查找是从里往外的，直到最顶层（全局作用域），并且一旦找到，即停止向上查找。所有内部函数可以访问函数外部的变量，反之无效  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    bar(b * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//a is not defined</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    addNum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 这里未通过var去声明，默认是全局变量</span></span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foo2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tmp = foo1();</span><br><span class="line">tmp();  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">addNum();</span><br><span class="line">tmp(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>这里第二次调用foo2函数，foo1函数的局部变量num并没有被初始化为0，说明打印的是内存中的num。正常函数在每次调用结束后都会销毁局部变量，在重新调用的时候会再次声明变量；而这边没有重新声明的原因是：把foo2函数赋值给了一个全局变量tmp，导致foo2函数一直存在内存中，而foo2函数依赖于foo1函数存在，所以foo1函数也存在内存中，并没有被销毁，所以foo1的局部变量也是存在内存中。  </p></blockquote><ul><li><code>this</code>的上下文基于函数调用的情况。和函数在哪定义无关，而和函数怎么调用有关。<ul><li>在全局上下文（任何函数以外），this指向全局对象(windows)</li><li>在函数内部时，this由函数怎么调用来确定<ul><li>当函数作为对象方法调用时，this指向该对象  </li></ul></li></ul></li></ul><p>下面是阮老师博客里的两个思考题：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">　　name : <span class="string">"My Object"</span>,</span><br><span class="line">　　getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">// The Window</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">"My Object"</span>,</span><br><span class="line">　　getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　    <span class="keyword">return</span> that.name;</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());<span class="comment">// My Object</span></span><br></pre></td></tr></table></figure><blockquote><p><code>this</code>的作用域好像一直是个比较奇怪的东西，对于上面两个例子，我的理解是：第一个例子，是在方法里调用的<code>this</code>，而这个<code>this</code>并没有<code>声明</code>，会隐式地创建一个全局变量，所以调用的全局的name；第二个，调用的<code>that</code>的时候，会向顶级链式查找是否声明<code>that</code>，而这个that有this赋值，这里的this又是通过对象方法调用，则该this指向这个object对象，所有最终调用的是object作用域内的name。不知道这么理解是不是有问题，还望大神指正。  </p></blockquote><p><strong>那其实js闭包的主要目的：访问函数内部的局部变量，即延长作用域链</strong><br>参考链接：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">js闭包MDN文档</a>  </p><h4 id="php闭包"><a href="#php闭包" class="headerlink" title="php闭包"></a>php闭包</h4><h5 id="php回调函数"><a href="#php回调函数" class="headerlink" title="php回调函数"></a>php回调函数</h5><p><a href="http://php.net/manual/zh/function.call-user-func.php" target="_blank" rel="noopener">mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $… ]] )</a><br><a href="http://php.net/manual/zh/function.call-user-func-array.php" target="_blank" rel="noopener">mixed call_user_func_array ( callable $callback , array $param_arr )</a>  </p><p>这两个函数都是把第一个参数作为回调函数d调用，后面接收参数，区别就是第二个函数第二参数接收数组；在使用上唯一的区别就是，<code>call_user_func</code>函数无法接收<code>引用传递</code>; 个人觉得同样是使用，call_user_func 相比call_user_func_array完全可以被替代，不知道是不是有一些性能上的优势。具体使用样例，请参考官方文档。  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(&amp;$a, &amp;$b)</span> </span>&#123;</span><br><span class="line">    $a ++;</span><br><span class="line">    $b --;</span><br><span class="line">&#125;;</span><br><span class="line">$a = $b = <span class="number">10</span>;</span><br><span class="line">call_user_func_array(<span class="string">'foo'</span>, [&amp;$a, &amp;$b]);</span><br><span class="line"><span class="keyword">echo</span> $a.<span class="string">"\n"</span>, $b; <span class="comment">// 11, 9</span></span><br></pre></td></tr></table></figure><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>基本用法，跟js的闭包类似  </p><ul><li>普通调用  </li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">global</span> $tmp = <span class="string">'hello world'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    var_dump(<span class="keyword">global</span> $tmp);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// null, 函数内部无法直接调用上级作用域的变量，除非声明为全局变量</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$foo1 = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $a = <span class="number">10</span>;</span><br><span class="line">    $foo2 = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        var_dump($a);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> $foo2;</span><br><span class="line">&#125;;</span><br><span class="line">$tmp = $foo1();</span><br><span class="line">$tmp();  <span class="comment">// null，原因同上</span></span><br></pre></td></tr></table></figure><ul><li>php想要能够获取上级作用域的变量，需要通过use传递  </li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$foo1 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $a = <span class="number">10</span>;</span><br><span class="line">    $foo2 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($a)</span> </span>&#123;</span><br><span class="line">        var_dump($a);</span><br><span class="line">        $a ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    $foo2();</span><br><span class="line">    <span class="keyword">return</span> $foo2;</span><br><span class="line">&#125;;</span><br><span class="line">$tmp = $foo1();</span><br><span class="line">$tmp();  <span class="comment">// 10, 10,  use并不能实际改变变量的值，只是值传递</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$foo1 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $a = <span class="number">10</span>;</span><br><span class="line">    $foo2 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">(&amp;$a)</span> </span>&#123;</span><br><span class="line">        var_dump($a);</span><br><span class="line">        $a ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    $foo2();</span><br><span class="line">    <span class="keyword">return</span> $foo2;</span><br><span class="line">&#125;;</span><br><span class="line">$tmp = $foo1();</span><br><span class="line">$tmp();  <span class="comment">// 10, 11,  通过值传递改变变量的值</span></span><br></pre></td></tr></table></figure><ul><li>下面两段代码的区别，不是很明白，望大佬指点，为什么后一个值传递就可以获取到已经改变后变量的值。好像都是在调用方法之前，已经执行过变量的递增了吧？  </li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 值传递</span></span><br><span class="line">$foo1 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $a = <span class="number">10</span>;</span><br><span class="line">    $foo2 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($a)</span> </span>&#123;</span><br><span class="line">        var_dump($a);</span><br><span class="line">    &#125;;</span><br><span class="line">    $a ++;</span><br><span class="line">    <span class="keyword">return</span> $foo2;</span><br><span class="line">&#125;;</span><br><span class="line">$tmp = $foo1();</span><br><span class="line">$tmp();  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 引用传递</span></span><br><span class="line">$foo1 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $a = <span class="number">10</span>;</span><br><span class="line">    $foo2 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">(&amp;$a)</span> </span>&#123;</span><br><span class="line">        var_dump($a);</span><br><span class="line">    &#125;;</span><br><span class="line">    $a ++;</span><br><span class="line">    <span class="keyword">return</span> $foo2;</span><br><span class="line">&#125;;</span><br><span class="line">$tmp = $foo1();</span><br><span class="line">$tmp();  <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><ul><li>正确使用  </li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 值传递</span></span><br><span class="line">$foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $a = <span class="number">10</span>;</span><br><span class="line">    $foo2 = <span class="function"><span class="keyword">function</span> <span class="params">($num)</span> <span class="title">use</span> <span class="params">($a)</span> </span>&#123;</span><br><span class="line">        var_dump($num + $a);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> $foo2;</span><br><span class="line">&#125;;</span><br><span class="line">$tmp = $foo();</span><br><span class="line">$tmp(<span class="number">100</span>); <span class="comment">// 110</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 引用传递</span></span><br><span class="line">$foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $a = <span class="number">10</span>;</span><br><span class="line">    $foo2 = <span class="function"><span class="keyword">function</span> <span class="params">($num)</span> <span class="title">use</span> <span class="params">(&amp;$a)</span> </span>&#123;</span><br><span class="line">        var_dump($num + $a);</span><br><span class="line">$a ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> $foo2;</span><br><span class="line">&#125;;</span><br><span class="line">$tmp = $foo();</span><br><span class="line">$tmp(<span class="number">100</span>); <span class="comment">// 110</span></span><br><span class="line">$tmp(<span class="number">100</span>); <span class="comment">// 111</span></span><br><span class="line">$tmp(<span class="number">100</span>); <span class="comment">// 112  跟js类似，保证变量常驻内存</span></span><br></pre></td></tr></table></figure><h5 id="php-Closure-类"><a href="#php-Closure-类" class="headerlink" title="php Closure 类"></a>php Closure 类</h5><ul><li><p><a href="http://php.net/manual/zh/closure.bind.php" target="_blank" rel="noopener">Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域</a><br>public static Closure Closure::bind ( Closure $closure , object $newthis [, mixed $newscope = ‘static’ ] )</p></li><li><p><a href="http://php.net/manual/zh/closure.bindto.php" target="_blank" rel="noopener">Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域</a><br>public Closure Closure::bindTo ( object $newthis [, mixed $newscope = ‘static’ ] )<br>对这两个方法不是很能理解。。。求指教  </p></li></ul><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>都是为了扩展作用域，获取内部变量  </p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>js能够在方法内部直接获取到父级作用域的变量，而php需要通过use声明，并且默认是值传递  </p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>不是很能理解应用场景，搜索了一下，很多只是写了一个闭包实现的购物车，感觉并不是那么的实用。</li><li>如果只是单纯的使用匿名函数，感觉还不如封装成一个私有方法  <blockquote><p>这些只是个人粗鄙的理解，望指正.</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;匿名函数&quot;&gt;&lt;a href=&quot;#匿名函数&quot; class=&quot;headerlink&quot; title=&quot;匿名函数&quot;&gt;&lt;/a&gt;匿名函数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如果只是省去函数名，单纯的当作一个函数式方法返回，只能称为匿名函数（闭包需要将匿名函数当作结果返回
      
    
    </summary>
    
      <category term="PHP" scheme="https://pengwenwu.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://pengwenwu.github.io/tags/PHP/"/>
    
      <category term="JS" scheme="https://pengwenwu.github.io/tags/JS/"/>
    
      <category term="闭包" scheme="https://pengwenwu.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>phpstorm或vscode使用psr2规范</title>
    <link href="https://pengwenwu.github.io/2018/05/14/phpstorm%E6%88%96vscode%E4%BD%BF%E7%94%A8psr2%E8%A7%84%E8%8C%83/"/>
    <id>https://pengwenwu.github.io/2018/05/14/phpstorm或vscode使用psr2规范/</id>
    <published>2018-05-13T16:16:13.000Z</published>
    <updated>2018-05-13T16:19:13.177Z</updated>
    
    <content type="html"><![CDATA[<ul><li>安装composer</li><li>全局安装phpcs</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer global require squizlabs/php_codesniffer</span><br></pre></td></tr></table></figure><h3 id="vscode直接插件搜索phpcs安装"><a href="#vscode直接插件搜索phpcs安装" class="headerlink" title="vscode直接插件搜索phpcs安装"></a>vscode直接插件搜索phpcs安装</h3><h3 id="phpstorm"><a href="#phpstorm" class="headerlink" title="phpstorm"></a>phpstorm</h3><p>全局安装phpcs后，会在<strong>C:\Users{user name}\AppData\Roaming\Composer\vendor\bin</strong>下生成一个<code>phpcs.bat</code>，后面会用到</p><ul><li>phpstorm -&gt; setting</li><li>languages &amp; Frameworks-&gt;PHP-&gt;Code Sniffer点击Configuration右侧的按钮</li><li>找到刚才的phpcs.bat，点击<code>Validate</code>，确认</li><li>Editor-&gt;Inspection-&gt;PHP</li><li>双击PHP Code Sniffer validation，点击Coding standard右侧的刷新按钮，然后选择psr2，确定</li></ul><p><strong>参考链接</strong>: <a href="https://laravel-china.org/topics/1692/how-to-use-phpstorm-gracefully" target="_blank" rel="noopener">如何优雅地使用phpstorm?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;安装composer&lt;/li&gt;
&lt;li&gt;全局安装phpcs&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp
      
    
    </summary>
    
      <category term="PHP" scheme="https://pengwenwu.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://pengwenwu.github.io/tags/PHP/"/>
    
      <category term="PSR" scheme="https://pengwenwu.github.io/tags/PSR/"/>
    
  </entry>
  
  <entry>
    <title>array_map, array_walk, array_filter的区别及使用</title>
    <link href="https://pengwenwu.github.io/2018/05/13/array-map-array-walk-array-filter%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>https://pengwenwu.github.io/2018/05/13/array-map-array-walk-array-filter的区别及使用/</id>
    <published>2018-05-13T08:33:22.000Z</published>
    <updated>2018-05-13T16:15:45.409Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>array_map, array_walk, array_filter的区别及使用</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// array_map, array_walk, array_filter的区别</span></span><br><span class="line">$arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">($value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $value * $value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span><span class="params">($value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $value &gt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span><span class="params">(&amp;$value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $value = $value * $value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// array_map 会返回新的数组, 不对原数组产生影响</span></span><br><span class="line">$new_arr = array_map(<span class="string">'foo'</span>, $arr);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'原数组:'</span>.var_export($arr, <span class="number">1</span>).<span class="string">"\n"</span>, <span class="string">'array_map修改后的数组：'</span>.var_export($new_arr, <span class="number">1</span>).<span class="string">"\n"</span>.<span class="string">"&lt;hr/&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// array_walk 返回bool值，callback需要通过值传递改变原有数组</span></span><br><span class="line">$res = array_walk($arr, <span class="string">'walk'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'修改后的数组:'</span>.var_export($arr, <span class="number">1</span>).<span class="string">"\n"</span>, <span class="string">'array_walk返回结果：'</span>.var_export($res, <span class="number">1</span>).<span class="string">"\n"</span>.<span class="string">"&lt;hr/&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// array_filter 返回筛选后的新数组，不对原数组产生影响</span></span><br><span class="line">$new_arr = array_filter($arr, <span class="string">'filter'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'原数组:'</span>.var_export($arr, <span class="number">1</span>).<span class="string">"\n"</span>, <span class="string">'array_filter返回结果：'</span>.var_export($new_arr, <span class="number">1</span>).<span class="string">"\n"</span>.<span class="string">"&lt;hr/&gt;"</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;array_map, array_walk, array_filter的区别及使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="PHP" scheme="https://pengwenwu.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://pengwenwu.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>windows下cmd/powershell中文乱码解决方法</title>
    <link href="https://pengwenwu.github.io/2018/05/13/windows%E4%B8%8Bcmd-powershell%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://pengwenwu.github.io/2018/05/13/windows下cmd-powershell中文乱码解决方法/</id>
    <published>2018-05-13T08:09:01.000Z</published>
    <updated>2018-05-13T08:13:21.915Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>windows下cmd或者powershell运行php文件中文乱码  </p></blockquote><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>执行下面的命令，切换成utf-8编码</p><pre><code>chcp 65001</code></pre><p>这个指标不治本，查了说是可以修改注册表，但是好像又会带来其他的坑（中文软件乱码、nodejs乱码），未测试过，不予评价。参考链接：<a href="https://www.zhihu.com/question/54724102" target="_blank" rel="noopener">https://www.zhihu.com/question/54724102</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;windows下cmd或者powershell运行php文件中文乱码  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方
      
    
    </summary>
    
      <category term="环境配置" scheme="https://pengwenwu.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="中文乱码" scheme="https://pengwenwu.github.io/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>hexo常用命令</title>
    <link href="https://pengwenwu.github.io/2018/05/13/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://pengwenwu.github.io/2018/05/13/hexo常用命令/</id>
    <published>2018-05-13T06:21:59.000Z</published>
    <updated>2018-06-07T12:42:55.389Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>hexo常用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;博客名称&quot;  =&gt; hexo new &quot;博客名称&quot; </span><br><span class="line">hexo clean # 清楚缓存</span><br><span class="line">hexo g  =&gt; hexo generate  #生成</span><br><span class="line">hexo p  =&gt; hexo publish # 发布</span><br><span class="line">hexo s  =&gt; hexo server  #启动服务预览</span><br><span class="line">hexo d  =&gt; hexo deploy  #部署</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>发布流程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;hexo常用命令&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
      <category term="Git" scheme="https://pengwenwu.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://pengwenwu.github.io/tags/Git/"/>
    
      <category term="Hexo" scheme="https://pengwenwu.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>git reset 和 revert 的区别和使用</title>
    <link href="https://pengwenwu.github.io/2018/05/13/git-reset-%E5%92%8C-revert-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://pengwenwu.github.io/2018/05/13/git-reset-和-revert-的区别和使用/</id>
    <published>2018-05-13T06:17:37.000Z</published>
    <updated>2018-05-13T06:22:41.234Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>git <code>revert</code> 撤销某次提交, 保留之前的commit, 同时创建一个新的commit(可用于<strong>公共分支</strong>)<br>git <code>reset</code> 撤销某个提交， 删除之前的commit, head回退 (多用于<strong>私有分支</strong>)<br><strong>区别</strong>: git revert 只是撤销某个commit, 保留该commit之前的提交结果</p></blockquote><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><blockquote><p>commit3: add log3<br>commit2: add log2<br>commit1: add log1</p></blockquote><h3 id="HEAD用法"><a href="#HEAD用法" class="headerlink" title="HEAD用法"></a>HEAD用法</h3><ul><li>HEAD^: 指向上一次commit</li><li>HEAD~100: 指向前第一百个commit</li><li>HEAD commit_id: 直接指向某个commit  </li></ul><h3 id="–soft、–mixed-默认-、–hard的区别"><a href="#–soft、–mixed-默认-、–hard的区别" class="headerlink" title="–soft、–mixed(默认)、–hard的区别"></a>–soft、–mixed(默认)、–hard的区别</h3><ul><li>–soft: 只是重置HEAD到某一个commit, 其余不会有任何变化(缓存区和工作目录都不会被改变)</li><li>–mixed(默认): 重置HEAD, 文件修改都将保存到缓存区(缓存区和你指定的提交同步，但工作目录不受影响)</li><li>–hard: 修改当前所有内容, 所有本地修改都将丢失(缓存区和工作目录都同步到你指定的提交). 找回执行命令: git reflow</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;git &lt;code&gt;revert&lt;/code&gt; 撤销某次提交, 保留之前的commit, 同时创建一个新的commit(可用于&lt;strong&gt;公共分支&lt;/strong&gt;)&lt;br&gt;git &lt;code&gt;reset&lt;/code&gt; 撤销某个提交， 删除之前
      
    
    </summary>
    
      <category term="Git" scheme="https://pengwenwu.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://pengwenwu.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git pull更新指定文件</title>
    <link href="https://pengwenwu.github.io/2018/05/13/git-pull%E6%9B%B4%E6%96%B0%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6/"/>
    <id>https://pengwenwu.github.io/2018/05/13/git-pull更新指定文件/</id>
    <published>2018-05-13T06:07:42.000Z</published>
    <updated>2018-05-13T06:17:02.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经常会遇到，几个文件一起提交了，但是某些文件是要先执行的，不然一起pull下来会加载报错</p><h3 id="更新git指定文件"><a href="#更新git指定文件" class="headerlink" title="更新git指定文件"></a>更新git指定文件</h3><p>git fetch<br>git checkout origin/master – path/to/file</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;经常会遇到，几个文件一起提交了，但是某些文件是要先执行的，不然一起pull下来会加载报错&lt;/p&gt;
&lt;h3 id=&quot;更新git指定文件&quot;&gt;&lt;a href=&quot;#更新git指定文件&quot; class=&quot;headerlink&quot; title=&quot;更新git指定文件
      
    
    </summary>
    
      <category term="Git" scheme="https://pengwenwu.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://pengwenwu.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>阅读《微服务设计》笔记</title>
    <link href="https://pengwenwu.github.io/2018/03/03/%E9%98%85%E8%AF%BB%E3%80%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://pengwenwu.github.io/2018/03/03/阅读《微服务设计》笔记/</id>
    <published>2018-03-03T10:14:59.000Z</published>
    <updated>2018-06-07T12:43:14.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录阅读《微服务设计》收获的点  </p></blockquote><h2 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a>什么是微服务？</h2><p><strong>一些协同工作的小而自治的服务</strong></p><h2 id="打破外键关系"><a href="#打破外键关系" class="headerlink" title="打破外键关系"></a>打破外键关系</h2><p><strong>对于有外键关系的表如何做服务拆分？</strong><br>通过api调用访问  </p><ul><li>优点：数据表拆分，进而服务拆分</li><li>缺点：增加了数据库的调用，会影响性能。需要测试是否在可接受范围内，权衡拆分服务带来的好处</li></ul><h2 id="共享表拆分"><a href="#共享表拆分" class="headerlink" title="共享表拆分"></a>共享表拆分</h2><p><strong>共享表拆分后，如何保证插入数据的一致性？</strong><br>设计之初为了减少数据库的调用，必然会建立基于外键的共享表。拆分之后，如何保证同时插入多张表数据的一致性？（某张表插入失败）  </p><ul><li>通过<code>事务</code>处理  </li><li>推荐对及时性较弱的操作，异常捕获后放入队列或者日志文件中进行延迟处理，保证<code>最终一致性</code>  </li><li>终止整个操作，再发起<code>补偿事务</code>来抵消之前的操作（自动化处理）</li><li><p><code>分布式事务</code>。通过专门的事务管理器工具来协调底层事务（不推荐，易出错，难扩展）</p><blockquote><p>阅读完感觉云里雾里，可能是自己的水平还没到达那个深度。收获大概是：了解了后端的架构，后期拓展可能会遇到的问题，以及解决这样问题的思路。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录阅读《微服务设计》收获的点  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是微服务？&quot;&gt;&lt;a href=&quot;#什么是微服务？&quot; class=&quot;headerlink&quot; title=&quot;什么是微服务？&quot;&gt;&lt;/a&gt;什么是微服务？&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="后端" scheme="https://pengwenwu.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="微服务" scheme="https://pengwenwu.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://pengwenwu.github.io/2018/01/21/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://pengwenwu.github.io/2018/01/21/Linux常用命令/</id>
    <published>2018-01-21T13:27:15.000Z</published>
    <updated>2018-03-05T15:19:56.078Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一些阅读《鸟哥的Linux私房菜-基础学习篇》中不太熟悉的命令  </p></blockquote><h3 id="软连接、硬链接"><a href="#软连接、硬链接" class="headerlink" title="软连接、硬链接"></a>软连接、硬链接</h3><blockquote><p><strong>软连接</strong>：连接文件的内容只会写上目标文件的“文件名”，实际是通过记录的目标文件地址去访问实际存储内容。大小就是文件名大小。如果删除目标文件，则当前文件无法访问。(等同于windows的快捷方式)  </p><p> <strong>硬连接</strong>：只能针对单个文件，实际会创建一个一模一样的“文件”(权限、大小)，连接数增加。连接到同一个地址，只是使用了不同的文件名，均可以对源文件进行数据修改，删除任意一个，不影响其余文件访问</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp -s test test1  </span><br><span class="line">ln -s test test1  # 软连接(快捷方式)</span><br><span class="line"></span><br><span class="line">cp -l demo.php demo1.php </span><br><span class="line">ln -l demo.php demo1.php # 硬链接(只支持单个文件)</span><br></pre></td></tr></table></figure><h3 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a>查看分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#-z gzip压缩，-j bzip2压缩</span><br><span class="line">tar -zcvf [newfilename] filename </span><br><span class="line">tar -zxvf filename.tar.gz [-C 目录] 解压要到指定目录</span><br></pre></td></tr></table></figure><h3 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type name</span><br></pre></td></tr></table></figure><h3 id="命名别名"><a href="#命名别名" class="headerlink" title="命名别名"></a>命名别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias rm=&apos;rm -i&apos;</span><br><span class="line">alias st=&apos;status&apos;</span><br><span class="line"></span><br><span class="line">unalias rm  #取消别名</span><br></pre></td></tr></table></figure><h3 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h3><blockquote><p>标准输入：&lt;或&lt;&lt; (将由键盘输入的数据由文件代替/<strong>结束输入</strong>)<br>标准输出：&gt;或&gt;&gt; (覆盖/追加)<br>标准错误输出：2&gt;或2&gt;&gt; (覆盖/追加)  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; catfile &lt;&lt; eof</span><br><span class="line">&gt;This is a test.</span><br><span class="line">&gt;Ok now stop</span><br><span class="line">&gt;eof</span><br></pre></td></tr></table></figure><h3 id="命令执行判断：-amp-amp"><a href="#命令执行判断：-amp-amp" class="headerlink" title="命令执行判断：; || &amp;&amp;"></a>命令执行判断：; || &amp;&amp;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#依次执行</span><br><span class="line">echo 1; echo 2; echo 3 </span><br><span class="line"></span><br><span class="line">#若cmd1正确执行，则开始执行cmd2</span><br><span class="line">#若cmd1执行错误，则cmd2不执行</span><br><span class="line">cmd1 &amp;&amp; cmd2   </span><br><span class="line">               </span><br><span class="line">#若cmd1正确执行，则不执行cmd2</span><br><span class="line">#若cmd1执行错误，则开始执行cmd2</span><br><span class="line">cmd1 || cmd2</span><br></pre></td></tr></table></figure><h3 id="选取命令：cut-grep"><a href="#选取命令：cut-grep" class="headerlink" title="选取命令：cut, grep"></a>选取命令：cut, grep</h3><blockquote><p>cut:<br>  -d：分割字符，与-f一起用<br>  -f：取出第几段<br>  -c：取出固定字符区间  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 列出第三段，第五段</span><br><span class="line">echo $PATH | cut -d &apos;:&apos; -f 3,5 </span><br><span class="line"></span><br><span class="line"># 取得第5字符之后</span><br><span class="line">echo $PATH | cut -c 5-</span><br></pre></td></tr></table></figure><h3 id="排序命令-sort-wc-uniq"><a href="#排序命令-sort-wc-uniq" class="headerlink" title="排序命令:sort, wc, uniq"></a>排序命令:sort, wc, uniq</h3><blockquote><p>sort [-fbMnrtuk]<br>uniq [-ic]<br>-c：进行计数  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每个人登录的次数</span><br><span class="line">last | cut -d &apos; &apos; -f 1 | sort | uniq -c</span><br></pre></td></tr></table></figure><blockquote><p>wc [-lwm]<br>-l：仅列出行<br>-w：仅列出多少字<br>-m：多少字符</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录一些阅读《鸟哥的Linux私房菜-基础学习篇》中不太熟悉的命令  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;软连接、硬链接&quot;&gt;&lt;a href=&quot;#软连接、硬链接&quot; class=&quot;headerlink&quot; title=&quot;软连接、硬链接&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://pengwenwu.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://pengwenwu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>hexo + github搭建个人博客教程</title>
    <link href="https://pengwenwu.github.io/2018/01/14/hexo%20+%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    <id>https://pengwenwu.github.io/2018/01/14/hexo + github搭建个人博客教程/</id>
    <published>2018-01-14T08:09:07.000Z</published>
    <updated>2018-06-07T12:42:44.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一年前，临近毕业。为了准备面试，才刻意去准备了<code>github</code>以及<code>blog</code>。<br>自从找到工作后，这两个基本没怎么维护过，想想未免太功利了点。</p><p>主要是前几天，又踩到坑了，想去找以前的记录，很麻烦。<br>之前虽然每天都会写工作总结，一些踩过的坑记在为知笔记上，没有<code>分类</code>、<code>标签</code>，后面再想去找很困难。<br>痛定思痛，该记的东西少不掉，索性优雅一点。</p><p>之前用的是博客园，但是那个账号密码老记不住，干脆自己搭建一个吧，好歹也是一个码农。<br>然后花了两个晚上加一个上午，通过<code>hexo</code>和<code>github</code>搭建了一个个人博客。<br>网上教程、文档那么多，为什么花这么久时间？当然是踩坑了啊。<br>所以下面会记录一些遇到的问题和坑。<br>如果你看完这边文章，那你只需要<code>两个小时</code>就能搭建成功。欢迎有兴趣的小伙伴尝试一下。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><strong>node.js</strong></li><li><strong>git</strong></li></ol><p>这两个应用windows用户直接搜索下载安装就可以。<br>如果习惯了使用linux命令的朋友，推荐windows神器<code>cmder</code>。<br>可以直接在windows环境下使用linux命令，样式可调，再也不要用黑乎乎的cmd了，而且自带git，完全可以不用下载windows git。</p><h3 id="正式安装hexo"><a href="#正式安装hexo" class="headerlink" title="正式安装hexo"></a>正式安装hexo</h3><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方中文文档</a></p><p>在node.js安装好的前提下，全局安装hexo<br>如何判断node.js是否安装成功？执行以下命令，如果能够看到版本号则说明安装成功了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure></p><p>安装<code>hexo</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><p>自选合适的目录，新建文件夹&lt;folder&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;folder&gt;</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>不再赘述，直接看官方文档。</p><h3 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h3><p>新建仓库，仓库名必须为<strong>[your_name.github.io]</strong></p><blockquote><p>补充：本地配置github ssh连接，方便自动部署，以及clone你喜欢的主题(theme)</p></blockquote><p>windows用户直接在<code>c:/用户/youername/.ssh/</code>下查看是否有<code>id_rsa.pub</code>文件。<br>没有的话命令行执行命令<code>ssh-keygen -t rsa -C &quot;your eamil&quot;</code>，会自动生成<code>id_rsa.pub</code>文件，打开后复制。</p><p>github-&gt;头像-&gt;Settings→SSH kyes→Add SSH key，粘贴复制的内容。</p><p>配置本地账户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name “your_username”  #设置用户名</span><br><span class="line">git config --global user.email “your_email”  #设置邮箱地址,最好使用注册邮箱地址</span><br></pre></td></tr></table></figure></p><p>测试是否配置成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><h3 id="hexo配置以及使用"><a href="#hexo配置以及使用" class="headerlink" title="hexo配置以及使用"></a>hexo配置以及使用</h3><p>有两个配置文件：</p><ul><li>一个是根目录下的<code>_config.yml</code>称为<code>站点配置</code>文件</li><li>一个是<code>themes/landscape/_config.yml</code>称为<code>主题配置</code>文件(默认主题：landscape)</li></ul><p>站点配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url: https://yourname.github.io/</span><br><span class="line">theme: landscape #选择你想用的主题，我用的是indigo</span><br><span class="line">deploy:</span><br><span class="line">    type: git   # 不要使用github</span><br><span class="line">    repo: git@github.com:pengwenwu/pengwenwu.github.io.git # 使用ssh连接</span><br><span class="line">    branch: master  # 默认master分支</span><br><span class="line">    message: add new blog # 自动部署commit备注，可不填</span><br></pre></td></tr></table></figure><h4 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h4><p><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">hexo命令参考</a></p><p><code>hexo n &quot;我的博客&quot;</code> == <code>hexo new &quot;我的博客&quot;</code> #新建文章<br><code>hexo p</code> == <code>hexo publish</code><br><code>hexo g</code> == <code>hexo generate</code> #生成<br><code>hexo s</code> == <code>hexo server</code> #启动服务本地预览<br><code>hexo d</code> == <code>hexo deploy</code> #部署<br><code>hexo clean</code> #清除缓存 网页正常情况下可以忽略此条命令  </p><p><code>hexo server</code> #Hexo 会监视文件变动并自动更新，您无须重启服务器。<br><code>hexo server -s</code> #静态模式<br><code>hexo server -p 5000</code> #更改端口<br><code>hexo server -i 192.168.1.1</code> #自定义 IP</p><p>在执行之前，记得安装自动部署  (–save 加不加的区别在于是否写入到依赖文件package.json中)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>正常本地预览，直接执行<code>hexo s</code>,如果要发布话最好执行<code>clean</code>命令，会去删除生成的public文件，完整部署命令:<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>。或者直接<code>hexo d -g</code></p><h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><p>安装完自动部署后，是不需要本地git init新建仓库的。执行<code>hexo g</code>会在根目录生成public文件夹，自动部署，<br>本质是将public文件夹内容全部提交到仓库中去，默认会访问编译好的index.html。</p><p>如果部署完，访问your_name.github.io 404,可能有下面几个原因</p><ol><li>首先检查仓库文件，是不是全都是public的文件内容，如果整个本地blog文件夹都提交了，首先清空<br>仓库，然后删除本地<code>.deploy_git</code>文件夹，再重新部署</li><li>文件有报错，本地<code>hexo s</code>观察是否有报错。</li></ol><p>不喜欢原主题的朋友，可以github去找喜欢的主题。执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone XXXX.next.git themes\next</span><br></pre></td></tr></table></figure></p><p>这个会将新的主题下载到themes下对应的next目录，next为主题的名字。</p><p>主题的配置，可以看文档，修改对应的<code>主题配置</code>文件。<br>我使用的主题是<code>indigo</code>,详细文档<a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">indigo</a></p><p><code>markdown</code>不会使用的朋友，参考链接<a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">markdown中文文档</a><br>如果没有ide的话，可以使用在线预览<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">Cmd Markdown</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一年前，临近毕业。为了准备面试，才刻意去准备了&lt;code&gt;github&lt;/code&gt;以及&lt;code&gt;blog&lt;/code&gt;。&lt;br&gt;自从找到
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://pengwenwu.github.io/tags/Hexo/"/>
    
      <category term="Github" scheme="https://pengwenwu.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>如何将一个数组乱序？</title>
    <link href="https://pengwenwu.github.io/2018/01/13/%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F%EF%BC%9F/"/>
    <id>https://pengwenwu.github.io/2018/01/13/如何将一个数组乱序？/</id>
    <published>2018-01-13T13:55:11.000Z</published>
    <updated>2018-01-14T08:13:34.204Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是很久以前博客园的博客，打个小样。</p></blockquote><p>前几天php实习面试，问到一个问题：<strong>如何将一个数组乱序？</strong><br>答：使用自带的array_rand()或者shuffle()函数，或者用随机数取值赋值给新的数组。<br>又问：万一一直随机到同一个数怎么办？<br>那就进行判断，如果已经取过的位置，重新选取随机数。<br>这样问题就来了：随着新数组长度增加，原数组中的随机数选取碰撞几率会原来越大，最后几乎是一直碰撞的。也没有想出更好的办法。</p><p>后来回家后查了一下，总结一下，有以下几种方法：</p><ol><li><p>使用自带的函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle_rand1</span><span class="params">($arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"原来数组为："</span>;</span><br><span class="line">print_r($arr);</span><br><span class="line">shuffle($arr);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;乱序数组为："</span>;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第一时间想到的方法，就是随机取值，赋值给新的数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle_rand2</span><span class="params">($arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"原来数组为："</span>;</span><br><span class="line">print_r($arr);</span><br><span class="line">$len = count($arr);</span><br><span class="line">$shuffle_arr = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">while</span>(count($shuffle_arr)&lt;$len)&#123;</span><br><span class="line">$index = rand(<span class="number">0</span>,$len<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(!in_array($index, $shuffle_arr))&#123;</span><br><span class="line">$shuffle_arr[] = $index;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$newarr = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">foreach</span> ($shuffle_arr <span class="keyword">as</span> $v) &#123;</span><br><span class="line">$newarr[] = $arr[$v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;新的数组为："</span>;</span><br><span class="line">print_r($newarr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组中随机取一个元素赋值给新的数组，然后将原数组最后一位赋值到该位置,数组长度减一，继续重复上述步奏</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle_rand3</span><span class="params">($arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"原来数组为："</span>;</span><br><span class="line">print_r($arr);</span><br><span class="line">$len = count($arr);</span><br><span class="line">$shuffle_arr = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">while</span>($len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">$index = rand(<span class="number">0</span>,$len<span class="number">-1</span>);</span><br><span class="line">$shuffle_arr[] = $arr[$index];</span><br><span class="line">$arr[$index] = $arr[$len<span class="number">-1</span>];</span><br><span class="line">$len--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;新的数组为："</span>;</span><br><span class="line">print_r($shuffle_arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在具有n个元素的数组中，对0到n-1一次进行与一个随机位置元素进行交换,这种方法不需要新建一个数组，直接在原数组中进行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle_rand4</span><span class="params">($arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"原来数组为："</span>;</span><br><span class="line">print_r($arr);</span><br><span class="line">$len = count($arr);</span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;$len;$i++)&#123;</span><br><span class="line">$index = rand(<span class="number">0</span>,$len<span class="number">-1</span>);</span><br><span class="line">$temp = $arr[$i];</span><br><span class="line">$arr[$i] = $arr[$index];</span><br><span class="line">$arr[$index] = $temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;新的数组为："</span>;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是很久以前博客园的博客，打个小样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前几天php实习面试，问到一个问题：&lt;strong&gt;如何将一个数组乱序？&lt;/strong&gt;&lt;br&gt;答：使用自带的array_rand()或者shuffle()函数，或者
      
    
    </summary>
    
      <category term="算法" scheme="https://pengwenwu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PHP" scheme="https://pengwenwu.github.io/tags/PHP/"/>
    
      <category term="算法" scheme="https://pengwenwu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://pengwenwu.github.io/2018/01/10/hello-world/"/>
    <id>https://pengwenwu.github.io/2018/01/10/hello-world/</id>
    <published>2018-01-10T15:18:30.173Z</published>
    <updated>2018-01-10T15:18:30.173Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
