{"meta":{"title":"Pena's Blog","subtitle":"莫道君行早，更有早行人","description":"pengwenwu的个人博客","author":"pengwenwu","url":"https://pengwenwu.github.io"},"pages":[{"title":"categories","date":"un55fin55","updated":"un00fin00","comments":true,"path":"categories/index.html","permalink":"https://pengwenwu.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"un55fin55","updated":"un00fin00","comments":true,"path":"tags/index.html","permalink":"https://pengwenwu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"RabbitMq客户端-php-amqplib库","slug":"RabbitMq客户端-php-amqplib库","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2018/09/03/RabbitMq客户端-php-amqplib库/","link":"","permalink":"https://pengwenwu.github.io/2018/09/03/RabbitMq客户端-php-amqplib库/","excerpt":"","text":"官网教程地址：http://www.rabbitmq.com/tutorials/tutorial-one-php.html Hello World!简单使用安装直接使用composer加载1composer require php-amqplib/php-amqplib send发送在send.php中包含库并使用：1234require_once __DIR__ . '/vendor/autoload.php';use PhpAmqpLib\\Connection\\AMQPStreamConnection;use PhpAmqpLib\\Message\\AMQPMessage; 创建到服务器的连接：12$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');$channel = $connection-&gt;channel(); 要发送，我们必须声明一个队列供我们发送; 然后我们可以向队列发布消息：1234$channel-&gt;queue_declare('hello', false, false, false, false);$msg = new AMQPMessage('Hello World!');$channel-&gt;basic_publish($msg, '', 'hello');echo \" [x] Sent 'Hello World!'\\n\"; 声明队列是幂等的 - 只有在它不存在的情况下才会创建它。 关闭了频道和连接:12$channel-&gt;close();$connection-&gt;close(); php send.php执行失败，可能是未安装php的bcmath扩展，可以用过phpize动态编译安装 receive接收receive.php 设置与send生产者相同; 我们打开一个连接和一个通道，并声明我们将要消耗的队列。请注意，这与发送的队列匹配。12345678require_once __DIR__ . '/vendor/autoload.php';use PhpAmqpLib\\Connection\\AMQPStreamConnection;$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');$channel = $connection-&gt;channel();$channel-&gt;queue_declare('hello', false, false, false, false);echo \" [*] Waiting for messages. To exit press CTRL+C\\n\"; 定义一个PHP callable，它将接收服务器发送的消息。请记住，消息是从服务器异步发送到客户端的。1234567$callback = function ($msg) &#123; echo ' [x] Received ', $msg-&gt;body, \"\\n\";&#125;;$channel-&gt;basic_consume('hello', '', false, true, false, false, $callback);while (count($channel-&gt;callbacks)) &#123; $channel-&gt;wait();&#125; 这里通过while保证进程常驻 列出队列1rabbitmqctl list_queues 完整代码：send.php 、 receive.php 。测试结果如图： hello world Work queues工作队列这里将创建一个工作队列，用于在多个工作人员之间分配耗时的任务。 准备这里将通过sleep()函数，模拟耗时任务。通过字符串中.点的个数作为其复杂性。 稍微修改前一个示例中的send.php代码，以允许从命令行发送任意消息。重命名为new_task.php：123456789$data = implode(' ', array_slice($argv, 1));if (empty($data)) &#123; $data = \"Hello World!\";&#125;$msg = new AMQPMessage($data);$channel-&gt;basic_publish($msg, '', 'hello');echo ' [x] Sent ', $data, \"\\n\"; 旧的receive.php脚本还需要进行一些更改：它需要为消息体中的每个点伪造一秒钟的工作。它将从队列中弹出消息并执行任务，所以我们称之为worker.php：1234567$callback = function ($msg) &#123; echo ' [x] Received ', $msg-&gt;body, \"\\n\"; sleep(substr_count($msg-&gt;body, '.')); echo \" [x] Done\\n\";&#125;;$channel-&gt;basic_consume('hello', '', false, true, false, false, $callback); 循环调度使用任务队列的一个优点是能够轻松地并行工作。如果我们正在积压工作积压，我们可以添加更多工人，这样就可以轻松扩展。 打开四个控制台。三个将运行worker.php 脚本。测试结果如图： worker 默认情况下，RabbitMQ将按顺序将每条消息发送给下一个消费者。平均而言，每个消费者将获得相同数量的消息。这种分发消息的方式称为循环法。 消息确认执行任务可能需要几秒钟。您可能想知道如果其中一个消费者开始执行长任务并且仅在部分完成时死亡会发生什么。使用我们当前的代码，一旦RabbitMQ向客户发送消息，它立即将其标记为删除。在这种情况下，如果你杀死一个工人，我们将丢失它刚刚处理的消息。我们还将丢失分发给这个特定工作者但尚未处理的所有消息。 为了确保消息永不丢失，RabbitMQ支持 消息确认。消费者发回ack（nowledgement）告诉RabbitMQ已收到，处理了特定消息，RabbitMQ可以自由删除它。 如果消费者死亡（其通道关闭，连接关闭或TCP连接丢失）而不发送确认，RabbitMQ将理解消息未完全处理并将重新排队。如果其他消费者同时在线，则会迅速将其重新发送给其他消费者。 默认情况下，消息确认已关闭。现在是时候通过设置第四个参数来打开它们basic_consume到false（true表示没有ACK）12345678$callback = function ($msg) &#123; echo ' [x] Received ', $msg-&gt;body, \"\\n\"; sleep(substr_count($msg-&gt;body, '.')); echo \" [x] Done\\n\"; $msg-&gt;delivery_info['channel']-&gt;basic_ack($msg-&gt;delivery_info['delivery_tag']);&#125;;$channel-&gt;basic_consume('task_queue', '', false, false, false, false, $callback); 被遗忘的ack错过ack是一个常见的错误。这是一个简单的错误，但后果是严重的。当您的客户端退出时，消息将被重新传递（这可能看起来像随机重新传递），但RabbitMQ将会占用越来越多的内存，因为它无法释放任何未经处理的消息。 可以使用rabbitmqctl 来打印messages_unacknowledged字段：12&gt; sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged&gt; 消息持久性消息确认确保即使消费者死亡，任务也不会丢失。但是如果RabbitMQ服务器停止，我们的任务仍然会丢失。 当RabbitMQ退出或崩溃时，它将忘记队列和消息，除非你告诉它不要。确保消息不会丢失需要做两件事：我们需要将队列和消息都标记为持久。 首先，我们需要确保RabbitMQ永远不会丢失我们的队列。为此，我们需要声明它是持久的。为此，我们将第三个参数传递给queue_declare为true:1$ channel-&gt;queue_declare（'hello'，false，true，false，false）; 虽然此命令本身是正确的，但它在我们当前的设置中不起作用。那是因为我们已经定义了一个名为hello的队列 ，这个队列不耐用。RabbitMQ不允许您使用不同的参数重新定义现有队列，并将向尝试执行此操作的任何程序返回错误。但是有一个快速的解决方法 - 让我们声明一个具有不同名称的队列，例如task_queue：1$channel-&gt;queue_declare('task_queue', false, true, false, false); 此标志设置为true需要应用于生产者和消费者代码。 此时我们确信即使RabbitMQ重新启动，task_queue队列也不会丢失。现在我们需要将消息标记为持久性 - 通过设置delivery_mode = 2消息属性，AMQPMessage将其作为属性数组的一部分。1234$msg = new AMQPMessage( $data, array('delivery_mode' =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT)); 公平派遣您可能已经注意到调度仍然无法完全按照我们的意愿运行。例如，在有两个工人的情况下，当所有奇怪的消息都很重，甚至消息很轻时，一个工人将经常忙碌而另一个工作人员几乎不会做任何工作。好吧，RabbitMQ对此一无所知，仍然会均匀地发送消息。 发生这种情况是因为RabbitMQ只是在消息进入队列时调度消息。它不会查看消费者未确认消息的数量。它只是盲目地向第n个消费者发送每个第n个消息。 我们可以使用basic_qos方法和prefetch_count = 1设置。这告诉RabbitMQ不要一次向一个worker发送一条消息。或者，换句话说，在处理并确认前一个消息之前，不要向worker发送新消息。相反，它会将它发送给下一个仍然不忙的worker。1$channel-&gt;basic_qos(null, 1, null); 完整代码：new_task.php，worker.php 测试结果如图： 公平差遣 Publish/Subscribe（发布/订阅）工作队列背后的假设是每个任务都交付给一个工作者。在这一部分，我们将做一些完全不同的事情 - 我们将向多个消费者传递信息。此模式称为“发布/订阅”。 交换器前面教程中的内容： 生产者是发送消息的用户的应用程序 队列是存储消息的缓冲器 消费者是接收消息的用户的应用程序 RabbitMQ中消息传递模型的核心思想是生产者永远不会将任何消息直接发送到队列。实际上，生产者通常甚至不知道消息是否会被传递到任何队列。 相反，生产者只能向交换器发送消息。交换是一件非常简单的事情。一方面，它接收来自生产者的消息，另一方面将它们推送到队列。交换器必须确切知道如何处理收到的消息。它应该附加到特定队列吗？它应该附加到许多队列吗？或者它应该被丢弃。其规则由交换类型定义。 交换器 有几种交换类型可供选择：direct（直接），topic（主题），headers（标题）和fanout（扇出）。我们将专注于最后一个 - fanout扇出。让我们创建一个这种类型的交换，并将其称为日志：1$channel-&gt;exchange_declare('logs', 'fanout', false, false, false); 列出清单12&gt; rabbitmqctl list_exchanges&gt; 在此列表中将有一些amq.*交换和默认（未命名）交换。这些是默认创建的。 默认交换之前能发送消息，是因为我们使用的默认交换，通过空字符串&quot;&quot;来识别 之前是这样发送消息的：12&gt; $channel-&gt;basic_publish($msg, '', 'hello');&gt; 这里我们使用默认或无名交换：消息被路由到具有routing_key指定的名称的队列（如果存在）。路由键是basic_publish的第三个参数 临时队列能够命名队列对我们来说至关重要 - 我们需要将工作人员指向同一个队列。当您想要在生产者和消费者之间共享队列时，为队列命名很重要。 但我们的记录器并非如此。我们希望了解所有日志消息，而不仅仅是它们的一部分。我们也只对目前流动的消息感兴趣，而不是旧消息。要解决这个问题，我们需要两件事。 首先，每当我们连接到Rabbit时，我们都需要一个新的空队列。为此，我们可以使用随机名称创建队列，或者更好 - 让服务器为我们选择随机队列名称。 其次，一旦我们断开消费者，就应该自动删除队列。 在php-amqplib客户端中，当我们将队列名称作为空字符串提供时，我们使用生成的名称创建一个非持久队列：1list($queue_name, ,) = $channel-&gt;queue_declare(\"\"); 方法返回时，$queue_name变量包含RabbitMQ生成的随机队列名称。例如，它可能看起来像amq.gen-JzTY20BRgKO-HjmUJj0wLg。 当声明它的连接关闭时，队列将被删除，因为它被声明为独占。 绑定 绑定 我们已经创建了一个扇出交换和一个队列。现在我们需要告诉交换机将消息发送到我们的队列。交换和队列之间的关系称为绑定。1$channel-&gt;queue_bind($queue_name, 'logs'); 列出绑定12&gt; rabbitmqctl list_bindings&gt; 生成日志消息的生产者程序与前一个教程没有太大的不同。最重要的变化是我们现在想要将消息发布到我们的日志交换而不是无名交换。这里是emit_log.php脚本的代码 ：12345678910111213141516171819202122&lt;?phprequire_once __DIR__ . '/vendor/autoload.php';use PhpAmqpLib\\Connection\\AMQPStreamConnection;use PhpAmqpLib\\Message\\AMQPMessage;$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');$channel = $connection-&gt;channel();$channel-&gt;exchange_declare('logs', 'fanout', false, false, false);$data = implode(' ', array_slice($argv, 1));if (empty($data)) &#123; $data = \"info: Hello World!\";&#125;$msg = new AMQPMessage($data);$channel-&gt;basic_publish($msg, 'logs');echo ' [x] Sent ', $data, \"\\n\";$channel-&gt;close();$connection-&gt;close(); 在建立连接后我们宣布了交换。此步骤是必要的，因为禁止发布到不存在的交换 receive_logs.php的代码：123456789101112131415161718&lt;?phprequire_once __DIR__ . '/vendor/autoload.php';use PhpAmqpLib\\Connection\\AMQPStreamConnection;$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');$channel = $connection-&gt;channel();$channel-&gt;exchange_declare('logs', 'fanout', false, false, false);list($queue_name, ,) = $channel-&gt;queue_declare(\"\", false, false, true, false);$channel-&gt;queue_bind($queue_name, 'logs');echo \" [*] Waiting for logs. To exit press CTRL+C\\n\";$callback = function ($msg) &#123; echo ' [x] ', $msg-&gt;body, \"\\n\";&#125;;$channel-&gt;basic_consume($queue_name, '', false, true, false, false, $callback);while (count($channel-&gt;callbacks)) &#123; $channel-&gt;wait();&#125;$channel-&gt;close();$connection-&gt;close(); Routing路由这里我们将为其添加一个功能 - 我们将只能订阅一部分消息。例如，我们只能将关键错误消息定向到日志文件（以节省磁盘空间），同时仍然能够在控制台上打印所有日志消息。 绑定之前绑定流程：1$channel-&gt;queue_bind($queue_name, 'logs'); 绑定是交换和队列之间的关系。这可以简单地理解为：队列对来自此交换的消息感兴趣。 绑定可以采用额外的routing_key参数。为了避免与$ channel::basic_publish参数混淆，我们将其称为绑定密钥。这就是我们如何使用键创建绑定：12$binding_key = 'black';$channel-&gt;queue_bind($queue_name, $exchange_name, $binding_key); 绑定密钥的含义取决于交换类型。我们之前使用的扇出交换只是忽略了它的价值。 直接交换我们上一个教程中的日志记录系统向所有消费者广播所有消息。我们希望扩展它以允许根据消息的严重性过滤消息。例如，我们可能希望将日志消息写入磁盘的脚本仅接收严重错误，而不是在警告或信息日志消息上浪费磁盘空间。 我们使用的是扇出交换，它没有给我们太大的灵活性 - 它只能进行无意识的广播。 我们将使用直接交换。直接交换背后的路由算法很简单 - 消息进入队列，其绑定密钥与消息的路由密钥完全匹配。 直接交换 在此设置中，我们可以看到直接交换X与两个绑定到它的队列。第一个队列绑定橙色绑定，第二个绑定有两个绑定，一个绑定密钥为黑色，另一个绑定为绿色。 在这样的设置中，使用路由密钥orange发布到交换机的消息 将被路由到队列Q1。路由键为黑色 或绿色的消息将转到Q2。所有其他消息将被丢弃。 多个绑定 多个绑定 使用相同的绑定密钥绑定多个队列是完全合法的。在我们的例子中，我们可以在X和Q1之间添加绑定键黑色的绑定。在这种情况下，直接交换将表现得像扇出一样，并将消息广播到所有匹配的队列。路由密钥为黑色的消息将传送到 Q1和Q2。 发送日志我们将此模型用于我们的日志系统。我们会将消息发送给直接交换，而不是扇出。我们将提供日志严重性作为路由密钥。这样接收脚本将能够选择它想要接收的严重性。让我们首先关注发送日志。 一如既往，我们需要先创建一个交换：1$channel-&gt;exchange_declare('direct_logs', 'direct', false, false, false); 我们已准备好发送消息：12$channel-&gt;exchange_declare('direct_logs', 'direct', false, false, false);$channel-&gt;basic_publish($msg, 'direct_logs', $severity); 订阅接收消息将像上一个教程一样工作，但有一个例外 - 我们将为我们感兴趣的每个严重性创建一个新的绑定。123foreach ($severities as $severity) &#123; $channel-&gt;queue_bind($queue_name, 'direct_logs', $severity);&#125; 完整代码 直接交换多个绑定 emit_log_direct.php类的代码：12345678910111213141516171819&lt;?phprequire_once __DIR__ . '/vendor/autoload.php';use PhpAmqpLib\\Connection\\AMQPStreamConnection;use PhpAmqpLib\\Message\\AMQPMessage;$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');$channel = $connection-&gt;channel();$channel-&gt;exchange_declare('direct_logs', 'direct', false, false, false);$severity = isset($argv[1]) &amp;&amp; !empty($argv[1]) ? $argv[1] : 'info';$data = implode(' ', array_slice($argv, 2));if (empty($data)) &#123; $data = \"Hello World!\";&#125;$msg = new AMQPMessage($data);$channel-&gt;basic_publish($msg, 'direct_logs', $severity);echo ' [x] Sent ', $severity, ':', $data, \"\\n\";$channel-&gt;close();$connection-&gt;close(); receive_logs_direct.php的代码：123456789101112131415161718192021222324252627&lt;?phprequire_once __DIR__ . '/vendor/autoload.php';use PhpAmqpLib\\Connection\\AMQPStreamConnection;$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');$channel = $connection-&gt;channel();$channel-&gt;exchange_declare('direct_logs', 'direct', false, false, false);list($queue_name, ,) = $channel-&gt;queue_declare(\"\", false, false, true, false);$severities = array_slice($argv, 1);if (empty($severities)) &#123; echo '缺少安全级别参数', \"\\n\"; exit(1);&#125;foreach ($severities as $severity) &#123; $channel-&gt;queue_bind($queue_name, 'direct_logs', $severity);&#125;echo \" [*] Waiting for logs. To exit press CTRL+C\\n\";$callback = function ($msg) &#123; echo ' [x] ', $msg-&gt;delivery_info['routing_key'], ':', $msg-&gt;body, \"\\n\";&#125;;$channel-&gt;basic_consume($queue_name, '', false, true, false, false, $callback);while (count($channel-&gt;callbacks)) &#123; $channel-&gt;wait();&#125;$channel-&gt;close();$connection-&gt;close(); 测试结果如图： 直接绑定测试结果 Topics主题虽然使用直接交换改进了我们的系统，但它仍然有局限性 - 它不能基于多个标准进行路由。 我们需要了解更复杂的主题交换。 主题交换发送到主题交换的消息不能具有任意 routing_key - 它必须是由点分隔的单词列表。单词可以是任何内容，但通常它们指定与消息相关的一些功能。一些有效的路由密钥示例：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”。路由密钥中可以包含任意数量的单词，最多可达255个字节。 绑定密钥也必须采用相同的形式。主题交换背后的逻辑 类似于直接交换- 使用特定路由密钥发送的消息将被传递到与匹配绑定密钥绑定的所有队列。但是，绑定键有两个重要的特殊情况： *（星号）可以替代一个单词。 #（hash）可以替换零个或多个单词。 在一个例子中解释这个是最容易的： 主题交换 我们创建了三个绑定：Q1绑定了绑定键” .orange.“, Q2 绑定了”..rabbit”和”lazy.#”。 这些绑定可以概括为： Q1对所有橙色动物感兴趣。 Q2希望听到关于兔子的一切，以及关于懒惰动物的一切。 路由密钥设置为”quick.orange.rabbit”的消息将传递到两个队列。消息”lazy.orange.elephant”也将同时发送给他们。另一方面，”quick.orange.fox”只会进入第一个队列，而”lazy.brown.fox”只会进入第二个队列。“lazy.pink.rabbit”将仅传递到第二个队列一次，即使它匹配两个绑定。“quick.brown.fox”与任何绑定都不匹配，因此它将被丢弃。 如果我们违反规则并发送带有一个或四个单词的消息，例如”orange”或”quick.orange.male.rabbit”，会发生什么？好吧，这些消息将不匹配任何绑定，将丢失。 另一方面，”lazy.orange.male.rabbit”，即使它有四个单词，也会匹配最后一个绑定，并将被传递到第二个队列。 主题交换主题交换功能强大，可以像其他交换器一样。 当队列与”#”（哈希）绑定密钥绑定时 - 它将接收所有消息，而不管路由密钥 - 如扇出交换。 当特殊字符”*”（星号）和”#”（哈希）未在绑定中使用时，主题交换的行为就像直接交换一样。 完整代码emit_log_topic.php的代码：12345678910111213141516171819&lt;?phprequire_once __DIR__ . '/vendor/autoload.php';use PhpAmqpLib\\Connection\\AMQPStreamConnection;use PhpAmqpLib\\Message\\AMQPMessage;$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');$channel = $connection-&gt;channel();$channel-&gt;exchange_declare('topic_logs', 'topic', false, false, false);$routing_key = isset($argv[1]) &amp;&amp; !empty($argv[1]) ? $argv[1] : 'anonymous.info';$data = implode(' ', array_slice($argv, 2));if (empty($data)) &#123; $data = \"Hello World!\";&#125;$msg = new AMQPMessage($data);$channel-&gt;basic_publish($msg, 'topic_logs', $routing_key);echo ' [x] Sent ', $routing_key, ':', $data, \"\\n\";$channel-&gt;close();$connection-&gt;close(); receive_logs_topic.php的代码：123456789101112131415161718192021222324252627&lt;?phprequire_once __DIR__ . '/vendor/autoload.php';use PhpAmqpLib\\Connection\\AMQPStreamConnection;$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');$channel = $connection-&gt;channel();$channel-&gt;exchange_declare('topic_logs', 'topic', false, false, false);list($queue_name, ,) = $channel-&gt;queue_declare(\"\", false, false, true, false);$binding_keys = array_slice($argv, 1);if (empty($binding_keys)) &#123; echo '缺少安全级别参数', \"\\n\"; exit(1);&#125;foreach ($binding_keys as $binding_key) &#123; $channel-&gt;queue_bind($queue_name, 'topic_logs', $binding_key);&#125;echo \" [*] Waiting for logs. To exit press CTRL+C\\n\";$callback = function ($msg) &#123; echo ' [x] ', $msg-&gt;delivery_info['routing_key'], ':', $msg-&gt;body, \"\\n\";&#125;;$channel-&gt;basic_consume($queue_name, '', false, true, false, false, $callback);while (count($channel-&gt;callbacks)) &#123; $channel-&gt;wait();&#125;$channel-&gt;close();$connection-&gt;close(); 测试结果如图： 主题交换测试 rpc远程过程调用目前接触不多，而且问题会比较多，暂不赘述 了解链接：http://www.rabbitmq.com/tutorials/tutorial-six-php.html","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"RabbitMq","slug":"RabbitMq","permalink":"https://pengwenwu.github.io/tags/RabbitMq/"},{"name":"php","slug":"php","permalink":"https://pengwenwu.github.io/tags/php/"}]},{"title":"centos7安装RabbitMq服务端","slug":"centos7安装RabbitMq服务端","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2018/09/03/centos7安装RabbitMq服务端/","link":"","permalink":"https://pengwenwu.github.io/2018/09/03/centos7安装RabbitMq服务端/","excerpt":"","text":"安装erlanggithub地址：https://github.com/rabbitmq/erlang-rpm 选择不同的版本 添加仓库比如在CentOS 7上使用Erlang 21.x：123456789vim /etc/yum.repos.d/rabbitmq-erlang.repo[rabbitmq-erlang]name = rabbitmq-erlangbaseurl = https://dl.bintray.com/rabbitmq/rpm/erlang/21/el/7gpgcheck = 1gpgkey = https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.ascrepo_gpgcheck = 0enabled = 1 yum安装1yum install erlang -y 安装RabbitMq官网下载地址：http://www.rabbitmq.com/download.html 选择合适的版本，这里以centos为例：123wget https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.7/rabbitmq-server-3.7.7-1.el7.noarch.rpmyum install rabbitmq-server-3.7.7-1.el7.noarch.rpm rpm查看安装目录 rpm查看安装包 1rpm -qa | grep rabbitmq rpm查看安装路径 这里是小写l，加上刚刚查出的安装包名 1rpm -ql rabbitmq-server-3.7.7-1.el7.noarch 启动rabbitmq-server123456#将rabbitmq-server加入到开机自启动服务systemctl enable rabbitmq-server.servicechkconfig rabbitmq-server on#启动service rabbitmq-server start 查看rabbitmq运行状态1systemctl status rabbitmq-server 查看rabbitmq状态1rabbitmqctl status 查看rabbitmq默认配置1rabbitmqctl environment 开启web监控运行rabbitmq-server后，如果出现completed with 0 plugins.，则说明未开启监控。 此时需要执行命令: rabbitmq-plugins enable rabbitmq_management再次运行rabbitmq-server 123456789service rabbitmq-server start #启动service rabbitmq-server stop #停止service rabbitmq-server restart #重启service rabbitmq-server status #查看状态service rabbitmq-server etc #查看有哪些命令可以使用","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"RabbitMq","slug":"RabbitMq","permalink":"https://pengwenwu.github.io/tags/RabbitMq/"}]},{"title":"centos7编译安装php7和nginx","slug":"centos7编译安装php7和nginx","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/07/22/centos7编译安装php7和nginx/","link":"","permalink":"https://pengwenwu.github.io/2018/07/22/centos7编译安装php7和nginx/","excerpt":"","text":"删除yum安装过的php相关模块1yum remove php* 依赖安装123456789yum -y install gcc automake autoconf libtool makeyum -y install gcc gcc-c++ glibcyum -y install libmcrypt-devel mhash-devel libxslt-devel \\libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel \\zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel \\ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel \\krb5 krb5-devel libidn libidn-devel openssl openssl-devel 编译安装1234567891011121314151617181920212223242526272829303132333435363738wget http://cn2.php.net/distributions/php-7.2.8.tar.gztar zvxf php-7.2.8.tar.gzcd php-7.2.8./configure --prefix=/usr/local/php7 \\--with-config-file-path=/usr/local/php7/etc \\--with-config-file-scan-dir=/usr/local/php7/etc/php.d \\--enable-mysqlnd \\--with-mysqli \\--with-pdo-mysql \\--enable-fpm \\--with-fpm-user=nginx \\--with-fpm-group=nginx \\--with-gd \\--with-iconv \\--with-zlib \\--enable-xml \\--enable-shmop \\--enable-sysvsem \\--enable-inline-optimization \\--enable-mbregex \\--enable-mbstring \\--enable-ftp \\--with-openssl \\--enable-pcntl \\--enable-sockets \\--with-xmlrpc \\--enable-zip \\--enable-soap \\--without-pear \\--with-gettext \\--enable-session \\--with-curl \\--with-jpeg-dir \\--with-freetype-dir \\--enable-opcachemake &amp;&amp; install 配置php添加php安装目录到系统环境变量12345vim /etc/profile.d/php.shexport PATH=$PATH:/usr/local/php/bin/:/usr/local/php/sbin/source /etc/profile.d/php.sh 添加php配置文件1cp php.ini-production /usr/local/php/etc/php.ini 修改服务器所在时区123vim /usr/local/php/etc/php.inidate.timezone = PRC 添加 php-fpm 配置文件123cd /usr/local/php/etccp php-fpm.conf.default php-fpm.conf 添加 php-fpm 管理相关的配置文件到系统配置目录 /etc/init.d12# /usr/local/php-7.2.8cp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm 添加 www.conf 配置文件12# /usr/local/phpcp etc/php-fpm.d/www.conf.default etc/php-fpm.d/www.conf 设置PHP日志目录和php-fpm运行进程的ID文件目录php-fpm运行进程的ID文件也就是 php-fpm.pid 设置php-fpm进程目录的用户和用户组为nginx -r: 添加系统用户( 这里指将要被创建的系统用户nginx )-g: 指定要创建的用户所属组( 这里指添加到新系统用户nginx到nginx系统用户组 )-s: 新帐户的登录shell( /sbin/nologin 这里设置为将要被创建系统用户nginx不能用来登录系统 )-d: 新帐户的主目录( 这里指定将要被创建的系统用户nginx的家目录为 /usr/local/nginx )-M: 不要创建用户的主目录( 也就是说将要被创建的系统用户nginx不会在 /home 目录下创建 nginx 家目录 ) 1234567891011121314# 添加系统用户组nginxgroupadd -r nginx# 创建新的系统用户nginx, 并添加到系统用户组nginx, 设置不允许此用户名登录shell (如果你没有创建过系统用户nginx请创建)useradd -r -g nginx -s /sbin/nologin -d /usr/local/nginx -M nginx# 创建 `php-fpm` 日志目录mkdir -p /var/log/php-fpm/# 创建 `php-fpm` 进程的ID(php-fpm.pid)文件运行目录mkdir -p /var/run/php-fpm# 修改 `php-fpm` 进程的ID(php-fpm.pid)文件运行目录的所属用户和组chown -R nginx:nginx /var/run/php-fpm/ 设置php开机启动12345678# 修改系统配置目录下的 `php-fpm` 文件可执行权限chmod +x /etc/init.d/php-fpm# 将系统配置目录下的 `php-fpm` 添加到 `系统服务`chkconfig --add php-fpm# 设置 `php-fpm` `系统服务` 为开机启动chkconfig php-fpm on 检测 php-fpm 系统服务是否启动成功用 chkconfig 命令检测一下服务是否运行成功12345678910111213141516chkconfig --list | grep php-fpmNote: This output shows SysV services only and does not include native systemd services. SysV configuration data might be overridden by native systemd configuration. If you want to list systemd services use 'systemctl list-unit-files'. To see services enabled on particular target use 'systemctl list-dependencies [target]'.php-fpm 0:off 1:off 2:on 3:on 4:on 5:on 6:off# 可见服务已经在 第2 到 第5 运行等级打开# 禁用 `php-fpm` 开机启动chkconfig php-fpm off 测试PHP的配置文件是否无误12345php-fpm -t[22-Jul-2018 11:13:23] NOTICE: configuration file /usr/local/php/etc/php-fpm.conf test is successful# 出现上面的提示也就是测试配置文件通过没有问题, 可以正式使用php服务了 启动php系统服务使用 systemctl start + 服务名 启动系统服务1systemctl start php-fpm.service 查看php系统服务状态使用 systemctl status + 服务名 查看系统服务状态1234567891011121314151617systemctl status php-fpm.service● php-fpm.service - LSB: starts php-fpm Loaded: loaded (/etc/rc.d/init.d/php-fpm; bad; vendor preset: disabled) Active: active (running) since Sun 2018-07-22 11:15:47 UTC; 29s ago Docs: man:systemd-sysv-generator(8) Process: 13309 ExecStart=/etc/rc.d/init.d/php-fpm start (code=exited, status=0/SUCCESS) Tasks: 3 Memory: 3.2M CGroup: /system.slice/php-fpm.service ├─13311 php-fpm: master process (/usr/local/php/etc/php-fpm.conf) ├─13312 php-fpm: pool www └─13313 php-fpm: pool wwwJul 22 11:15:47 localhost.localdomain systemd[1]: Starting LSB: starts php-fpm...Jul 22 11:15:47 localhost.localdomain systemd[1]: Started LSB: starts php-fpm.Jul 22 11:15:47 localhost.localdomain php-fpm[13309]: Starting php-fpm done 安装nginx123456789101112131415cd /usr/local/src# 依赖安装yum install -y pcre pcre-develyum install -y openssl openssl-devel# 下载wget https://nginx.org/download/nginx-1.14.0.tar.gztar -zxvf nginx-1.14.0.tar.gzcd nginx-1.14.0/# 编译./configure --prefix=/usr/local/nginx --sbin-path=/usr/local/nginx/nginx --conf-path=/usr/local/nginx/nginx.conf --pid-path=/usr/local/nginx/nginx.pid --with-http_ssl_module --with-http_realip_module --with-http_sub_module --with-http_gzip_static_module --with-http_stub_status_module --with-pcre --with-cc-opt=\"-Wno-deprecated-declarations\"make &amp;&amp; make install 配置环境变量123echo 'export PATH=$PATH:/usr/local/nginx/nginx' &gt; /etc/profile.d/nginx.shcp /usr/local/nginx/nginx /usr/bin 常用nginx命令 启动 nginx nginx -s stop nginx -s quit nginx -s reload nginx -s quit:此方式停止步骤是待nginx进程处理任务完毕进行停止 nginx -s stop:此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程 开机启动1vim /etc/init.d/nginx 粘贴以下命令并修改以下目录：12nginx=\"/usr/local/nginx/nginx\" NGINX_CONF_FILE=\"/usr/local/nginx/nginx.conf\" 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#!/bin/sh## nginx - this script starts and stops the nginx daemin## chkconfig: - 85 15 # description: Nginx is an HTTP(S) server, HTTP(S) reverse \\# proxy and IMAP/POP3 proxy server# processname: nginx# config: /etc/nginx/nginx.conf# pidfile: /run/nginx/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ \"$NETWORKING\" = \"no\" ] &amp;&amp; exit 0nginx=\"/usr/sbin/nginx\"prog=$(basename $nginx)NGINX_CONF_FILE=\"/etc/nginx/nginx.conf\"lockfile=/var/lock/nginx.lockstart() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 echo -n $\"Starting $prog: \" daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $\"Stopping $prog: \" killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125;restart() &#123; configtest || return $? stop start&#125;reload() &#123; configtest || return $? echo -n $\"Reloading $prog: \" killproc $nginx -HUP RETVAL=$? echo&#125;force_reload() &#123; restart&#125;configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125;rh_status() &#123; status $prog&#125;rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125;case \"$1\" in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $\"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;\" exit 2esacexit $RETVAL 添加到服务 12chmod a+x /etc/init.d/nginxchkconfig --add nginx 使用 1234service nginx start service nginx stop service nginx restart service nginx reload","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://pengwenwu.github.io/tags/Linux/"},{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"nginx","slug":"nginx","permalink":"https://pengwenwu.github.io/tags/nginx/"}]},{"title":"php的几种运行模式CLI、CGI、FastCGI、mod_php","slug":"php的几种运行模式CLI、CGI、FastCGI、mod-php","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2018/07/22/php的几种运行模式CLI、CGI、FastCGI、mod-php/","link":"","permalink":"https://pengwenwu.github.io/2018/07/22/php的几种运行模式CLI、CGI、FastCGI、mod-php/","excerpt":"","text":"常用运行模式CLICLI：命令行，可以在控制台或者shell中输入命令获取输出，没有header头信息 CGI公共网关接口（Common Gateway Interface/CGI）：是一种重要的互联网技术，可以让一个客户端，从网页浏览器向执行在网络服务器上的程序请求数据。CGI描述了服务器和请求处理程序之间传输数据的一种标准。即web server将用户请求以消息的方式转交给PHP独立进程,PHP与web服务之间无从属关系。 FastCGI快速通用网关接口（Fast Common Gateway Interface／FastCGI）：是一种让交互程序与Web服务器通信的协议。FastCGI是早期通用网关接口（CGI）的增强版本。 CGI 和 FastCGI 是一种通信协议规范，不是一个实体 CGI 程序和FastCGI程序，是指实现这两个协议的程序，可以是任何语言实现这个协议的。（PHP-CGI 和 PHP-FPM就是实现FastCGI的程序） FastCGI和CGI的区别 CGI每接收一个请求就要fork一个进程处理，只能接收一个请求作出一个响应。请求结束后该进程就会结束。 FastCGI会事先启动起来，作为一个cgi的管理服务器存在，预先启动一系列的子进程来等待处理，然后等待web服务器发过来的请求，一旦接受到请求就交由子进程处理，这样由于不需要在接受到请求后启动cgi，会快很多。 FastCGI使用进程/线程池来处理一连串的请求。这些进程/线程由FastCGI服务器管理，而不是Web服务器。 当进来一个请求时，Web服务器把环境变量和这个页面请求通过一个Socket长连接传递给FastCGI进程。FastCGI像是一个常驻型的CGI，它可以一直执行，在请求到达时不会花费时间去fork一个进程来处理(这是CGI对位人诟病的fork-and-execute模式)。正是因为它只是一个通信协议，它还支持分布式的运算，即FastCGI程序可以在网站服务器以外的主机上执行并且接受来自其他网站服务器的请求。 FastCGI整个流程 Web server启动时载入FastCGI进程管理器 FastCGI自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web server的请求 当请求Web server时，Web server通过socket请求FastCGI进程管理器，FastCGI进程管理器选择并连接到一个CGI解释器，Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi FastCGI子进程处理请求完成后将标准输出和错误从同一连接返回给Web server，当FastCGI子进程结束后请求便结束。FastCGI子进程接着等待处理来自FastCGI进程管理器的下一个连接，在CGI模式中，php-cgi在此便退出了。 PHP-FPM：PHP的FastCGI进程管理器 PHP-CGI 和 PHP-FPM的区别php-cgi与php-fpm一样，也是一个fastcgi进程管理器 php-cgi的问题在于： php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启 直接杀死php-cgi进程,php就不能运行了。 PHP-FPM和Spawn-FCGI就没有这个问题，守护进程会平滑从新生成新的子进程。针对php-cgi的不足，php-fpm应运而生。 PHP-FPM 的管理对象是php-cgi。使用PHP-FPM来控制PHP-CGI的FastCGI进程 mod_php（传统模式）即apache的php模块，将PHP做为web-server的子进程控制,两者之间有从属关系。 最明显的例子就是在CGI模式下,如果修改了PHP.INI的配置文件,不用重启web服务便可生效，而模块模式下则需要重启web服务。 以mod_php模式运行PHP，意味着php是作为apache的一个模块来启动的，因此只有在apache启动的时候会读取php.ini配置文件并加载扩展模块，在apache运行期间是不会再去读取和加载扩展模块的。如果修改php的配置，需要重启apache服务 Apache的工作模式 prefork的工作原理一个单独的控制进程(父进程)负责产生子进程，这些子进程用于监听请求并作出应答。 Apache总是试图保持一些备用的 (spare)或是空闲的子进程用于迎接即将到来的请求。这样客户端就无需在得到服务前等候子进程的产生。 在Unix系统中，父进程通常以root身份运行以便邦定80端口，而 Apache产生的子进程通常以一个低特权的用户运行。User和Group指令用于配置子进程的低特权用户。运行子进程的用户必须要对他所服务的内容有读取的权限，但是对服务内容之外的其他资源必须拥有尽可能少的权限。 Apache的工作模式 worker的工作原理每个进程能够拥有的线程数量是固定的。服务器会根据负载情况增加或减少进程数量。 一个单独的控制进程(父进程)负责子进程的建立。每个子进程能够建立ThreadsPerChild数量的服务线程和一个监听线程，该监听线程监听接入请求并将其传递给服务线程处理和应答。 nginx默认是使用的fastcgi模式，可以配合fpm使用","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"}]},{"title":"vagrant常用命令.md","slug":"vagrant常用命令","date":"un66fin66","updated":"un11fin11","comments":true,"path":"2018/07/21/vagrant常用命令/","link":"","permalink":"https://pengwenwu.github.io/2018/07/21/vagrant常用命令/","excerpt":"","text":"Vagrant常用命令在安装配置中，使用了一些基础命令 vagrant box add：添加box vagrant init：初始化 vagrant up：启动虚拟机 vagrant ssh：登录虚拟机 vagrant reload：重新启动虚拟机 Vagrant还包括如下一些操作： vagrant box list 显示当前已经添加的box列表 12$ vagrant box listbase (virtualbox) vagrant box remove 删除相应的box 1vagrant box remove base virtualbox vagrant destroy 停止当前正在运行的虚拟机并销毁所有创建的资源 vagrant halt 关机 vagrant package 打包命令，可以把当前的运行的虚拟机环境进行打包 vagrant resume 恢复前面被挂起的状态 vagrant ssh-config 输出用于ssh连接的一些信息 vagrant status 获取当前虚拟机的状态 vagrant suspend 挂起当前的虚拟机 参考链接：https://github.com/astaxie/go-best-practice/blob/master/ebook/zh/01.3.md","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"vagrant","slug":"vagrant","permalink":"https://pengwenwu.github.io/tags/vagrant/"}]},{"title":"vagrant安装配置.md","slug":"vagrant安装配置","date":"un66fin66","updated":"un11fin11","comments":true,"path":"2018/07/21/vagrant安装配置/","link":"","permalink":"https://pengwenwu.github.io/2018/07/21/vagrant安装配置/","excerpt":"","text":"准备自行下载Vagrant、VirtualBox安装 vagrant官网地址：https://www.vagrantup.com/ box下载：https://app.vagrantup.com/boxes/search Vagrant配置下载boxbox提供一个操作系统环境，可以自行下载想用的基础环境，比如Ubuntu、centos、debian等 添加box1vagrant box add base 远端的box地址或者本地的box文件名 base可以是box的自定义名称，用来标识添加的box，默认是base 可以通过vagrant list查看刚刚添加的box 初始化1vagrant init Box名称 如果没有指定名称为base，则需要指定初始化的Box名称。此时将会在目录下生成一个Vagrantfile文件 启动虚拟机1vagrant up ssh连接到虚拟机1vagrant ssh Vagrantfile配置文件详解目录下有一个文件Vagrantfile，里面包含有大量的配置信息，主要包括三个方面的配置，虚拟机的配置、SSH配置、Vagrant的一些基础配置。 box设置1config.vm.box = \"base\" 用于配置Vagrant要去启用哪个box作为系统，默认是base VirtualBox提供了VBoxManage这个命令行工具，可以让我们设定VM，用modifyvm这个命令让我们可以设定VM的名称和内存大小等等，这里说的名称指的是在VirtualBox中显示的名称123config.vm.provider \"virtualbox\" do |v| v.customize [\"modifyvm\", :id, \"--name\", \"astaxie\", \"--memory\", \"512\"]end 这行设置的意思是调用VBoxManage的modifyvm的命令，设置VM的名称为astaxie，内存为512MB。你可以类似的通过定制其它VM属性来定制你自己的VM。 或者使用默认的配置信息修改虚拟机配置123456789config.vm.provider \"virtualbox\" do |vb|# Display the VirtualBox GUI when booting the machine# vb.gui = true ## Customize the amount of memory on the VM:vb.memory = \"1024\"vb.cpus = \"2\"vb.name = \"pww_centos7\"end 网络设置Vagrant有两种方式来进行网络连接，一种是host-only(主机模式)，意思是主机和虚拟机之间的网络互访，其他人访问不到你的虚拟机。另一种是Bridge(桥接模式)，该模式下的VM就像是局域网中的一台独立的主机，也就是说需要VM到你的路由器要IP，这样的话局域网里面其他机器就可以访问它12345# host-onlyconfig.vm.network \"private_network\", ip: \"192.168.33.10\"# Bridgeconfig.vm.network \"public_network\" hosename设置1config.vm.hostname = \"go-app\" 设置hostname非常重要，因为当我们有很多台虚拟服务器的时候，都是依靠hostname來做识别的 同步目录（挂载）/vagrant目录默认就是当前的开发目录，这是在虚拟机开启的时候默认挂载同步的。我们还可以通过配置来设置额外的同步目录：1config.vm.synced_folder \"../data\", \"/vagrant_data\" 端口转发（映射）1config.vm.network :forwarded_port, guest: 80, host: 8080 把对host机器上8080端口的访问请求forward到虚拟机的80端口的服务 多台vm通信上面的配置都是针对单个服务器配置，如果是多个服务器，比如一台应用服务器，一台redis服务器，可以使用下面的配置：12345678910111213141516171819Vagrant.configure(\"2\") do |config| config.vm.define :web do |web| web.vm.provider \"virtualbox\" do |v| v.customize [\"modifyvm\", :id, \"--name\", \"web\", \"--memory\", \"512\"] end web.vm.box = \"CentOs7\" web.vm.hostname = \"web\" web.vm.network :private_network, ip: \"192.168.33.10\" end config.vm.define :redis do |redis| redis.vm.provider \"virtualbox\" do |v| v.customize [\"modifyvm\", :id, \"--name\", \"redis\", \"--memory\", \"512\"] end redis.vm.box = \"CentOs7\" redis.vm.hostname = \"redis\" redis.vm.network :private_network, ip: \"192.168.33.11\" endend 也可以通过指定服务器名，ssh登录到指定服务器1vagrant ssh redis 常见问题 无法挂载本地目录到虚拟机，提示mount: unknown filesystem type ‘vboxsf’ 123# 通过安装vagrant-vbguest来修复vagrant plugin install vagrant-vbguestvagrant reload 修改完配置记得用vagrant reload重启命令使配置生效 参考文档：https://github.com/astaxie/go-best-practice/blob/master/ebook/zh/01.2.mdhttps://blog.csdn.net/hel12he/article/details/51089774","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"vagrant","slug":"vagrant","permalink":"https://pengwenwu.github.io/tags/vagrant/"}]},{"title":"如何保证后端接口的幂等性？","slug":"如何保证后端接口的幂等性？","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2018/07/20/如何保证后端接口的幂等性？/","link":"","permalink":"https://pengwenwu.github.io/2018/07/20/如何保证后端接口的幂等性？/","excerpt":"","text":"一、什么是幂等性？ 一个操作，不论执行多少次，产生的效果和返回的结果都是一样的 二、应用场景 一个订单创建接口，第一次调用超时了，然后又调用了一次 订单创建后需要去执行扣减库存等等的后续操作，第一次调用超时后又调用一次 支付订单，已经发送过支付请求，第一次超时后又调用一次 订单完成支付后，发送消息处理一系列后续请求，中间件消息被多个机器（分布式）或者进程执行 对外提供接口的api如何保证幂等 这些问题都是在单体架构转成微服务架构之后，带来的问题。除了查询接口，增加、更新、删除都要保证幂等性，如何保证？ 三、解决方方案1、 全局唯一ID根据每一次的操作和内容生成一个全局ID(guid等)，在执行操作之前判断这个唯一ID是否存在，决定是否继续执行。 缺点：只是一种通用方案，不可能所有操作都做唯一性判读，一个是效率问题，另一个是要考虑分布式以及上下游的问题，实现起来较困难。另外就是：如果是针对某张表的唯一索引，会出现重复更新的情况，所以更多的是要结合数据库字段以及状态机去实现， 业务情景： 支付订单：生成唯一的支付凭证 对外提供接口的api 2、 token机制业务情景： 防止订单重复提交，创建多个订单 业务要求：页面数据只能被点击提交一次 发生原因：重复点击、网络重发、nginx重发等原因 解决方法：在数据提交之前，向服务端申请token，提交后后端校验token，并删除token 3、 数据库字段约束业务情景： 更新订单状态 库存扣减 数据库字段约束主要用版本号控制，状态机约束，字段约束 字段约束主要是通过一些主键或者唯一索引去判断执行插入：无法插入相同数据 更新： 悲观锁： select * from table_xxx where id=’xxx’ for update; 版本号控制更新： 乐观锁： updateGoodsName(int id,String newName,int version); update goods set name=#{newName},version=#{version+1} where id=#{id} and version=${version} 状态机设置固定的状态类型，只有同时满足该状态类型下的多个状态，才能执行 比如： A:订单 待付款待发货 contain 待发货已发货 全部是已发货 已收货 退款 退货已收货 全部已收货退款中退款成功退款失败退货中退货成功退货失败已取消 B:订单（不存入库状态） 待付款待发货（未确认、已确认）已发货已收货退款中退款成功退款失败退货中退货成功退货失败已取消 参考链接：高并发的核心技术-幂等的实现方案接口设计的幂等性考虑分布式高并发系统如何保证对外接口的幂等性？如何绘画状态机来描述业务的变化 - 人人都是产品经理","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://pengwenwu.github.io/tags/分布式/"},{"name":"幂等性","slug":"幂等性","permalink":"https://pengwenwu.github.io/tags/幂等性/"}]},{"title":"CI框架3.x源码阅读笔记三之全局函数库文件Common.php文件","slug":"CI框架3-x源码阅读笔记三之全局函数库文件Common-php文件","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2018/07/18/CI框架3-x源码阅读笔记三之全局函数库文件Common-php文件/","link":"","permalink":"https://pengwenwu.github.io/2018/07/18/CI框架3-x源码阅读笔记三之全局函数库文件Common-php文件/","excerpt":"","text":"全局函数库Common.phpCommon.php文件定义了一系列的全局函数，具有最高的加载优先权 function_exists()的使用是为了避免重复定义 1require_once(BASEPATH.'core/Common.php'); is_php()确定当前PHP版本是否等于或大于提供的值 123456789101112131415161718192021if ( ! function_exists('is_php'))&#123; /** * Determines if the current version of PHP is equal to or greater than the supplied value * * @param string * @return bool TRUE if the current version is $version or higher */ function is_php($version) &#123; static $_is_php; $version = (string) $version; if ( ! isset($_is_php[$version])) &#123; $_is_php[$version] = version_compare(PHP_VERSION, $version, '&gt;='); &#125; return $_is_php[$version]; &#125;&#125; is_really_writable()测试文件可写性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051if ( ! function_exists('is_really_writable'))&#123; /** * Tests for file writability * * is_writable() returns TRUE on Windows servers when you really can't write to * the file, based on the read-only attribute. is_writable() is also unreliable * on Unix servers if safe_mode is on. * * @link https://bugs.php.net/bug.php?id=54709 * @param string * @return bool */ function is_really_writable($file) &#123; // 兼容linux/Unix和windows系统 // 可以通过分隔符判断当前系统是linux，直接调用方法判断文件是否可写 if (DIRECTORY_SEPARATOR === '/' &amp;&amp; (is_php('5.4') OR ! ini_get('safe_mode'))) &#123; return is_writable($file); &#125; // Windows系统 if (is_dir($file)) &#123; // 如果是目录，则创建一个随机命名的文件 $file = rtrim($file, '/').'/'.md5(mt_rand()); // 如果文件无法创建，则返回不可写 // 这里fopen参数的mode多加了'b'，是强制使用二进制的意思 if (($fp = @fopen($file, 'ab')) === FALSE) &#123; return FALSE; &#125; fclose($fp); // 删除刚才的文件 @chmod($file, 0777); @unlink($file); return TRUE; &#125; elseif ( ! is_file($file) OR ($fp = @fopen($file, 'ab')) === FALSE) &#123; // 非文件或者文件无法打开 return FALSE; &#125; // 关闭句柄 fclose($fp); return TRUE; &#125;&#125; &amp;load_class()这个函数充当单例。如果所请求的类不存在，则实例化并将其设置为静态变量。如果先前实例化了变量，则返回该变量。 引用返回：该函数返回的是一个class实例的引用，任何对该实例的改变，都会影响下一次函数的调用结果 也是通过内部的static关键字进行缓存已经加载的类的实例，实现方式类似于单例模式 优先查找APPPATH和BASEPATH，最后才从$directory中查找类。如果存在同名类，最终加载自定义的扩展类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpfunction &amp;load_class($class, $directory = 'libraries', $param = NULL)&#123; static $_classes = array(); // 判断当前类是否存在，已存在，则返回 if (isset($_classes[$class])) &#123; return $_classes[$class]; &#125; $name = FALSE; // 首先查找本地 application/directory 文件夹 // 然后是本机的 system/directory 文件夹 // 优先使用app自定义类 foreach (array(APPPATH, BASEPATH) as $path) &#123; if (file_exists($path.$directory.'/'.$class.'.php')) &#123; $name = 'CI_'.$class; if (class_exists($name, FALSE) === FALSE) &#123; require_once($path.$directory.'/'.$class.'.php'); &#125; break; &#125; &#125; // 自定义的拓展类是否存在，加载 if (file_exists(APPPATH.$directory.'/'.config_item('subclass_prefix').$class.'.php')) &#123; $name = config_item('subclass_prefix').$class; if (class_exists($name, FALSE) === FALSE) &#123; require_once(APPPATH.$directory.'/'.$name.'.php'); &#125; &#125; // 未找到该类 if ($name === FALSE) &#123; // Note: We use exit() rather than show_error() in order to avoid a // self-referencing loop with the Exceptions class set_status_header(503); echo 'Unable to locate the specified class: '.$class.'.php'; exit(5); // EXIT_UNK_CLASS &#125; // 记录刚刚加载过的类 is_loaded($class); // 实例化 $_classes[$class] = isset($param) ? new $name($param) : new $name(); return $_classes[$class];&#125; is_loaded用来追踪被加载过的类 12345678910111213141516171819202122&lt;?phpif ( ! function_exists('is_loaded'))&#123; /** * Keeps track of which libraries have been loaded. This function is * called by the load_class() function above * * @param string * @return array */ function &amp;is_loaded($class = '') &#123; static $_is_loaded = array(); if ($class !== '') &#123; $_is_loaded[strtolower($class)] = $class; &#125; return $_is_loaded; &#125;&#125; get_config记载主要的config.php文件 这个函数允许我们抓取配置文件，即使是配置类还没有被实例化 类型约束：php5可以使用类型约束，函数的参数可以指定必须为对象（在函数原型里面指定类的名字），接口，数组（php5.1起），回调callback（php5.4起）。自php7起，新增标量类型声明：字符串string，整数int，浮点数float，布尔值bool。一般不太会用到，除非是依赖注入的设计模式中 需要注意的几点： 函数只加载主配置文件，不会加载其他配置文件（这意味着，如果添加了其他的配置文件，在框架预备完毕之前，不会读取你的配置文件）。在Config组件实例化之前，所有读取主配置文件的工作都由该函数完成 该函数支持动态运行的过程中修改Config.php中的条目（配置信息只可能修改一次，因为该函数也有static变量做缓存，若缓存存在，则直接返回配置） 会同时加载environment下的配置文件，即会覆盖先前查找的config.php中相同的属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phpif ( ! function_exists('get_config'))&#123; /** * Loads the main config.php file * * This function lets us grab the config file even if the Config class * hasn't been instantiated yet * * @param array * @return array */ function &amp;get_config(Array $replace = array()) &#123; static $config; if (empty($config)) &#123; $file_path = APPPATH.'config/config.php'; $found = FALSE; if (file_exists($file_path)) &#123; $found = TRUE; require($file_path); &#125; // Is the config file in the environment folder? if (file_exists($file_path = APPPATH.'config/'.ENVIRONMENT.'/config.php')) &#123; require($file_path); &#125; elseif ( ! $found) &#123; set_status_header(503); echo 'The configuration file does not exist.'; exit(3); // EXIT_CONFIG &#125; // Does the $config array exist in the file? if ( ! isset($config) OR ! is_array($config)) &#123; set_status_header(503); echo 'Your config file does not appear to be formatted correctly.'; exit(3); // EXIT_CONFIG &#125; &#125; // Are any values being dynamically added or replaced? foreach ($replace as $key =&gt; $val) &#123; $config[$key] = $val; &#125; return $config; &#125;&#125; config_item获取配置数组中具体的值12345678910111213141516171819202122&lt;?phpif ( ! function_exists('config_item'))&#123; /** * Returns the specified config item * * @param string * @return mixed */ function config_item($item) &#123; static $_config; if (empty($_config)) &#123; // references cannot be directly assigned to static variables, so we use an array $_config[0] =&amp; get_config(); &#125; return isset($_config[0][$item]) ? $_config[0][$item] : NULL; &#125;&#125; get_mimes此函数返回从配置/ mimes.php MIME类型的数组 12345678910111213141516171819202122232425262728293031&lt;?phpif ( ! function_exists('get_mimes'))&#123; /** * Returns the MIME types array from config/mimes.php * * @return array */ function &amp;get_mimes() &#123; static $_mimes; if (empty($_mimes)) &#123; if (file_exists(APPPATH.'config/'.ENVIRONMENT.'/mimes.php')) &#123; $_mimes = include(APPPATH.'config/'.ENVIRONMENT.'/mimes.php'); &#125; elseif (file_exists(APPPATH.'config/mimes.php')) &#123; $_mimes = include(APPPATH.'config/mimes.php'); &#125; else &#123; $_mimes = array(); &#125; &#125; return $_mimes; &#125;&#125; is_https判断是佛通过加密访问1234567891011121314151617181920212223242526272829&lt;?phpif ( ! function_exists('is_https'))&#123; /** * Is HTTPS? * * Determines if the application is accessed via an encrypted * (HTTPS) connection. * * @return bool */ function is_https() &#123; if ( ! empty($_SERVER['HTTPS']) &amp;&amp; strtolower($_SERVER['HTTPS']) !== 'off') &#123; return TRUE; &#125; elseif (isset($_SERVER['HTTP_X_FORWARDED_PROTO']) &amp;&amp; $_SERVER['HTTP_X_FORWARDED_PROTO'] === 'https') &#123; return TRUE; &#125; elseif ( ! empty($_SERVER['HTTP_FRONT_END_HTTPS']) &amp;&amp; strtolower($_SERVER['HTTP_FRONT_END_HTTPS']) !== 'off') &#123; return TRUE; &#125; return FALSE; &#125;&#125; is_cli判断是否由命令行运行12345678910111213141516&lt;?phpif ( ! function_exists('is_cli'))&#123; /** * Is CLI? * * Test to see if a request was made from the command line. * * @return bool */ function is_cli() &#123; return (PHP_SAPI === 'cli' OR defined('STDIN')); &#125;&#125; show_error错误处理程序 这个函数允许我们调用异常类，使用application/views/errors/error_general.php下的标准错误模板显示错误 此函数会将错误页面直接发送到浏览器并退出1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpif ( ! function_exists('show_error'))&#123; /** * Error Handler * * This function lets us invoke the exception class and * display errors using the standard error template located * in application/views/errors/error_general.php * This function will send the error page directly to the * browser and exit. * * @param string * @param int * @param string * @return void */ function show_error($message, $status_code = 500, $heading = 'An Error Was Encountered') &#123; $status_code = abs($status_code); if ($status_code &lt; 100) &#123; $exit_status = $status_code + 9; // 9 is EXIT__AUTO_MIN if ($exit_status &gt; 125) // 125 is EXIT__AUTO_MAX &#123; $exit_status = 1; // EXIT_ERROR &#125; $status_code = 500; &#125; else &#123; $exit_status = 1; // EXIT_ERROR &#125; // 记载异常类，都是通过该组件去管理错误 $_error =&amp; load_class('Exceptions', 'core'); echo $_error-&gt;show_error($heading, $message, 'error_general', $status_code); exit($exit_status); &#125;&#125; show_404展示错误页面 123456789101112131415161718192021&lt;?phpif ( ! function_exists('show_404'))&#123; /** * 404 Page Handler * * This function is similar to the show_error() function above * However, instead of the standard error template it displays * 404 errors. * * @param string * @param bool * @return void */ function show_404($page = '', $log_error = TRUE) &#123; $_error =&amp; load_class('Exceptions', 'core'); $_error-&gt;show_404($page, $log_error); exit(4); // EXIT_UNKNOWN_FILE &#125;&#125; log_message调用Log组件记录log信息 1234567891011121314151617181920212223242526&lt;?phpif ( ! function_exists('log_message'))&#123; /** * Error Logging Interface * * We use this as a simple mechanism to access the logging * class and send messages to be logged. * * @param string the error level: 'error', 'debug' or 'info' * @param string the error message * @return void */ function log_message($level, $message) &#123; static $_log; if ($_log === NULL) &#123; // references cannot be directly assigned to static variables, so we use an array $_log[0] =&amp; load_class('Log', 'core'); &#125; $_log[0]-&gt;write_log($level, $message); &#125;&#125; set_status_header设置http头信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?phpif ( ! function_exists('set_status_header'))&#123; /** * Set HTTP Status Header * * @param int the status code * @param string * @return void */ function set_status_header($code = 200, $text = '') &#123; if (is_cli()) &#123; return; &#125; if (empty($code) OR ! is_numeric($code)) &#123; show_error('Status codes must be numeric', 500); &#125; // 此函数构造一个响应头。$stati为响应码与其响应说明 if (empty($text)) &#123; is_int($code) OR $code = (int) $code; $stati = array( 100 =&gt; 'Continue', 101 =&gt; 'Switching Protocols', 200 =&gt; 'OK', 201 =&gt; 'Created', 202 =&gt; 'Accepted', 203 =&gt; 'Non-Authoritative Information', 204 =&gt; 'No Content', 205 =&gt; 'Reset Content', 206 =&gt; 'Partial Content', 300 =&gt; 'Multiple Choices', 301 =&gt; 'Moved Permanently', 302 =&gt; 'Found', 303 =&gt; 'See Other', 304 =&gt; 'Not Modified', 305 =&gt; 'Use Proxy', 307 =&gt; 'Temporary Redirect', 400 =&gt; 'Bad Request', 401 =&gt; 'Unauthorized', 402 =&gt; 'Payment Required', 403 =&gt; 'Forbidden', 404 =&gt; 'Not Found', 405 =&gt; 'Method Not Allowed', 406 =&gt; 'Not Acceptable', 407 =&gt; 'Proxy Authentication Required', 408 =&gt; 'Request Timeout', 409 =&gt; 'Conflict', 410 =&gt; 'Gone', 411 =&gt; 'Length Required', 412 =&gt; 'Precondition Failed', 413 =&gt; 'Request Entity Too Large', 414 =&gt; 'Request-URI Too Long', 415 =&gt; 'Unsupported Media Type', 416 =&gt; 'Requested Range Not Satisfiable', 417 =&gt; 'Expectation Failed', 422 =&gt; 'Unprocessable Entity', 500 =&gt; 'Internal Server Error', 501 =&gt; 'Not Implemented', 502 =&gt; 'Bad Gateway', 503 =&gt; 'Service Unavailable', 504 =&gt; 'Gateway Timeout', 505 =&gt; 'HTTP Version Not Supported' ); if (isset($stati[$code])) &#123; $text = $stati[$code]; &#125; else &#123; show_error('No status text available. Please check your status code number or supply your own message text.', 500); &#125; &#125; // php_sapi_name()方法可以获得PHP与服务器之间的接口类型 if (strpos(PHP_SAPI, 'cgi') === 0) &#123; header('Status: '.$code.' '.$text, TRUE); &#125; else &#123; $server_protocol = isset($_SERVER['SERVER_PROTOCOL']) ? $_SERVER['SERVER_PROTOCOL'] : 'HTTP/1.1'; header($server_protocol.' '.$code.' '.$text, TRUE, $code); &#125; &#125;&#125; _error_handler、_exception_handler、_shutdown_handler错误处理机制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpif ( ! function_exists('_error_handler'))&#123; /** * Error Handler * * This is the custom error handler that is declared at the (relative) * top of CodeIgniter.php. The main reason we use this is to permit * PHP errors to be logged in our own log files since the user may * not have access to server logs. Since this function effectively * intercepts PHP errors, however, we also need to display errors * based on the current error_reporting level. * We do that with the use of a PHP error template. * * @param int $severity * @param string $message * @param string $filepath * @param int $line * @return void */ function _error_handler($severity, $message, $filepath, $line) &#123; $is_error = (((E_ERROR | E_COMPILE_ERROR | E_CORE_ERROR | E_USER_ERROR) &amp; $severity) === $severity); // When an error occurred, set the status header to '500 Internal Server Error' // to indicate to the client something went wrong. // This can't be done within the $_error-&gt;show_php_error method because // it is only called when the display_errors flag is set (which isn't usually // the case in a production environment) or when errors are ignored because // they are above the error_reporting threshold. if ($is_error) &#123; set_status_header(500); &#125; // Should we ignore the error? We'll get the current error_reporting // level and add its bits with the severity bits to find out. if (($severity &amp; error_reporting()) !== $severity) &#123; return; &#125; $_error =&amp; load_class('Exceptions', 'core'); $_error-&gt;log_exception($severity, $message, $filepath, $line); // Should we display the error? if (str_ireplace(array('off', 'none', 'no', 'false', 'null'), '', ini_get('display_errors'))) &#123; $_error-&gt;show_php_error($severity, $message, $filepath, $line); &#125; // If the error is fatal, the execution of the script should be stopped because // errors can't be recovered from. Halting the script conforms with PHP's // default error handling. See http://www.php.net/manual/en/errorfunc.constants.php if ($is_error) &#123; exit(1); // EXIT_ERROR &#125; &#125;&#125; remove_invisible_characters删除不可见字符 123456789101112131415161718192021222324252627282930313233343536&lt;?phpif ( ! function_exists('remove_invisible_characters'))&#123; /** * Remove Invisible Characters * * This prevents sandwiching null characters * between ascii characters, like Java\\0script. * 这可以防止夹空字符之间的ASCII字符，如java \\ 0scrip * @param string * @param bool * @return string */ function remove_invisible_characters($str, $url_encoded = TRUE) &#123; $non_displayables = array(); // every control character except newline (dec 10), // carriage return (dec 13) and horizontal tab (dec 09) if ($url_encoded) &#123; $non_displayables[] = '/%0[0-8bcef]/'; // url encoded 00-08, 11, 12, 14, 15 $non_displayables[] = '/%1[0-9a-f]/'; // url encoded 16-31 &#125; $non_displayables[] = '/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]+/S'; // 00-08, 11, 12, 14-31, 127 do &#123; $str = preg_replace($non_displayables, '', $str, -1, $count); &#125; while ($count); return $str; &#125;&#125; html_escape返回HTML转义变量 12345678910111213141516171819202122232425&lt;?phpif ( ! function_exists('html_escape'))&#123; /** * Returns HTML escaped variable. * * @param mixed $var The input string or array of strings to be escaped. * @param bool $double_encode $double_encode set to FALSE prevents escaping twice. * @return mixed The escaped string or array of strings as a result. */ function html_escape($var, $double_encode = TRUE) &#123; if (empty($var)) &#123; return $var; &#125; if (is_array($var)) &#123; return array_map('html_escape', $var, array_fill(0, count($var), $double_encode)); &#125; return htmlspecialchars($var, ENT_QUOTES, config_item('charset'), $double_encode); &#125;&#125; _stringify_attributes在HTML标签中使用Stringify属性 用于转换字符串、数组或对象的辅助函数的字符串的属性 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpif ( ! function_exists('_stringify_attributes'))&#123; /** * Stringify attributes for use in HTML tags. * * Helper function used to convert a string, array, or object * of attributes to a string. * * @param mixed string, array, object * @param bool * @return string */ function _stringify_attributes($attributes, $js = FALSE) &#123; $atts = NULL; if (empty($attributes)) &#123; return $atts; &#125; if (is_string($attributes)) &#123; return ' '.$attributes; &#125; $attributes = (array) $attributes; foreach ($attributes as $key =&gt; $val) &#123; $atts .= ($js) ? $key.'='.$val.',' : ' '.$key.'=\"'.$val.'\"'; &#125; return rtrim($atts, ','); &#125;&#125; function_usable函数可用 123456789101112131415161718192021222324252627282930&lt;?phpif ( ! function_exists('function_usable'))&#123; /** * Function usable * * @link http://www.hardened-php.net/suhosin/ * @param string $function_name Function to check for * @return bool TRUE if the function exists and is safe to call, * FALSE otherwise. */ function function_usable($function_name) &#123; static $_suhosin_func_blacklist; if (function_exists($function_name)) &#123; if ( ! isset($_suhosin_func_blacklist)) &#123; $_suhosin_func_blacklist = extension_loaded('suhosin') ? explode(',', trim(ini_get('suhosin.executor.func.blacklist'))) : array(); &#125; return ! in_array($function_name, $_suhosin_func_blacklist, TRUE); &#125; return FALSE; &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"CodeIgniter","slug":"CodeIgniter","permalink":"https://pengwenwu.github.io/tags/CodeIgniter/"}]},{"title":"CI框架3.x源码阅读笔记二之核心文件CodeIgniter.php","slug":"CI框架3-x源码阅读笔记二之核心文件CodeIgniter-php","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2018/07/13/CI框架3-x源码阅读笔记二之核心文件CodeIgniter-php/","link":"","permalink":"https://pengwenwu.github.io/2018/07/13/CI框架3-x源码阅读笔记二之核心文件CodeIgniter-php/","excerpt":"","text":"核心文件CodeIgniter.php文件地址: system/core/CodeIgniter.php 加载框架常量、函数库以及框架初始化加载框架常量constants.php文件1234567&lt;?phpif (file_exists(APPPATH.'config/'.ENVIRONMENT.'/constants.php'))&#123; require_once(APPPATH.'config/'.ENVIRONMENT.'/constants.php');&#125;require_once(APPPATH.'config/constants.php'); 通过ENVIRONMENT常量去加载不同目录的constants.php，内容主要是一些常量的定义 加载全局函数库Common.php12&lt;?phprequire_once(BASEPATH.'core/Common.php'); 进行全局变量安全处理如果低于php5.4版本，将进行全局变量安全处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpif ( ! is_php('5.4'))&#123; ini_set('magic_quotes_runtime', 0); if ((bool) ini_get('register_globals')) &#123; $_protected = array( '_SERVER', '_GET', '_POST', '_FILES', '_REQUEST', '_SESSION', '_ENV', '_COOKIE', 'GLOBALS', 'HTTP_RAW_POST_DATA', 'system_path', 'application_folder', 'view_folder', '_protected', '_registered' ); $_registered = ini_get('variables_order'); foreach (array('E' =&gt; '_ENV', 'G' =&gt; '_GET', 'P' =&gt; '_POST', 'C' =&gt; '_COOKIE', 'S' =&gt; '_SERVER') as $key =&gt; $superglobal) &#123; if (strpos($_registered, $key) === FALSE) &#123; continue; &#125; foreach (array_keys($$superglobal) as $var) &#123; if (isset($GLOBALS[$var]) &amp;&amp; ! in_array($var, $_protected, TRUE)) &#123; $GLOBALS[$var] = NULL; &#125; &#125; &#125; &#125;&#125; 自定义错误、异常和程序完成的函数定义一个自定义错误处理程序，以便记录PHP错误 1234&lt;?phpset_error_handler('_error_handler');set_exception_handler('_exception_handler');register_shutdown_function('_shutdown_handler'); 检查核心class是否被扩展$assign_to_config是定义在入口文件Index.php中的配置数组，被注释掉了。 这里的subclass_prefix配置默认项是在APPPATH/Config/config.php目录。 即index.php文件中的subclass_prefix配置项具有优先权，会覆盖config中的配置。 123456&lt;?phpif (!empty($assign_to_config['subclass_prefix']))&#123; // 这里的get_config是全局函数，主要用于新增或替换原有配置 get_config(array('subclass_prefix' =&gt; $assign_to_config['subclass_prefix']));&#125; 加载composer123456789101112131415161718&lt;?phpif ($composer_autoload = config_item('composer_autoload'))&#123; if ($composer_autoload === TRUE) &#123; file_exists(APPPATH.'vendor/autoload.php') ? require_once(APPPATH.'vendor/autoload.php') : log_message('error', '$config[\\'composer_autoload\\'] is set to TRUE but '.APPPATH.'vendor/autoload.php was not found.'); &#125; elseif (file_exists($composer_autoload)) &#123; require_once($composer_autoload); &#125; else &#123; log_message('error', 'Could not find the specified $config[\\'composer_autoload\\'] path: '.$composer_autoload); &#125;&#125; 加载核心类组件BenchMark-&gt;BM指BenchMark，是CI的基准点组件，主要用于mark各种时间点、记录内存使用等参数，便于性能测试和追踪 只是用来计算程序运行消耗的时间和内存 1234&lt;?php$BM =&amp; load_class('Benchmark', 'core');$BM-&gt;mark('total_execution_time_start');$BM-&gt;mark('loading_time:_base_classes_start'); 钩子类-&gt;EXTHooks钩子类 - 提供一种机制来扩展基本系统而不进行黑客攻击。 用于在不改变CI核心的基础上改变或者增加系统的核心运行功能。Hook钩子允许你在系统运行的各个挂钩点（hook point）添加自定义的功能和跟踪，如pre_system，pre_controller，post_controller等预定义的挂钩点。以下所有的$EXT-&gt;_call_hook(“xxx”); 均是call特定挂钩点的程序（如果有的话）。1234567891011121314&lt;?php/* * ------------------------------------------------------ * Instantiate the hooks class * ------------------------------------------------------ */$EXT =&amp; load_class('Hooks', 'core');/* * ------------------------------------------------------ * Is there a \"pre_system\" hook? * ------------------------------------------------------ */$EXT-&gt;call_hook('pre_system'); 配置类-&gt;CFGConfig配置管理组件。主要用于加载配置文件、获取和设置配置项等123456789101112&lt;?php$CFG =&amp; load_class('Config', 'core');// Do we have any manually set config items in the index.php file?// 上文提到过，在index.php入口文件中，配置项具有优先权，会替换替他文件内的配置if (isset($assign_to_config) &amp;&amp; is_array($assign_to_config))&#123; foreach ($assign_to_config as $key =&gt; $value) &#123; $CFG-&gt;set_item($key, $value); &#125;&#125; 字符集设置相关扩展开启bool extension_loaded ( string $name )检查一个扩展是否已经加载。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php// 获取配置项里的charset字符集配置// config类的构造函数，会去获取APP应用目录下的配置$charset = strtoupper(config_item('charset'));ini_set('default_charset', $charset);// 检查mbstring扩展项是否开启if (extension_loaded('mbstring'))&#123; define('MB_ENABLED', TRUE); // mbstring.internal_encoding is deprecated starting with PHP 5.6 // and it's usage triggers E_DEPRECATED messages. @ini_set('mbstring.internal_encoding', $charset); // This is required for mb_convert_encoding() to strip invalid characters. // That's utilized by CI_Utf8, but it's also done for consistency with iconv. mb_substitute_character('none');&#125;else&#123; define('MB_ENABLED', FALSE);&#125;// 开启字符集转换扩展// There's an ICONV_IMPL constant, but the PHP manual says that using// iconv's predefined constants is \"strongly discouraged\".if (extension_loaded('iconv'))&#123; define('ICONV_ENABLED', TRUE); // iconv.internal_encoding is deprecated starting with PHP 5.6 // and it's usage triggers E_DEPRECATED messages. @ini_set('iconv.internal_encoding', $charset);&#125;else&#123; define('ICONV_ENABLED', FALSE);&#125;// 设置内部编码if (is_php('5.6'))&#123; ini_set('php.internal_encoding', $charset);&#125; 加载兼容性特性包重写系统组件的一些方法 mbstring mb_strlen - 字符串长度 mb_strpos - 字符串查找 mb_substr - 字符串截取 hash hash - 生成哈希值 hash_equals - 可防止时序攻击的字符串比较 hash_pbkdf2 - 生成所提供密码的 PBKDF2 密钥导出 password password_hash - 创建密码的散列，兼容crypt()，PHP7.0.0后已废弃salt password_get_info - 返回指定散列（hash）的相关信息 password_needs_rehash - 检测散列值是否匹配指定的选项 password_verify - 验证密码是否和散列值匹配 standard array_column - 返回数组中指定的一列 hex2bin - 转换十六进制字符串为二进制字符串 array_replace - 使用传递的数组替换第一个数组的元素 array_replace_recursive - 使用传递的数组递归替换第一个数组的元素 quoted_printable_encode - 将 8-bit 字符串转换成 quoted-printable 字符串 123456789101112&lt;?php// 中文字符串处理require_once(BASEPATH.'core/compat/mbstring.php');// hash处理require_once(BASEPATH.'core/compat/hash.php');// 加密兼容处理require_once(BASEPATH.'core/compat/password.php');// 标准兼容处理require_once(BASEPATH.'core/compat/standard.php'); Utf8类-&gt;UNI12&lt;?php$UNI =&amp; load_class('Utf8', 'core'); URI类12&lt;?php$URI =&amp; load_class('URI', 'core'); 路由类-&gt;RTR12&lt;?php$RTR =&amp; load_class('Router', 'core', isset($routing) ? $routing : NULL); OUTPUT类-&gt;OUT最终输出管理组件12345678&lt;?php$OUT =&amp; load_class('Output', 'core');// 判断是否有有效的缓存文件，有的话执行结束if ($EXT-&gt;call_hook('cache_override') === FALSE &amp;&amp; $OUT-&gt;_display_cache($CFG, $URI) === TRUE)&#123; exit;&#125; 安全类-&gt;SEC为xss和csrf支持加载安全类12&lt;?php$SEC =&amp; load_class('Security', 'core'); 输入及过滤类-&gt;IN用于获取输入以及表单验证12&lt;?php$IN =&amp; load_class('Input', 'core'); 语言类-&gt;LANG用于设置框架语言12&lt;?php$LANG =&amp; load_class('Lang', 'core'); 加载app应用控制器和本地system控制器123456789101112131415161718192021222324252627&lt;?php// 加载本地system原始控制器// 这里没有用load_class()；的原因是我们最终并不会直接使用该基类，都是针对继承后新的类require_once BASEPATH.'core/Controller.php';/*** 定义get_instance();方法，通过调用CI_Controller::get_instance()可以实现单例化* 调用此函数可方便以后直接取得当前应用控制器* Reference to the CI_Controller method.** Returns current CI instance object** @return object*/function &amp;get_instance()&#123; return CI_Controller::get_instance();&#125;// 加载app应用的自定义控制器if (file_exists(APPPATH.'core/'.$CFG-&gt;config['subclass_prefix'].'Controller.php'))&#123; require_once APPPATH.'core/'.$CFG-&gt;config['subclass_prefix'].'Controller.php';&#125;// 为基准设置一个标记点，记录时间$BM-&gt;mark('loading_time:_base_classes_end'); 路由的设置与判断会有下面几种情况认为是404： 访问的文件不存在 请求的class不存在 请求私有方法 请求原始基类 请求的方法不存在 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?php$e404 = FALSE;$class = ucfirst($RTR-&gt;class);$method = $RTR-&gt;method;// 文件不存在if (empty($class) OR ! file_exists(APPPATH.'controllers/'.$RTR-&gt;directory.$class.'.php'))&#123; $e404 = TRUE;&#125;else&#123; // 加载该class文件 require_once(APPPATH.'controllers/'.$RTR-&gt;directory.$class.'.php'); // 该class不存在 || 请求私有方法 || 请求原始基类 if ( ! class_exists($class, FALSE) OR $method[0] === '_' OR method_exists('CI_Controller', $method)) &#123; $e404 = TRUE; &#125; elseif (method_exists($class, '_remap')) &#123; $params = array($method, array_slice($URI-&gt;rsegments, 2)); $method = '_remap'; &#125; // 请求的方法不存在 elseif ( ! in_array(strtolower($method), array_map('strtolower', get_class_methods($class)), TRUE)) &#123; $e404 = TRUE; &#125;&#125;// 针对404的处理if ($e404)&#123; if ( ! empty($RTR-&gt;routes['404_override'])) &#123; if (sscanf($RTR-&gt;routes['404_override'], '%[^/]/%s', $error_class, $error_method) !== 2) &#123; $error_method = 'index'; &#125; $error_class = ucfirst($error_class); if ( ! class_exists($error_class, FALSE)) &#123; if (file_exists(APPPATH.'controllers/'.$RTR-&gt;directory.$error_class.'.php')) &#123; require_once(APPPATH.'controllers/'.$RTR-&gt;directory.$error_class.'.php'); $e404 = ! class_exists($error_class, FALSE); &#125; // Were we in a directory? If so, check for a global override elseif ( ! empty($RTR-&gt;directory) &amp;&amp; file_exists(APPPATH.'controllers/'.$error_class.'.php')) &#123; require_once(APPPATH.'controllers/'.$error_class.'.php'); if (($e404 = ! class_exists($error_class, FALSE)) === FALSE) &#123; $RTR-&gt;directory = ''; &#125; &#125; &#125; else &#123; $e404 = FALSE; &#125; &#125; // Did we reset the $e404 flag? If so, set the rsegments, starting from index 1 if ( ! $e404) &#123; $class = $error_class; $method = $error_method; $URI-&gt;rsegments = array( 1 =&gt; $class, 2 =&gt; $method ); &#125; else &#123; show_404($RTR-&gt;directory.$class.'/'.$method); &#125;&#125;if ($method !== '_remap')&#123; $params = array_slice($URI-&gt;rsegments, 2);&#125; 解析请求的类，并调用请求的方法123456789101112131415161718192021&lt;?php// 新的钩子pre_controller$EXT-&gt;call_hook('pre_controller');// Mark a start point so we can benchmark the controller$BM-&gt;mark('controller_execution_time_( '.$class.' / '.$method.' )_start');// 实例化这个类$CI = new $class();// 新的钩子post_controller_constructor$EXT-&gt;call_hook('post_controller_constructor');// 调用方法call_user_func_array(array(&amp;$CI, $method), $params);// Mark a benchmark end point$BM-&gt;mark('controller_execution_time_( '.$class.' / '.$method.' )_end');// 新的钩子post_controller$EXT-&gt;call_hook('post_controller'); 输出123456789101112&lt;?phpif ($EXT-&gt;call_hook('display_override') === FALSE)&#123; $OUT-&gt;_display();&#125;/** ------------------------------------------------------* Is there a \"post_system\" hook?* ------------------------------------------------------*/$EXT-&gt;call_hook('post_system');","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"CodeIgniter","slug":"CodeIgniter","permalink":"https://pengwenwu.github.io/tags/CodeIgniter/"}]},{"title":"大疆2018秋招笔试算法题最后一题","slug":"大疆2018秋招笔试算法题最后一题","date":"un55fin55","updated":"un22fin22","comments":true,"path":"2018/07/06/大疆2018秋招笔试算法题最后一题/","link":"","permalink":"https://pengwenwu.github.io/2018/07/06/大疆2018秋招笔试算法题最后一题/","excerpt":"","text":"题目给定一个非负整数数组，最初位于数组的第一个位置。数组中的元素代表你在该位置可以跳跃的最大长度，你的目的是到达数组的最后一个位置。（假设你总是可以到达数组的最后一个位置，即除了最后一个位置，其他值不能为0） 例如：输入：[2,3,1,1,4]输出：2解释：跳到最后一个位置的最小跳跃数是 2。从下标0跳到下标为1的位置，跳一步，然后跳3步达到数组的最后一个位置。 思路即在跳跃距离内，选择一个下一次跳的最远的地方。 实现作为一个算法渣渣，这种是第一时间能想到的方法，肯定不是最优解。这种最差情况的时间复杂度是n^2，最好情况是n，所以总体时间复杂度是nlogn么。。。不知道怎么算~~~1234567891011121314151617181920212223242526272829303132333435&lt;?phpfunction getShortestValue(array $arr)&#123; $count = 0; $length = count($arr); for ($i = 0; $i &lt; $length;) &#123; $count++; $current_value = $i + $arr[$i]; // 一步到位，跳出循环 if ($current_value &gt;= $length - 1) &#123; return $count; &#125; $max_value = 0; for ($j = $i + 1; $j &lt;= $current_value; $j++) &#123; $count++; $tmp = $j + $arr[$j]; if ($tmp &gt;= $length - 1) &#123; return $count; &#125; if ($tmp &gt;= $max_value) &#123; $max_value = $tmp; &#125; &#125; $i = $max_value; &#125; return $count;&#125;$arr = [1, 2, 3, 1, 3, 4, 5, 1, 2];$arr2 = [2, 3, 1, 1, 4];echo getShortestValue($arr), \"\\n\"; // 5echo getShortestValue($arr2), \"\\n\"; // 2 总结：好久不接触算法，已经忘光了，这种算是简单的，却需要花这么久时间，反思。解完才想起来，应该是要用最短路径方法去解的","categories":[{"name":"算法","slug":"算法","permalink":"https://pengwenwu.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://pengwenwu.github.io/tags/算法/"},{"name":"最短路径","slug":"最短路径","permalink":"https://pengwenwu.github.io/tags/最短路径/"}]},{"title":"PHP引用","slug":"PHP引用","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2018/07/05/PHP引用/","link":"","permalink":"https://pengwenwu.github.io/2018/07/05/PHP引用/","excerpt":"","text":"官方文档 引用是什么 引用不是什么 引用做什么 引用传递 引用返回 php引用1. 变量的引用php的引用允许两个变量指向同一个内容1234567&lt;?php$a = 10;$b =&amp; $a;echo $a, $b; // 10, 10$b = 20;echo $a, $b; // 20, 20 2. 函数的引用传递1234567891011&lt;?phpfunction foo(&amp;$var)&#123; $var++;&#125;$a=5;foo($a); // 6foo($a); // 7echo $a; // 7 3. 函数的引用返回12345678910111213141516&lt;?phpfunction &amp;test()&#123; static $b = 0;//申明一个静态变量 $b = $b + 1; echo $b; return $b;&#125;$a = test();//这条语句会输出 $b的值 为１$a = 5;$a = test();//这条语句会输出 $b的值 为2$a =&amp; test();//这条语句会输出 $b的值 为3$a = 5;$a = test();//这条语句会输出 $b的值 为6 没有加&amp;, 跟普通的函数调用没有区别。 而引用返回的作用，相当于把$b的内存地址返回，赋值给$a，使得$a, $b的内存地址指向同一个地方，即相当于执行了($a =&amp; $b;) 更多的是使用在对象中：12345678910111213141516171819&lt;?phpclass Foo&#123; public $value = 42; public function &amp;getValue() &#123; return $this-&gt;value; &#125;&#125;$obj = new Foo;$myValue = &amp;$obj-&gt;getValue();echo $myValue; // 42;$obj2 = new Foo;$obj2-&gt;value = 2;$myValue =&amp; $obj2-&gt;getValue();echo $myValue; // 2 写时复制php一个比较重要的内部机制是写时复制12345&lt;?php$a = 10;$b = $a; // 此时$b, $a 指向同一地方$b = 20; // 在写入时，才会给$b 额外分配存储空间 性能优化本来之前了解的，使用引用传递能够提高运行效率，本机测试也是能提高30%左右。不过看这篇文章，介绍引用坑大于利，所以不再推荐。文章地址：https://zhuanlan.zhihu.com/p/35107602 参考文章：https://www.cnblogs.com/xiaochaohuashengmi/archive/2011/09/10/2173092.html","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"}]},{"title":"PHP静态变量","slug":"PHP静态变量","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2018/07/03/PHP静态变量/","link":"","permalink":"https://pengwenwu.github.io/2018/07/03/PHP静态变量/","excerpt":"","text":"通常意义上的静态变量是静态分配，他们的生命周期和程序的生命周期一样，只有在程序退出的时候才结束生命周期。 php的静态变量可以分为： 静态全局变量：php中的全局变量也可以理解为静态全局变量，因为除非明确unset释放，在程序运行过程中始终存在 静态局部变量：即函数内定义的静态变量，函数在执行时对变量的操作会保持到下一次函数执行，直到程序终止 静态成员变量：在类中定义的静态变量，和实例变量相对应，静态成员变量可以在所有实例中共享 静态局部变量1234567891011&lt;?phpfunction test()&#123; static $b = 0; $b = $b + 1; echo $b; return $b;&#125;test(); // 1test(); // 2test(); // 3 静态变量只能被初始化一次12345678&lt;?phpstatic $a = 0;$a = 10;var_dump($a); // 10static $a = 0;var_dump($a); // 10 静态成员变量12345678910111213&lt;?phpclass Foo&#123; public static $a = 1;&#125;$foo1 = new Foo();echo $foo1::$a; // 1$foo2 = new Foo();echo $foo2::$a; // 1echo FOO::$a; // 1 修改静态成员变量12345678910111213141516&lt;?phpclass Foo&#123; public static $a = 1;&#125;$foo1 = new Foo();echo $foo1::$a; // 1$foo1::$a = 2;echo $foo1::$a; // 2$foo2 = new Foo();echo $foo2::$a; // 2echo FOO::$a; // 2 参考链接：《深入理解PHP内核 - 静态变量》","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"}]},{"title":"CI框架3.x源码阅读笔记一之入口文件index.php","slug":"CI框架3.x源码阅读笔记一之入口文件index.php.md","date":"un11fin11","updated":"un00fin00","comments":true,"path":"2018/07/02/CI框架3.x源码阅读笔记一之入口文件index.php.md/","link":"","permalink":"https://pengwenwu.github.io/2018/07/02/CI框架3.x源码阅读笔记一之入口文件index.php.md/","excerpt":"","text":"当前框架版本define(‘CI_VERSION’, ‘3.0.2’); 入口文件index.php12345678&lt;?php# 对比项目跟原框架增加下列代码include_once dirname(__FILE__) . '/../etc/environment.php';.........include_once dirname(__FILE__) . '/../vendor/autoload.php';include_once dirname(__FILE__) . '/../etc/load_all.php'; 主要完成下列工作： 加载环境配置文件通过environment文件判断并设置当前的环境12&lt;?phpinclude_once dirname(__FILE__) . '/../etc/environment.php'; 通过修改apache或nginx配置，设置环境变量 1234567# apache# SetEnv key=valueSetEnv CI_ENV development_beta# nginx# key valuefastcgi_param CI_ENV beta; 在通过cli运行时，通过$_SERVER[&#39;argv&#39;]获取传递给脚本的参数数组，第一个肯定为当前脚本名。 设置报警级别通过不同的环境变量，设置不同级别的报警。CI默认会有三个级别：development（开发），testing（测试），production（生产）1234567891011121314151617181920212223242526272829&lt;?phpswitch (ENVIRONMENT)&#123; case 'development': error_reporting(E_ALL &amp; ~E_NOTICE); ini_set('display_errors', 1); break; case 'development_beta': error_reporting(E_ALL &amp; ~E_NOTICE &amp; ~E_WARNING); ini_set('display_errors', 0); break; case 'testing': case 'production': ini_set('display_errors', 0); if (version_compare(PHP_VERSION, '5.3', '&gt;=')) &#123; error_reporting(E_ALL &amp; ~E_NOTICE &amp; ~E_DEPRECATED &amp; ~E_STRICT &amp; ~E_USER_NOTICE &amp; ~E_USER_DEPRECATED); &#125; else &#123; error_reporting(E_ALL &amp; ~E_NOTICE &amp; ~E_STRICT &amp; ~E_USER_NOTICE); &#125; break; default: header('HTTP/1.1 503 Service Unavailable.', TRUE, 503); echo 'The application environment is not set correctly.'; exit(1); // EXIT_ERROR&#125; 配置系统、应用、视图等程序目录12345678910&lt;?php// 定义系统目录名称$system_path = '../system';// 定义应用目录名称$application_folder = '../application';// 视图文件存放目录// 如果为空，则默认到应用程序文件夹内的标准位置$view_folder = ''; cli目录设置bool chdir ( string $directory )将 PHP 的当前目录改为 directory string dirname ( string $path )给出一个包含有指向一个文件的全路径的字符串，本函数返回去掉文件名后的目录名。 string realpath ( string $path )realpath() 扩展所有的符号连接并且处理输入的 path 中的 ‘/./‘, ‘/../‘ 以及多余的 ‘/‘ 并返回规范化后的绝对路径名。返回的路径中没有符号连接，’/./‘ 或 ‘/../‘ 成分。 STDIN、STDOUT、STDERR是PHP以 CLI（Command Line Interface）模式运行而定义的三个常量，这三个常量类似于Shell的stdin,stdout,stdout,分别是PHP CLI模式下的标准输入、标准输出和标准错误流。 这三行代码是为了保证命令行模式下，CI框架可以正常运行12345&lt;?phpif (defined('STDIN'))&#123; chdir(dirname(__FILE__));&#125; 系统、应用、视图等目录的正确性验证系统(system)文件目录的正确性验证用于校验生成system系统文件目录, 得到规范化的绝对路径名123456789101112131415161718&lt;?phpif (($_temp = realpath($system_path)) !== FALSE)&#123; $system_path = $_temp.'/';&#125;else&#123; // 确保后面有斜线 $system_path = rtrim($system_path, '/').'/';&#125;// 如果$system_path所指向的文件目录不存在，则dieif ( ! is_dir($system_path))&#123; header('HTTP/1.1 503 Service Unavailable.', TRUE, 503); echo 'Your system folder path does not appear to be set correctly. Please open the following file and correct this: '.pathinfo(__FILE__, PATHINFO_BASENAME); exit(3); // EXIT_CONFIG&#125; 定义主要的路径常量mixed pathinfo ( string $path [, int $options = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME ] )pathinfo() 返回一个关联数组包含有 path 的信息。返回关联数组还是字符串取决于 options。 123456789101112&lt;?php// The name of THIS filedefine('SELF', pathinfo(__FILE__, PATHINFO_BASENAME));// Path to the system folderdefine('BASEPATH', str_replace('\\\\', '/', $system_path));// Path to the front controller (this file)define('FCPATH', dirname(__FILE__).'/');// Name of the \"system folder\"define('SYSDIR', trim(strrchr(trim(BASEPATH, '/'), '/'), '/')); 应用(application)文件目录的正确性验证123456789101112131415161718192021&lt;?phpif (is_dir($application_folder))&#123; if (($_temp = realpath($application_folder)) !== FALSE) &#123; $application_folder = $_temp; &#125; define('APPPATH', $application_folder.DIRECTORY_SEPARATOR);&#125;else&#123; if ( ! is_dir(BASEPATH.$application_folder.DIRECTORY_SEPARATOR)) &#123; header('HTTP/1.1 503 Service Unavailable.', TRUE, 503); echo 'Your application folder path does not appear to be set correctly. Please open the following file and correct this: '.SELF; exit(3); // EXIT_CONFIG &#125; define('APPPATH', BASEPATH.$application_folder.DIRECTORY_SEPARATOR);&#125; 视图(view)文件目录的正确性验证1234567891011121314151617181920212223242526272829&lt;?phpif ( ! is_dir($view_folder))&#123; if ( ! empty($view_folder) &amp;&amp; is_dir(APPPATH.$view_folder.DIRECTORY_SEPARATOR)) &#123; $view_folder = APPPATH.$view_folder; &#125; elseif ( ! is_dir(APPPATH.'views'.DIRECTORY_SEPARATOR)) &#123; header('HTTP/1.1 503 Service Unavailable.', TRUE, 503); echo 'Your view folder path does not appear to be set correctly. Please open the following file and correct this: '.SELF; exit(3); // EXIT_CONFIG &#125; else &#123; $view_folder = APPPATH.'views'; &#125;&#125;if (($_temp = realpath($view_folder)) !== FALSE)&#123; $view_folder = $_temp.DIRECTORY_SEPARATOR;&#125;else&#123; $view_folder = rtrim($view_folder, '/\\\\').DIRECTORY_SEPARATOR;&#125;define('VIEWPATH', $view_folder); 加载composer各种包的加载12&lt;?phpinclude_once dirname(__FILE__) . '/../vendor/autoload.php'; 其余初始化的文件加载包括一些监控、报警、调用链追踪12&lt;?phpinclude_once dirname(__FILE__) . '/../etc/load_all.php'; 加载核心文件12&lt;?phprequire_once BASEPATH.'core/CodeIgniter.php'; defined() - 检查某个名称的常量是否存在get_loaded_extensions() - 返回所有编译并加载模块名的 arrayget_defined_functions() - 返回所有已定义函数的数组get_defined_vars() - 返回由所有已定义变量所组成的数组","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"CodeIgniter","slug":"CodeIgniter","permalink":"https://pengwenwu.github.io/tags/CodeIgniter/"}]},{"title":"workerman入门","slug":"workerman入门","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2018/06/27/workerman入门/","link":"","permalink":"https://pengwenwu.github.io/2018/06/27/workerman入门/","excerpt":"","text":"由于php不像nodejs、java一样可以常驻内存，没有现成的websock io，需要通过原生的php socket去实现服务端websocket的通信。对于菜鸟而言，还是使用现成的框架更方便，等水平足够了，才需要去考虑这些底层的实现 什么是workerman？Workerman是一款纯PHP开发的开源高性能的PHP socket 服务器框架。本身是一个PHP多进程服务器框架，具有PHP进程管理以及socket通信的模块，所以不依赖php-fpm、nginx或者apache等这些容器便可以独立运行。 官网：http://www.workerman.net/workermanworkerman手册：http://doc.workerman.net/640361 特性 纯PHP开发 支持PHP多进程 支持TCP、UDP 支持长连接 支持各种应用层协议 支持高并发 支持服务平滑重启 支持文件更新检测及自动加载 支持以指定用户运行子进程 支持对象或者资源永久保持 高性能 支持HHVM 支持分布式部署 支持守护进程化 支持多端口监听 支持标准输入输出重定向 环境要求Linux用户(含Mac OS) 安装PHP&gt;=5.3.3，并安装了pcntl、posix扩展 建议安装event或者libevent扩展，但不是必须的（注意event扩展需要PHP&gt;=5.4） Linux环境检查脚本1curl -Ss http://www.workerman.net/check.php | php 如果脚本中全部提示ok，则代表满足WorkerMan运行环境 注意：检测脚本中没有检测event扩展或者libevent扩展，如果并发连接数大于1024建议安装event扩展或者libevent扩展 如何安装扩展参考文档：http://doc.workerman.net/appendices/install-extension.html 入门安装普通安装可以参照官网，通过git下载 也可以通过composer安装1composer require workerman/workerman 开发实例websocket实例服务端实现12345678910111213141516171819&lt;?phprequire_once './vendor/autoload.php';use Workerman\\Worker;// 注意：这里与上个例子不同，使用的是websocket协议$ws_worker = new Worker(\"websocket://0.0.0.0:9501\");// 启动4个进程对外提供服务$ws_worker-&gt;count = 4;// 当收到客户端发来的数据后返回hello $data给客户端$ws_worker-&gt;onMessage = function ($connection, $data) &#123; // 向客户端发送hello $data $connection-&gt;send('hello ' . $data);&#125;;// 运行workerWorker::runAll(); 客户端实现123456789ws = new WebSocket(\"ws://127.0.0.1:9501\");ws.onopen = function() &#123; console.log(\"连接成功\"); ws.send('tom'); console.log(\"给服务端发送一个字符串：tom\");&#125;;ws.onmessage = function(e) &#123; console.log(\"收到服务端的消息：\" + e.data);&#125;; 启动与停止启动以debug(调试)方式启动1php start.php start 以daemon(守护进程)方式启动1php start.php start -d 停止1php start.php stop 重启1php start.php restart 平滑重启1php start.php reload 查看状态1php start.php status 查看连接状态1php start.php connections debug和daemon方式区别 以debug方式启动，代码中echo、var_dump、print等打印函数会直接输出在终端 以daemon方式启动，代码中echo、var_dump、print等打印会默认重定向到/dev/null文件，可以通过设置Worker::$stdoutFile = &#39;/your/path/file&#39;;来设置这个文件路径 以debug方式启动，终端关闭后workerman会随之关闭并退出 以daemon方式启动，终端关闭后workerman继续后台正常运行 什么是平滑重启？平滑重启不同于普通的重启，平滑重启可以做到在不影响用户的情况下重启服务，以便重新载入PHP程序，完成业务代码更新。 平滑重启一般应用于业务更新或者版本发布过程中，能够避免因为代码发布重启服务导致的暂时性服务不可用的影响。 注意：只有子进程运行过程中载入的文件支持reload，主进程载入的文件不支持reload。或者说Worker::runAll执行完后workerman运行过程中动态加载的文件支持reload，Worker::runAll执行前就载入的文件代码不支持reload 平滑重启原理WorkerMan分为主进程和子进程，主进程负责监控子进程，子进程负责接收客户端的连接和连接上发来的请求数据，做相应的处理并返回数据给客户端。当业务代码更新时，其实我们只要更新子进程，便可以达到更新代码的目的。 当WorkerMan主进程收到平滑重启信号时，主进程会向其中一个子进程发送安全退出(让对应进程处理完毕当前请求后才退出)信号，当这个进程退出后，主进程会重新创建一个新的子进程（这个子进程载入了新的PHP代码），然后主进程再次向另外一个旧的进程发送停止命令，这样一个进程一个进程的重启，直到所有旧的进程全部被置换为止。 我们看到平滑重启实际上是让旧的业务进程逐个退出然后并逐个创建新的进程做到的。为了在平滑重启时不影响客用户，这就要求进程中不要保存用户相关的状态信息，即业务进程最好是无状态的，避免由于进程退出导致信息丢失。 开发流程注意事项平滑重启注意：只有在on{…}回调中载入的文件平滑重启后才会自动更新，启动脚本中直接载入的文件或者写死的代码运行reload不会自动更新。 区分主进程和子进程有必要注意下代码是运行在主进程还是子进程，一般来说在Worker::runAll();调用前运行的代码都是在主进程运行的，onXXX回调运行的代码都属于子进程。注意写在Worker::runAll();后面的代码永远不会被执行。 注意： 不要在主进程中初始化数据库、memcache、redis等连接资源，因为主进程初始化的连接可能会被子进程自动继承（尤其是使用单例的时候），所有进程都持有同一个连接，服务端通过这个连接返回的数据在多个进程上都可读，会导致数据错乱。同样的，如果任何一个进程关闭连接(例如daemon模式运行时主进程会退出导致连接关闭)，都导致所有子进程的连接都被一起关闭，并发生不可预知的错误，例如mysql gone away 错误。 推荐在onWorkerStart里面初始化连接资源。 Worker类构造函数初始化一个Worker容器实例，可以设置容器的一些属性和回调接口，完成特定功能。1Worker::__construct([string $listen , array $context]) 参数$listen （可选参数，不填写表示不监听任何端口）$listen 的格式为 &lt;协议&gt;://&lt;监听地址&gt; $context一个数组。用于传递socket的上下文选项。 比如传递ssl证书1234567891011121314151617181920&lt;?phprequire_once __DIR__ . '/Workerman/Autoloader.php';use Workerman\\Worker;// 证书最好是申请的证书$context = array( 'ssl' =&gt; array( 'local_cert' =&gt; '/etc/nginx/conf.d/ssl/server.pem', // 也可以是crt文件 'local_pk' =&gt; '/etc/nginx/conf.d/ssl/server.key', ));// 这里设置的是websocket协议$worker = new Worker('websocket://0.0.0.0:4431', $context);// 设置transport开启ssl，websocket+ssl即wss$worker-&gt;transport = 'ssl';$worker-&gt;onMessage = function($con, $msg) &#123; $con-&gt;send('ok');&#125;;Worker::runAll(); 部分常用属性id1int Worker::$id 当前worker进程的id编号，范围为0到$worker-&gt;count-1 这个属性对于区分worker进程非常有用，例如1个worker实例有多个进程，开发者只想在其中一个进程中设置定时器，则可以通过识别进程编号id来做到这一点，比如只在该worker实例id编号为0的进程设置定时器 注意：进程重启后id编号值是不变的。进程编号id的分配是基于每个worker实例的。每个worker实例都从0开始给自己的进程编号，所以worker实例间进程编号会有重复，但是一个worker实例中的进程编号不会重复。123456789101112131415161718use Workerman\\Worker;use Workerman\\Lib\\Timer;require_once './Workerman/Autoloader.php';$worker = new Worker('tcp://0.0.0.0:8585');$worker-&gt;count = 4;$worker-&gt;onWorkerStart = function($worker)&#123; // 只在id编号为0的进程上设置定时器，其它1、2、3号进程不设置定时器 if($worker-&gt;id === 0) &#123; Timer::add(1, function()&#123; echo \"4个worker进程，只在0号进程设置定时器\\n\"; &#125;); &#125;&#125;;// 运行workerWorker::runAll(); count1int Worker::$count 设置当前Worker实例启动多少个进程，不设置时默认为1。 注意：此属性必须在Worker::runAll();运行前设置才有效。windows系统不支持此特性。 设置规则： 每个进程占用内存之和需要小于总内存（一般来说每个业务进程占用内存大概40M左右） 如果是IO密集型，也就是业务中涉及到一些阻塞式IO，比如一般的访问Mysql、Redis等存储都是阻塞式访问的，进程数可以开大一些，如配置成CPU核数的3倍。注意非阻塞式IO属于CPU密集型，而不属于IO密集型。 如果是CPU密集型，也就是业务中没有阻塞式IO开销，例如使用异步IO读取网络资源，进程不会被业务代码阻塞的情况下，可以把进程数设置成和CPU核数一样 WorkerMan自身的IO都是非阻塞的，例如Connection-&gt;send等都是非阻塞的，属于CPU密集型操作。如果不清楚自己业务偏向于哪种类型，可设置进程数为CPU核数的2倍左右即可。 transport1string Worker::$transport 设置当前Worker实例所使用的传输层协议，目前只支持3种(tcp、udp、ssl)。不设置默认为tcp。 注意：ssl需要Workerman版本&gt;=3.3.7 connections1array Worker::$connections 此属性中存储了当前进程的所有的客户端连接对象，其中id为connection的id编号 格式为：1array(id=&gt;connection, id=&gt;connection, ...) stdoutFile1static string Worker::$stdoutFile 此属性为全局静态属性，如果以守护进程方式(-d启动)运行，则所有向终端的输出(echo var_dump等)都会被重定向到stdoutFile指定的文件中。 如果不设置，并且是以守护进程方式运行，则所有终端输出全部重定向到/dev/null 注意：此属性必须在Worker::runAll();运行前设置才有效。 1234567891011121314&lt;?phpuse Workerman\\Worker;require_once __DIR__ . '/Workerman/Autoloader.php';Worker::$daemonize = true;// 所有的打印输出全部保存在/tmp/stdout.log文件中Worker::$stdoutFile = '/tmp/stdout.log';$worker = new Worker('text://0.0.0.0:8484');$worker-&gt;onWorkerStart = function($worker)&#123; echo \"Worker start\\n\";&#125;;// 运行workerWorker::runAll(); reloadable设置当前Worker实例是否可以reload，即收到reload信号后是否退出重启。不设置默认为true，收到reload信号后自动重启进程。1bool Worker::$reloadable daemonize1static bool Worker::$daemonize 此属性为全局静态属性，表示是否以daemon(守护进程)方式运行。如果启动命令使用了 -d 参数，则该属性会自动设置为true。也可以代码中手动设置 回调属性onWorkerStart1callback Worker::$onWorkerStart 设置Worker子进程启动时的回调函数，每个子进程启动时都会执行。 注意：onWorkerStart是在子进程启动时运行的，如果开启了多个子进程($worker-&gt;count &gt; 1)，每个子进程运行一次，则总共会运行$worker-&gt;count次。 回调函数的参数: $worker: Worker对象 onWorkerReload1callback Worker::$onWorkerReload 设置Worker收到reload信号后执行的回调。 可以利用onWorkerReload回调做很多事情，例如在不需要重启进程的情况下重新加载业务配置文件。 注意： 子进程收到reload信号默认的动作是退出重启，以便新进程重新加载业务代码完成代码更新。所以reload后子进程在执行完onWorkerReload回调后便立刻退出是正常现象。 如果在收到reload信号后只想让子进程执行onWorkerReload，不想退出，可以在初始化Worker实例时设置对应的Worker实例的reloadable属性为false。 回调函数的参数: $worker: Worker对象 onConnect1callback Worker::$onConnect 当客户端与Workerman建立连接时(TCP三次握手完成后)触发的回调函数。每个连接只会触发一次onConnect回调。 注意：onConnect事件仅仅代表客户端与Workerman完成了TCP三次握手，这时客户端还没有发来任何数据，此时除了通过$connection-&gt;getRemoteIp()获得对方ip，没有其他可以鉴别客户端的数据或者信息，所以在onConnect事件里无法确认对方是谁。要想知道对方是谁，需要客户端发送鉴权数据，例如某个token或者用户名密码之类，在onMessage回调里做鉴权。 回调函数的参数: $connection: 连接对象 onMessage1callback Worker::$onMessage 当客户端通过连接发来数据时(Workerman收到数据时)触发的回调函数 回调函数的参数: $connection: 连接对象 $data: 客户端连接上发来的数据 onClose1callback Worker::$onClose 当客户端连接与Workerman断开时触发的回调函数。不管连接是如何断开的，只要断开就会触发onClose。每个连接只会触发一次onClose。 注意：如果对端是由于断网或者断电等极端情况断开的连接，这时由于无法及时发送tcp的fin包给workerman，workerman就无法得知连接已经断开，也就无法及时触发onClose。这种情况需要通过应用层心跳来解决。 回调函数的参数: $connection: 连接对象 onBufferDrain1callback Worker::$onBufferDrain 每个连接都有一个单独的应用层发送缓冲区，缓冲区大小由TcpConnection::$maxSendBufferSize决定，默认值为1MB，可以手动设置更改大小，更改后会对所有连接生效。 该回调可能会在调用Connection::send后立刻被触发，比如发送大数据或者连续快速的向对端发送数据，由于网络等原因数据被大量积压在对应连接的发送缓冲区，当超过TcpConnection::$maxSendBufferSize上限时触发。 回调函数的参数: $connection: 连接对象 onBufferDrain1callback Worker::$onBufferDrain 该回调在应用层发送缓冲区数据全部发送完毕后触发。一般与onBufferFull配合使用，例如在onBufferFull时停止向对端继续send数据，在onBufferDrain恢复写入数据。 回调函数的参数: $connection: 连接对象 onError1callback Worker::$onError 当客户端的连接上发生错误时触发。 目前错误类型有 调用Connection::send由于客户端连接断开导致的失败（紧接着会触发onClose回调） (code:WORKERMAN_SEND_FAIL msg:client closed) 在触发onBufferFull后(发送缓冲区已满)，仍然调用Connection::send，并且发送缓冲区仍然是满的状态导致发送失败(不会触发onClose回调)(code:WORKERMAN_SEND_FAIL msg:send buffer full and drop package) 使用AsyncTcpConnection异步连接失败时(紧接着会触发onClose回调) (code:WORKERMAN_CONNECT_FAIL msg:stream_socket_client返回的错误消息) 回调函数的参数: $connection: 连接对象$code: 错误码$msg: 错误消息 接口runAll1void Worker::runAll(void) 运行所有Worker实例。 注意： Worker::runAll()执行后将永久阻塞，也就是说位于Worker::runAll()后面的代码将不会被执行。所有Worker实例化应该都在Worker::runAll()前进行。 stopAll1void Worker::stopAll(void) 停止当前进程（子进程）的所有Worker实例并退出。 此方法用于安全退出当前子进程，作用相当于调用exit/die退出当前子进程。 与直接调用exit/die区别是，直接调用exit或者die无法触发onWorkerStop回调，并且会导致一条WORKER EXIT UNEXPECTED错误日志。 listen1void Worker::listen(void) 用于实例化Worker后执行监听。 Connection类属性idprotocol1string Connection::$protocol 设置当前连接的协议类 worker1Worker Connection::$worker 此属性为只读属性，即当前connection对象所属的worker实例 123456789101112131415use Workerman\\Worker;require_once __DIR__ . '/Workerman/Autoloader.php';$worker = new Worker('websocket://0.0.0.0:8484');// 当一个客户端发来数据时，转发给当前进程所维护的其它所有客户端$worker-&gt;onMessage = function($connection, $data)&#123; foreach($connection-&gt;worker-&gt;connections as $con) &#123; $con-&gt;send($data); &#125;&#125;;// 运行workerWorker::runAll(); maxSendBufferSize1int Connection::$maxSendBufferSize 此属性用来设置当前连接的应用层发送缓冲区大小。不设置默认为Connection::$defaultMaxSendBufferSize(1MB)。 defaultMaxSendBufferSize1static int Connection::$defaultMaxSendBufferSize 此属性为全局静态属性，用来设置所有连接的默认应用层发送缓冲区大小。不设置默认为1MB。 Connection::$defaultMaxSendBufferSize可以动态设置，设置后只对之后产生的新连接有效 maxPackageSize1static int Connection::$maxPackageSize 此属性为全局静态属性，用来设置每个连接能够接收的最大包包长。不设置默认为10MB。 回调属性与worker的回调属性作用相同 接口sendgetRemoteIpetRemotePortTimer定时器类add1int \\Workerman\\Lib\\Timer::add(float $time_interval, callable $callback [,$args = array(), bool $persistent = true]) 定时执行某个函数或者类方法 注意：定时器是在当前进程中运行的，workerman中不会创建新的进程或者线程去运行定时器。 参数time_interval: 多长时间执行一次，单位秒，支持小数，可以精确到0.001，即精确到毫秒级别 callback: 回调函数注意：如果回调函数是类的方法，则方法必须是public属性 args: 回调函数的参数，必须为数组，数组元素为参数值 persistent: 是否是持久的，如果只想定时执行一次，则传递false（只执行一次的任务在执行完毕后会自动销毁，不必调用Timer::del()）。默认是true，即一直定时执行 返回值返回一个整数，代表计时器的timerid，可以通过调用Timer::del($timerid)销毁这个计时器。 示例123456789101112131415161718192021222324252627use \\Workerman\\Worker;use \\Workerman\\Lib\\Timer;require_once __DIR__ . '/Workerman/Autoloader.php';$ws_worker = new Worker('websocket://0.0.0.0:8080');$ws_worker-&gt;count = 8;// 连接建立时给对应连接设置定时器$ws_worker-&gt;onConnect = function($connection)&#123; // 每10秒执行一次 $time_interval = 10; $connect_time = time(); // 给connection对象临时添加一个timer_id属性保存定时器id $connection-&gt;timer_id = Timer::add($time_interval, function()use($connection, $connect_time) &#123; $connection-&gt;send($connect_time); &#125;);&#125;;// 连接关闭时，删除对应连接的定时器$ws_worker-&gt;onClose = function($connection)&#123; // 删除定时器 Timer::del($connection-&gt;timer_id);&#125;;// 运行workerWorker::runAll(); 更多示例：http://doc.workerman.net/timer/add.html del1boolean \\Workerman\\Lib\\Timer::del(int $timer_id) 删除某个定时器 示例定时器回调中删除当前定时器12345678910111213141516171819202122use \\Workerman\\Worker;use \\Workerman\\Lib\\Timer;require_once __DIR__ . '/Workerman/Autoloader.php';$task = new Worker();$task-&gt;onWorkerStart = function($task)&#123; // 注意，回调里面使用当前定时器id必须使用引用(&amp;)的方式引入 $timer_id = Timer::add(1, function()use(&amp;$timer_id) &#123; static $i = 0; echo $i++.\"\\n\"; // 运行10次后删除定时器 if($i === 10) &#123; Timer::del($timer_id); &#125; &#125;);&#125;;// 运行workerWorker::runAll(); 定时器注意事项 只能在onXXXX回调中添加定时器。全局的定时器推荐在onWorkerStart回调中设置，针对某个连接的定时器推荐在onConnect中设置。 添加的定时任务在当前进程执行(不会启动新的进程或者线程)，如果任务很重（特别是涉及到网络IO的任务），可能会导致该进程阻塞，暂时无法处理其它业务。所以最好将耗时的任务放到单独的进程运行，例如建立一个/多个Worker进程运行 当前进程忙于其它业务时或者当一个任务没有在预期的时间运行完，这时又到了下一个运行周期，则会等待当前任务完成才会运行，这会导致定时器没有按照预期时间间隔运行。也就是说当前进程的业务都是串行执行的，如果是多进程则进程间的任务运行是并行的。 多进程设置了定时任务造可能会造成并发问题 可能会有1毫秒左右的误差 定时器不能跨进程删除，例如a进程设置的定时器无法在b进程直接调用Timer::del接口删除 不同进程间的定时器id可能会重复，但是同一个进程内产生的定时器id不会重复 常见问题心跳注意：长连接应用必须加心跳，否则连接可能由于长时间未通讯被路由节点强行断开。 心跳作用主要有两个： 客户端定时给服务端发送点数据，防止连接由于长时间没有通讯而被某些节点的防火墙关闭导致连接断开的情况。 服务端可以通过心跳来判断客户端是否在线，如果客户端在规定时间内没有发来任何数据，就认为客户端下线。这样可以检测到客户端由于极端情况(断电、断网等)下线的事件。 建议值：建议心跳间隔小于60秒 示例自动断开连接12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php/** * Created by PhpStorm. * User: pengwenwu * Date: 2018/6/23 * Time: 23:31 */require_once './vendor/autoload.php';use Workerman\\Worker;use Workerman\\Lib\\Timer;$ws_worker = new Worker(\"websocket://0.0.0.0:9501\");// 启动4个进程对外提供服务$ws_worker-&gt;count = 4;// 心跳间隔25秒define('HEARTBEAT_TIME', 25);$ws_worker-&gt;onMessage = function ($connection, $data) &#123; // 给connection临时设置一个lastMessageTime属性，用来记录上次收到消息的时间 $connection-&gt;lastMessageTime = time(); // 其它业务逻辑... $connection-&gt;send('hello' . $data);&#125;;// 进程启动后设置一个每秒运行一次的定时器$ws_worker-&gt;onWorkerStart = function ($worker) &#123; Timer::add(1, function () use ($worker) &#123; $time_now = time(); foreach ($worker-&gt;connections as $connection) &#123; // 有可能该connection还没收到过消息，则lastMessageTime设置为当前时间 if (empty($connection-&gt;lastMessageTime)) &#123; $connection-&gt;lastMessageTime = $time_now; continue; &#125; // 上次通讯时间间隔大于心跳间隔，则认为客户端已经下线，关闭连接 if ($time_now - $connection-&gt;lastMessageTime &gt; HEARTBEAT_TIME) &#123; $connection-&gt;close(); &#125; &#125; &#125;);&#125;;Worker::runAll(); 更多详细请参考官方手册","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"php","slug":"php","permalink":"https://pengwenwu.github.io/tags/php/"},{"name":"workerman","slug":"workerman","permalink":"https://pengwenwu.github.io/tags/workerman/"},{"name":"websocket","slug":"websocket","permalink":"https://pengwenwu.github.io/tags/websocket/"}]},{"title":"WebSocket入门","slug":"WebSocket入门","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2018/06/18/WebSocket入门/","link":"","permalink":"https://pengwenwu.github.io/2018/06/18/WebSocket入门/","excerpt":"","text":"为什么需要WebSocket？虽然有HTTP协议，但是一个很明显的缺点是：所有请求只能有客户端发起，向服务端请求。而服务端有任何状态变化，无法直接通知到客户端。简单处理的方法就是轮询，连续不断发起请求，但是这个非常浪费资源，因为需要不断请求连接。最常见的例子就是聊天室。 WebSocket优点： 支持双向通信，实时性更强 更好的支持二进制 较少的控制开销，数据交换时，数据包请求头较小 支持更多扩展 websocket也是通过http请求去建立连接，请求格式如下：1234567GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13 跟普通http请求的区别： GET请求的地址不是类似/path/，而是以ws://开头的地址 请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接 Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据 Sec-WebSocket-Version指定了WebSocket的协议版本 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 服务器返回数据：1234HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: server-random-string 该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议 成功建立连接后，客户端和服务端就可以直接主动发消息给对方。消息传递的格式有两种：文本，二进制数据.通常可以发送JSON数据，方便处理 WebSocket对象123var ws = new WebSokcet(url, [protocol])const ws = new WebSocket('ws://echo.websocket.org', ['myProtocol1', 'myProtocol2']) WebSocket 构造函数可接受两个参数，其中，第一个参数必须是以 ws:// 或 wss:// 开头的完全限定的 URL第二个为非必要参数，用于指定可接受的子协议，有两种可能的类型: String 类型，值为客户端和服务器端均能理解的协议 Arrary 类型，包含一组客户端支持的协议（String 类型） WebSocket 属性Socket.readyState只读属性 readyState 表示连接状态，可以是以下值： 0 | WebSocket.CONNECTING：表示连接尚未建立 1 | WebSocket.OPEN：表示连接已经建立 2 | WebSocket.CLOSEING：表示连接正在关闭 3 | WebSocket.CLOSED: 表示连接已经关闭或者连接不能打开 bufferedAmountWebSocket 对象的 bufferedAmount 属性可以用检查已经进入发送队列，但是还未发送到服务器的字节数。可以用来判断发送是否结束 protocolWebSocket 对象的 protocol 属性值为 WebSocket 打开连接握手期间，服务器端所选择的协议名 protocol 属性在最初的握手完成之前为空，如果服务器没有选择客户端提供的某个协议，则该属性保持空值 WebSockets事件处理WebSocket 对象具有以下 4 个事件： open 事件当服务器响应了 WebSocket 连接请求，触发open事件并建立一个连接，此时WebSocket已经准备好发送和接收数据，open事件对应的回调函数是onopen()12345678ws.onopen = (event) =&gt; &#123; console.log('开启连接');&#125;// 或者ws.addEventListener('open', (event) =&gt; &#123; console.log('开启连接');&#125;, false) message事件message事件在接收到消息是触发，消息内容存储在事件对象event的data中，对应的回调函数是onmessage()1234567ws.onmessage = (event) =&gt; &#123; if (typeof event.data === 'string') &#123; console.log('接收到的string消息内容为：' + event.data) &#125; else &#123; console.log('其他类型消息') &#125;&#125; 除了普通文件，WebSocket消息内容还可以是二进制，这种数据作为Blob消息或者ArraryBuffer消息处理。暂不赘述。 error事件error事件在响应意外发生故障时触发，对应的回调函数是onerror()。错误会导致WebSocket连接关闭。 close事件close事件在连接关闭时触发，对应的回调函数是onclose()。一旦连接关闭，客户端和服务器端不在接续接收和发送消息。close事件的3个常用属性： wasClean：布尔值，表示连接是否被正确关闭。如果是来自服务器的close帧的响应，则为true；如果是因为其他原因关闭，则为false code：服务器发送的关闭连接握手状态码 reason：服务器发送的关闭连接握手状态 WebSocket方法WebSocket API提供两个方法供调用。 send()使用send()方法可以从客户端向服务端发送消息。前提是必须当WebSocket在客户端和服务端建立全双工双向连接后，才可以调用该方法。所以一般是在open事件触发之后，close触发之前调用send()发送消息123ws.onopen = (event) &#123; ws.send('hello websocket');&#125; close()通过使用close()方法，可以人为的手动关闭WebSocket连接或者终止连接尝试。如果连接已关闭，则该方法什么也不做 可以向close()方法传递两个参数： code：Number类型，状态代码 reason: String类型，文本字符串，传递一些关于关闭连接的信息 参考链接：《WebSocket 教程 - 阮一峰》《WebSocket客户端编程》","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://pengwenwu.github.io/tags/WebSocket/"}]},{"title":"使用laradock配置LNMP环境","slug":"使用laradock配置LNMP环境","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/06/10/使用laradock配置LNMP环境/","link":"","permalink":"https://pengwenwu.github.io/2018/06/10/使用laradock配置LNMP环境/","excerpt":"","text":"介绍laradock是一个为php配置的完整的docker环境，可以通过修改配置文件，完成对不同版本、不同扩展、不同框架的php docker环境配置。从此对虚拟机说再见 使用clone到项目的同级目录或者使用Git 子模块1git clone https://github.com/Laradock/laradock.git laradock 这里使用CodeIgniter框架举个例子，目录结构是这样12|--- CodeIgniter|--- laradock 复制配置文件.env 才是配置文件123# 进入laradockm目录cd laradockcp env-example .env 增加配置参数如果需要使用mysql，redis等，.env需要新增配置HOST地址1234# .env 末尾新增DB_HOST=mysqlREDIS_HOST=redisQUEUE_HOST=rabbitmq 修改nginx默认挂在目录1vim laradock/nginx/sites/default.conf 修改default.conf配置文件123# 原配置# root /var/www/publicroot /var/www/CodeIgniter 启动容器这里有个坑，由于最近更新了mysql8，而laradoc的mysql中的Dockerfile默认是from latest拉去最新镜像，会导致mysql无法后台运行，秒退，应该是旧配置挂载问题1docker-compose up -d nginx mysql phpmyadmin redis workspace 这里需要重新构建mysql1234docker-compose build --build-arg MYSQL_VERSION=5.7 mysql# 构建完，重启容器docker-compose up -d mysql 查看可以通过docker-compose ps查看各个容器运行状态，以及暴露的端口12345678 Name Command State Ports--------------------------------------------------------------------------------------------------------laradoc_mysql_1 docker-entrypoint.sh mysqld Up 0.0.0.0:3306-&gt;3306/tcplaradoc_nginx_1 nginx Up 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:80-&gt;80/tcplaradoc_php-fpm_1 docker-php-entrypoint php-fpm Up 9000/tcplaradoc_phpmyadmin_1 /run.sh phpmyadmin Up 0.0.0.0:8080-&gt;80/tcp, 9000/tcplaradoc_redis_1 docker-entrypoint.sh redis ... Up 0.0.0.0:6379-&gt;6379/tcplaradoc_workspace_1 /sbin/my_init Up 0.0.0.0:2222-&gt;22/tcp 这里看到，nginx默认80端口，打开浏览器，输入localhost即可访问，正常返回的是CI框架的默认首页 Welcome to CodeIgniter! phpmyadmin的端口是8080，浏览器输入localhost:8080，则可以访问phpmyadmin。服务器地址是之前配置的 DB_HOST = mysql，账号密码可以查看.env配置文件，默认是root root，这些都是可以在启动命令的参数里设置 参考链接：《Laradock》","categories":[{"name":"Docker","slug":"Docker","permalink":"https://pengwenwu.github.io/categories/Docker/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"Docker","slug":"Docker","permalink":"https://pengwenwu.github.io/tags/Docker/"}]},{"title":"git子模块","slug":"git子模块","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/06/10/git子模块/","link":"","permalink":"https://pengwenwu.github.io/2018/06/10/git子模块/","excerpt":"","text":"子模块文档：Git 工具 - 子模块 在一个项目中要引入另外一个项目，比如我在当前项目里，想要引入laradock docker环境，需要怎么操作？难道需要copy一份代码过来？怎么保证同步更新？ 添加子模块在当前项目中执行git submodule add命令1git submodule add https://github.com/Laradock/laradock.git laradock 此时，会在当前项目下新建一个laradock项目，执行git status会看到下面两项：123456789$ git statusOn branch masterYour branch is up to date with 'origin/master'.Changes to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) new file: .gitmodules new file: laradock .gitmodules是一个配置文件1234$ cat .gitmodules[submodule \"laradock\"] path = laradock url = https://github.com/Laradock/laradock.git 如果此时，同时修改原项目文件，以及子项目文件，执行git diff12345678910111213141516$ git diffdiff --git a/README.md b/README.mdindex e02af03..a6a0276 100644--- a/README.md+++ b/README.md@@ -1,2 +1,4 @@ # bbs 基于CodeIgniter框架开发的bbs系统++&gt; 新增laradock项目引入diff --git a/laradock b/laradock--- a/laradock+++ b/laradock@@ -1 +1 @@-Subproject commit 66c61d9a72ea52ab04ddb1999b0998f7ba10a0e4+Subproject commit 66c61d9a72ea52ab04ddb1999b0998f7ba10a0e4-dirty 修改submodule需要进入到对应的子项目目录去修改,提交完毕之后，回到父级项目提交。 新clone submodule项目先clone父级项目，然后进入子项目，发现时空文件夹，需要依次执行1234# 在子项目目录git submodule init git submodule update 删除submodulegit 并不支持直接删除Submodule, 需要手动删除对应的文件1234567891011121314151617# 进入父级项目git rm --cached pod-library# 删除子项目rm -rf pod-library# 删除子项目配置文件rm .gitmodules# 更改git的配置文件config:vim .git/config# 删除父级项目git配置中的子项目配置[submodule \"pod-library\"] url = git@github.com:jjz/pod-library.git# 完成新的提交 参考资料：使用Git Submodule管理子模块","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"}]},{"title":"dokcer入门篇","slug":"dokcer入门篇","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2018/06/07/dokcer入门篇/","link":"","permalink":"https://pengwenwu.github.io/2018/06/07/dokcer入门篇/","excerpt":"","text":"阅读《Docker — 从入门到实践》 windows使用 下载docker for windows，安装 使用镜像加速，我自己使用的是阿里云镜像加速setting-&gt;Daemon-&gt;Registry mirrors-&gt;粘贴自己的加速器地址 可以使用gui界面，Kitematic 常用命令获取镜像可以使用docker pull --help查看1234docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]# etcdocker pull ubuntu:16.04 运行1234docker run -it --rm ubuntu:16.04 bash# 查看当前系统版本cat /etc/os-release -it: -i: 交互式操作, -t: 终端 --rm: 执行退出后删除该容器实例 bash: shell使用的方式 镜像列表1234docker image ls# etcREPOSITORY TAG IMAGE ID CREATED SIZE 各列意义：仓库名, 标签, 镜像id, 创建时间, 解压后文件大小镜像ID 则是镜像的唯一标识，一个镜像可以对应多个标签 镜像大小1docker system df 删除镜像1docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] 启动已终止的container镜像1docker [container] start 后台运行容器-d参数能够让容器后台运行，保证输出结果不会打印出来。但容器是否长久运行（一直后台挂起），跟-d参数无关，需要一直有指令执行，才不会“秒退”12345# -c exec执行docker run ubuntu:17.10 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"# 后台运行docker run -d ubuntu:17.10 /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 可以通过docker [container] logs去查看容器输出信息 终止运行1docker [contanier] stop 进入容器1234docker attach # 推荐使用docker exec -it [container id] /bin/bash 两者的区别：前者exit退出后，会停止当前容器；而exec仍然会保持运行 删除容器1234docker container rm # 清楚所有处于终止状态的容器docker container prune commit为什么不建议使用docker commit?使用docker commit提交后，对于其他使用者而言，这个image镜像是一个黑箱，别人无处得知执行过什么命令、如何生成的镜像 Dokcerfile 定制镜像FROM指定基础镜像RUN执行命令 shell格式：RUN &lt;命令&gt; exec格式：RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;] 构建镜像1234docker build [选项] &lt;上下文路径/URL/-&gt;# etc, 注意镜像构建上下文(context)docker build -t nginx:v3 . Dockerfile 指令详解CMD 启动命令CMD 指令就是用于指定默认的容器主进程的启动命令的，也分为shell格式以及exec格式 shell格式：CMD &lt;命令&gt; exec格式：CMD [“可执行文件”, “参数1”, “参数2”…] 参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数 一般推荐使用exec格式，这类格式在解析时会被解析成JSON数组，因此要使用双引号 如果是shell格式，实际会被包装成sh -c的格式1CMD echo $HOME 实际执行会变成：1CMD [ \"sh\", \"-c\", \"echo $HOME\" ] 注意：Docker不是虚拟机，容器中的应用都是前台执行，没有后台服务的概念 错误示范：1CMD service nginx start 这里容器执行后会秒退出，因为上面的命令会被转化为CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start]，主进程是sh，当service nginx start执行结束后，sh也就结束了，sh作为主进程结束，所以容器也会退出 正确做法：1CMD [ \"nginx\", \"-g\", \"daemon off;\" ] 这边执行docker run的时候，不需要再跟/bin/bash启动命令，因为会覆盖。否则就是秒结束进程 ENTRYPOINT 入口点如果指定了ENTRYPOINT，CMD就不会直接执行命令，而是讲内容作为参数传给ENTRYPOINT，实际执行指令会变为：1ENTRYPOINT \"&lt;CMD&gt;\" 场景一：让镜像变成像命令一样使用1docker run myip -i 场景二：应用运行前的准备工作在启动主进程之前，需要一些准备工作，比如数据库的配置、初始化 ENV 设置环境变量两种格式： ENV \\&lt;key> \\&lt;value> ENV \\&lt;key1>=\\&lt;value1> \\=\\&lt;value2> … 123# 含有空格的值使用双引号ENV VERSION=1.0 DEBUG=on \\ NAME=\"Happy Feet\" ARG构建参数格式：ARG &lt;参数名&gt;[=&lt;默认值&gt;] 构建参数和ENV效果一样，都是设置环境变量，唯一的区别是，ARG构建的环境变量，在将来容器运行的时候，不会存储这些环境变量 Dokcerfile中的ARG指令是定义参数名称，以及其默认值。可以通过构建命令docker build中用--build-arg &lt;参数名&gt;=&lt;值&gt;来覆盖 VOLUME 定义匿名卷格式为： VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…] VOLUME &lt;路径&gt; 容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中 1VOLUME /data 这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化 1docker run -d -v mydata:/data xxxx 这里mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置 EXPOSE 声明端口格式为：EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处: 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射 在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口 要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 WORKDIR 指定工作目录格式为: WORKDIR &lt;工作目录路径&gt; 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录 USER 指定当前用户格式：USER &lt;用户名&gt; USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份 HEALTHCHECK 健康检查HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常 格式： HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 ONBUILD格式：ONBUILD &lt;其它指令&gt; NOBUILD指令是别人定制镜像。即使用FROM的时候，才执行的命令 推送镜像12345# 先打标签docker tag ubuntu:17.10 username/ubuntu:17.10# 在pushdocker push username/ubuntu:17.10 配置私有仓库配置私有仓库 数据卷数据卷 是一个可供一个或多个容器使用的特殊目录： 数据卷可以在容器之间共享和重用 对 数据卷 的修改会立马生效 对 数据卷 的更新，不会影响镜像 数据卷 默认会一直存在，即使容器被删除 注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷。 外部访问容器使用- P标记时，Docker会随机映射 49000~49900 的端口到内部容器开放的网络端口 - p可以指定要映射的端口，也可以指定地址ip:hostPort:containerPort 1docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py 查看映射端口配置docker port1docker port nostalgic_morse 5000 容器有自己的内部网络和 ip 地址 -p 标记可以多次使用来绑定多个端口 容器互联查看已有网络1docker network ls 新建网络1docker network create -d bridge my-net -d 可以指定Docker网络类型，有bridge, overlay，其中 overlay 网络类型用于 Swarm mode(集群服务) 连接容器运行一个容器并连接到新建的 my-net 网络123456789101112docker run -it --rm --name busybox1 --network my-net busybox sh# 再运行一个容器docker run -it --rm --name busybox2 --network my-net busybox sh# 测试连接# 在busybox1 容器里，执行# /ping busybox2PING busybox2 (172.19.0.3): 56 data bytes64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.060 ms64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.046 ms64 bytes from 172.19.0.3: seq=2 ttl=64 time=0.075 ms Compose 项目Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。Compose 中有两个重要的概念： 服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。 项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。 Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。 Compose 命令说明命令对象与格式docker-compose 命令的基本的使用格式是:1docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...] 命令选项 -f, –file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。 -p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。 –x-networking 使用 Docker 的可拔插网络后端特性 –x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge –verbose 输出更多调试信息。 -v, –version 打印版本并退出 命令使用说明Tips: 这里的service name是指服务的名称，不是container name 或者 container id build构建（重新构建）项目中的服务容器1docker-compose build [options] [SERVICE...] 服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db选项包括： --force-rm 删除构建过程中的临时容器 --no-cache 构建镜像过程中不使用 cache（这将加长构建过程） --pull 始终尝试通过 pull 来获取更新版本的镜像 config验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因 down此命令将会停止 up 命令所启动的容器，并移除网络 exec进入指定的容器123# 如果执行/bin/bash失败，报错OCI runtime exec failed,是因为bash不存在，替换成sh docker-compose exec web /bin/sh images列出 Compose 文件中包含的镜像 kill格式为 docker-compose kill [options] [SERVICE...] 通过发送 SIGKILL 信号来强制停止服务容器 支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号 1docker-compose kill -s SIGINT logs查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 –no-color 来关闭颜色。 格式为：docker-compose logs [options] [SERVICE...] pause暂停服务格式为：docker-compose pause [SERVICE...] port打印某个容器端口所映射的公共端口 格式为 docker-compose port [options] SERVICE PRIVATE_PORT 选项： –protocol=proto 指定端口协议，tcp（默认值）或者 udp。 –index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1） pspullpushrestartstoprmrun格式为 docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]1docker-compose run ubuntu ping docker.com 默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。 该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。 两个不同点： 给定命令将会覆盖原有的自动运行命令； 不会自动创建端口，以避免冲突。 如果不希望自动启动关联的容器，可以使用 –no-deps 选项，例如:1docker-compose run --no-deps web python manage.py shell 将不会启动 web 容器所关联的其它容器. 选项： -d 后台运行容器。 –name NAME 为容器指定一个名字。 –entrypoint CMD 覆盖默认的容器启动指令。 -e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。 -u, –user=”” 指定运行容器的用户名或者 uid。 –no-deps 不自动启动关联的服务容器。 –rm 运行命令后自动删除容器，d 模式下将忽略。 -p, –publish=[] 映射容器端口到本地主机。 –service-ports 配置服务端口并映射到本地主机。 -T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。 scale设置指定服务运行的容器个数 格式为 docker-compose scale [options] [SERVICE=NUM...] 通过 service=num 的参数来设置数量。例如：1docker-compose scale web=3 db=2 一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。 topunpause启动已暂停的服务 up格式为 docker-compose up [options] [SERVICE...] 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作 链接的服务都将会被自动启动，除非已经处于运行状态 默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试 如果使用 docker-compose up -d，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。 选项： -d 在后台运行服务容器。 –no-color 不使用颜色来区分不同的服务的控制台输出。 –no-deps 不启动服务所链接的容器。 –force-recreate 强制重新创建容器，不能与 –no-recreate 同时使用。 –no-recreate 如果容器已经存在了，则不重新创建，不能与 –force-recreate 同时使用。 –no-build 不自动构建缺失的服务镜像。 -t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒） Compose 模板文件模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 docker run 相关参数的含义都是类似的。 默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。123456789version: '3'services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像 如果使用 build 指令，在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中再次设置。 build指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。 可以使用 context 指令指定 Dockerfile 所在文件夹的路径 使用 dockerfile 指令指定 Dockerfile 文件名 使用 arg 指令指定构建镜像时的变量 使用 cache_from 指定构建镜像的缓存12345build: context: . cache_from: - alpine:latest - corp/web_app:3.14 cap_add, cap_drop指定容器的内核能力（capacity）分配 command覆盖容器启动后默认执行的命令1command: echo \"hello world\" container_name指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式1container_name: docker-web-container 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称 devices指定设备映射关系。12devices: - \"/dev/ttyUSB1:/dev/ttyUSB0\" depends_on解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web1234567891011121314version: '3'services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 注意：web 服务不会等待 redis db 「完全启动」之后才启动。 dns自定义 DNS 服务器。可以是一个值，也可以是一个列表。12345dns: 8.8.8.8dns: - 8.8.8.8 - 114.114.114.114 env_file从文件中获取环境变量，可以为单独的文件路径或列表。 如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径 如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准 123456env_file: .envenv_file: - ./common.env - ./apps/web.env - /opt/secrets.env 环境变量文件中每一行必须符合格式，支持 # 开头的注释行。12# common.env: Set development environmentPROG_ENV=development environment设置环境变量。可以使用数组或字典两种格式 只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据 1234567environment: RACK_ENV: development SESSION_SECRET:environment: - RACK_ENV=development - SESSION_SECRET 如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。 expose暴露端口，但不映射到宿主机，只被连接的服务访问 仅可以指定内部端口为参数 123expose: - \"3000\" - \"8000\" image指定为镜像名称或镜像 ID 读取变量Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。 例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。 12345version: \"3\"services:db: image: \"mongo:$&#123;MONGO_VERSION&#125;\" 如果执行 MONGO_VERSION=3.2 docker-compose up 则会启动一个 mongo:3.2 镜像的容器；如果执行 MONGO_VERSION=2.8 docker-compose up 则会启动一个 mongo:2.8 镜像的容器。 若当前目录存在 .env 文件，执行 docker-compose 命令时将从该文件中读取变量。 在当前目录新建 .env 文件并写入以下内容。12# 支持 # 号注释MONGO_VERSION=3.6 执行 docker-compose up 则会启动一个 mongo:3.6 镜像的容器。 附录常见问题总结常见问题总结 资源链接资源链接 进阶深入进阶深入，参考原文档《Docker — 从入门到实践》","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://pengwenwu.github.io/tags/Docker/"}]},{"title":"js和php闭包使用和区别","slug":"js和php闭包使用和区别","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2018/05/25/js和php闭包使用和区别/","link":"","permalink":"https://pengwenwu.github.io/2018/05/25/js和php闭包使用和区别/","excerpt":"","text":"匿名函数 如果只是省去函数名，单纯的当作一个函数式方法返回，只能称为匿名函数（闭包需要将匿名函数当作结果返回），比如： 12345// jsvar foo = function(x, y) &#123; return x + y ;&#125;;console.log(foo(1, 2)); // 3 123456&lt;?php// php$foo = function($a, $b) &#123; return $a + $b;&#125;; // 一定要加分号echo $foo(1, 2); // 3 闭包 闭包通常是用来创建内部变量，使得这些变量不得被外部随意修改，而只能通过指定的函数接口去修改 js闭包这里举一个阮老师博客里的例子，阮老师博客：学习Javascript闭包（Closure） js基础参考链接：深入理解JS中声明提升、作用域（链）和this关键字 js比较特殊的一点是：函数内部可以直接读取到全局变量（对于阮老师的这句话不是很能理解，大概是想表达的意思：父作用域的变量可以在子作用域直接访问，而不需要去声明访问真正的全局变量？） 大部分语言，变量都是先声明在使用，而对于js，具有声明提升的特性（不管在哪里声明，都会在代码执行前处理） 函数和变量的声明总是会隐式地被移动到当前作用域的顶部，函数的声明优先级高于变量的声明 var 会在当前作用域声明一个变量，而未声明的变量，会隐式地创建一个全局变量 123// 声明提升console.log(a); // 1, 未报错var a = 1; 123456789101112131415161718192021// 上文链接中的例子function testOrder(arg) &#123; console.log(arg); // arg是形参，不会被重新定义 console.log(a); // 因为函数声明比变量声明优先级高，所以这里a是函数 var arg = 'hello'; // var arg;变量声明被忽略， arg = 'hello'被执行 var a = 10; // var a;被忽视; a = 10被执行，a变成number function a() &#123; console.log('fun'); &#125; // 被提升到作用域顶部 console.log(a); // 输出10 console.log(arg); // 输出hello&#125;; testOrder('hi');/* 输出：hi function a() &#123; console.log('fun'); &#125;10 hello */ 12345678// 全局作用域var foo = 42;function test() &#123; // 局部作用域 foo = 21;&#125;test();foo; // 21 12345678// 全局作用域foo = 42;function test() &#123; // 局部作用域 var foo = 21;&#125;test();foo; // 42 js变量的查找是从里往外的，直到最顶层（全局作用域），并且一旦找到，即停止向上查找。所有内部函数可以访问函数外部的变量，反之无效 12345678function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log(a, b, c); &#125; bar(b * 3);&#125;foo(2); 1234function foo() &#123; var a = 1;&#125;console.log(a); //a is not defined 123456789101112131415function foo1() &#123; var num = 0; addNum = function() &#123; // 这里未通过var去声明，默认是全局变量 num += 1; &#125;; function foo2() &#123; console.log(num); &#125; return foo2;&#125;var tmp = foo1();tmp(); // 0addNum();tmp(); // 1 这里第二次调用foo2函数，foo1函数的局部变量num并没有被初始化为0，说明打印的是内存中的num。正常函数在每次调用结束后都会销毁局部变量，在重新调用的时候会再次声明变量；而这边没有重新声明的原因是：把foo2函数赋值给了一个全局变量tmp，导致foo2函数一直存在内存中，而foo2函数依赖于foo1函数存在，所以foo1函数也存在内存中，并没有被销毁，所以foo1的局部变量也是存在内存中。 this的上下文基于函数调用的情况。和函数在哪定义无关，而和函数怎么调用有关。 在全局上下文（任何函数以外），this指向全局对象(windows) 在函数内部时，this由函数怎么调用来确定 当函数作为对象方法调用时，this指向该对象 下面是阮老师博客里的两个思考题： 12345678910var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); // The Window 1234567891011var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()());// My Object this的作用域好像一直是个比较奇怪的东西，对于上面两个例子，我的理解是：第一个例子，是在方法里调用的this，而这个this并没有声明，会隐式地创建一个全局变量，所以调用的全局的name；第二个，调用的that的时候，会向顶级链式查找是否声明that，而这个that有this赋值，这里的this又是通过对象方法调用，则该this指向这个object对象，所有最终调用的是object作用域内的name。不知道这么理解是不是有问题，还望大神指正。 那其实js闭包的主要目的：访问函数内部的局部变量，即延长作用域链参考链接：js闭包MDN文档 php闭包php回调函数[mixed call_user_func ( callable $callback , mixed $parameter [, mixed $… ]] )mixed call_user_func_array ( callable $callback , array $param_arr ) 这两个函数都是把第一个参数作为回调函数d调用，后面接收参数，区别就是第二个函数第二参数接收数组；在使用上唯一的区别就是，call_user_func函数无法接收引用传递; 个人觉得同样是使用，call_user_func 相比call_user_func_array完全可以被替代，不知道是不是有一些性能上的优势。具体使用样例，请参考官方文档。 123456789&lt;?php// 引用传递function foo(&amp;$a, &amp;$b) &#123; $a ++; $b --;&#125;;$a = $b = 10;call_user_func_array('foo', [&amp;$a, &amp;$b]);echo $a.\"\\n\", $b; // 11, 9 基本用法基本用法，跟js的闭包类似 普通调用 123456&lt;?phpglobal $tmp = 'hello world';function foo() &#123; var_dump(global $tmp);&#125;foo(); // null, 函数内部无法直接调用上级作用域的变量，除非声明为全局变量 12345678910&lt;?php$foo1 = function() &#123; $a = 10; $foo2 = function() &#123; var_dump($a); &#125;; return $foo2;&#125;;$tmp = $foo1();$tmp(); // null，原因同上 php想要能够获取上级作用域的变量，需要通过use传递 123456789101112&lt;?php$foo1 = function () &#123; $a = 10; $foo2 = function () use ($a) &#123; var_dump($a); $a ++; &#125;; $foo2(); return $foo2;&#125;;$tmp = $foo1();$tmp(); // 10, 10, use并不能实际改变变量的值，只是值传递 123456789101112&lt;?php$foo1 = function () &#123; $a = 10; $foo2 = function () use (&amp;$a) &#123; var_dump($a); $a ++; &#125;; $foo2(); return $foo2;&#125;;$tmp = $foo1();$tmp(); // 10, 11, 通过值传递改变变量的值 下面两段代码的区别，不是很明白，望大佬指点，为什么后一个值传递就可以获取到已经改变后变量的值。好像都是在调用方法之前，已经执行过变量的递增了吧？ 123456789101112&lt;?php// 值传递$foo1 = function () &#123; $a = 10; $foo2 = function () use ($a) &#123; var_dump($a); &#125;; $a ++; return $foo2;&#125;;$tmp = $foo1();$tmp(); // 10 123456789101112&lt;?php// 引用传递$foo1 = function () &#123; $a = 10; $foo2 = function () use (&amp;$a) &#123; var_dump($a); &#125;; $a ++; return $foo2;&#125;;$tmp = $foo1();$tmp(); // 11 正确使用 1234567891011&lt;?php// 值传递$foo = function () &#123; $a = 10; $foo2 = function ($num) use ($a) &#123; var_dump($num + $a); &#125;; return $foo2;&#125;;$tmp = $foo();$tmp(100); // 110 1234567891011121314&lt;?php// 引用传递$foo = function () &#123; $a = 10; $foo2 = function ($num) use (&amp;$a) &#123; var_dump($num + $a); $a ++; &#125;; return $foo2;&#125;;$tmp = $foo();$tmp(100); // 110$tmp(100); // 111$tmp(100); // 112 跟js类似，保证变量常驻内存 php Closure 类 Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域public static Closure Closure::bind ( Closure $closure , object $newthis [, mixed $newscope = ‘static’ ] ) Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域public Closure Closure::bindTo ( object $newthis [, mixed $newscope = ‘static’ ] )对这两个方法不是很能理解。。。求指教 共同点都是为了扩展作用域，获取内部变量 区别js能够在方法内部直接获取到父级作用域的变量，而php需要通过use声明，并且默认是值传递 应用场景 不是很能理解应用场景，搜索了一下，很多只是写了一个闭包实现的购物车，感觉并不是那么的实用。 如果只是单纯的使用匿名函数，感觉还不如封装成一个私有方法 这些只是个人粗鄙的理解，望指正.","categories":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"JS","slug":"JS","permalink":"https://pengwenwu.github.io/tags/JS/"},{"name":"闭包","slug":"闭包","permalink":"https://pengwenwu.github.io/tags/闭包/"}]},{"title":"phpstorm或vscode使用psr2规范","slug":"phpstorm或vscode使用psr2规范","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2018/05/14/phpstorm或vscode使用psr2规范/","link":"","permalink":"https://pengwenwu.github.io/2018/05/14/phpstorm或vscode使用psr2规范/","excerpt":"","text":"安装composer 全局安装phpcs 1composer global require squizlabs/php_codesniffer vscode直接插件搜索phpcs安装phpstorm全局安装phpcs后，会在C:\\Users{user name}\\AppData\\Roaming\\Composer\\vendor\\bin下生成一个phpcs.bat，后面会用到 phpstorm -&gt; setting languages &amp; Frameworks-&gt;PHP-&gt;Code Sniffer点击Configuration右侧的按钮 找到刚才的phpcs.bat，点击Validate，确认 Editor-&gt;Inspection-&gt;PHP 双击PHP Code Sniffer validation，点击Coding standard右侧的刷新按钮，然后选择psr2，确定 参考链接: 如何优雅地使用phpstorm?","categories":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"PSR","slug":"PSR","permalink":"https://pengwenwu.github.io/tags/PSR/"}]},{"title":"array_map, array_walk, array_filter的区别及使用","slug":"array-map-array-walk-array-filter的区别及使用","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2018/05/13/array-map-array-walk-array-filter的区别及使用/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/array-map-array-walk-array-filter的区别及使用/","excerpt":"","text":"array_map, array_walk, array_filter的区别及使用 12345678910111213141516171819202122232425262728&lt;?php// array_map, array_walk, array_filter的区别$arr = [1, 2, 3, 4];function foo($value)&#123; return $value * $value;&#125;function filter($value)&#123; return $value &gt; 2;&#125;function walk(&amp;$value)&#123; $value = $value * $value;&#125;// array_map 会返回新的数组, 不对原数组产生影响$new_arr = array_map('foo', $arr);echo '原数组:'.var_export($arr, 1).\"\\n\", 'array_map修改后的数组：'.var_export($new_arr, 1).\"\\n\".\"&lt;hr/&gt;\";// array_walk 返回bool值，callback需要通过值传递改变原有数组$res = array_walk($arr, 'walk');echo '修改后的数组:'.var_export($arr, 1).\"\\n\", 'array_walk返回结果：'.var_export($res, 1).\"\\n\".\"&lt;hr/&gt;\";// array_filter 返回筛选后的新数组，不对原数组产生影响$new_arr = array_filter($arr, 'filter');echo '原数组:'.var_export($arr, 1).\"\\n\", 'array_filter返回结果：'.var_export($new_arr, 1).\"\\n\".\"&lt;hr/&gt;\";","categories":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"}]},{"title":"windows下cmd/powershell中文乱码解决方法","slug":"windows下cmd-powershell中文乱码解决方法","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/05/13/windows下cmd-powershell中文乱码解决方法/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/windows下cmd-powershell中文乱码解决方法/","excerpt":"","text":"windows下cmd或者powershell运行php文件中文乱码 解决方法执行下面的命令，切换成utf-8编码 chcp 65001 这个指标不治本，查了说是可以修改注册表，但是好像又会带来其他的坑（中文软件乱码、nodejs乱码），未测试过，不予评价。参考链接：https://www.zhihu.com/question/54724102","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://pengwenwu.github.io/categories/环境配置/"}],"tags":[{"name":"中文乱码","slug":"中文乱码","permalink":"https://pengwenwu.github.io/tags/中文乱码/"}]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2018/05/13/hexo常用命令/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/hexo常用命令/","excerpt":"","text":"hexo常用命令123456hexo n &quot;博客名称&quot; =&gt; hexo new &quot;博客名称&quot; hexo clean # 清楚缓存hexo g =&gt; hexo generate #生成hexo p =&gt; hexo publish # 发布hexo s =&gt; hexo server #启动服务预览hexo d =&gt; hexo deploy #部署 发布流程123hexo cleanhexo ghexo d","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"https://pengwenwu.github.io/tags/Hexo/"}]},{"title":"git reset 和 revert 的区别和使用","slug":"git-reset-和-revert-的区别和使用","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/05/13/git-reset-和-revert-的区别和使用/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/git-reset-和-revert-的区别和使用/","excerpt":"","text":"git revert 撤销某次提交, 保留之前的commit, 同时创建一个新的commit(可用于公共分支)git reset 撤销某个提交， 删除之前的commit, head回退 (多用于私有分支)区别: git revert 只是撤销某个commit, 保留该commit之前的提交结果 DEMO commit3: add log3commit2: add log2commit1: add log1 HEAD用法 HEAD^: 指向上一次commit HEAD~100: 指向前第一百个commit HEAD commit_id: 直接指向某个commit –soft、–mixed(默认)、–hard的区别 –soft: 只是重置HEAD到某一个commit, 其余不会有任何变化(缓存区和工作目录都不会被改变) –mixed(默认): 重置HEAD, 文件修改都将保存到缓存区(缓存区和你指定的提交同步，但工作目录不受影响) –hard: 修改当前所有内容, 所有本地修改都将丢失(缓存区和工作目录都同步到你指定的提交). 找回执行命令: git reflow","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"}]},{"title":"git pull更新指定文件","slug":"git-pull更新指定文件","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/05/13/git-pull更新指定文件/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/git-pull更新指定文件/","excerpt":"","text":"经常会遇到，几个文件一起提交了，但是某些文件是要先执行的，不然一起pull下来会加载报错 更新git指定文件git fetchgit checkout origin/master – path/to/file","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"}]},{"title":"阅读《微服务设计》笔记","slug":"阅读《微服务设计》笔记","date":"un66fin66","updated":"un44fin44","comments":true,"path":"2018/03/03/阅读《微服务设计》笔记/","link":"","permalink":"https://pengwenwu.github.io/2018/03/03/阅读《微服务设计》笔记/","excerpt":"","text":"记录阅读《微服务设计》收获的点 什么是微服务？一些协同工作的小而自治的服务 打破外键关系对于有外键关系的表如何做服务拆分？通过api调用访问 优点：数据表拆分，进而服务拆分 缺点：增加了数据库的调用，会影响性能。需要测试是否在可接受范围内，权衡拆分服务带来的好处 共享表拆分共享表拆分后，如何保证插入数据的一致性？设计之初为了减少数据库的调用，必然会建立基于外键的共享表。拆分之后，如何保证同时插入多张表数据的一致性？（某张表插入失败） 通过事务处理 推荐对及时性较弱的操作，异常捕获后放入队列或者日志文件中进行延迟处理，保证最终一致性 终止整个操作，再发起补偿事务来抵消之前的操作（自动化处理） 分布式事务。通过专门的事务管理器工具来协调底层事务（不推荐，易出错，难扩展） 阅读完感觉云里雾里，可能是自己的水平还没到达那个深度。收获大概是：了解了后端的架构，后期拓展可能会遇到的问题，以及解决这样问题的思路。","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://pengwenwu.github.io/tags/微服务/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2018/01/21/Linux常用命令/","link":"","permalink":"https://pengwenwu.github.io/2018/01/21/Linux常用命令/","excerpt":"","text":"记录一些阅读《鸟哥的Linux私房菜-基础学习篇》中不太熟悉的命令 软连接、硬链接 软连接：连接文件的内容只会写上目标文件的“文件名”，实际是通过记录的目标文件地址去访问实际存储内容。大小就是文件名大小。如果删除目标文件，则当前文件无法访问。(等同于windows的快捷方式) 硬连接：只能针对单个文件，实际会创建一个一模一样的“文件”(权限、大小)，连接数增加。连接到同一个地址，只是使用了不同的文件名，均可以对源文件进行数据修改，删除任意一个，不影响其余文件访问 12345cp -s test test1 ln -s test test1 # 软连接(快捷方式)cp -l demo.php demo1.php ln -l demo.php demo1.php # 硬链接(只支持单个文件) 查看分区1fdisk -l 解压缩123#-z gzip压缩，-j bzip2压缩tar -zcvf [newfilename] filename tar -zxvf filename.tar.gz [-C 目录] 解压要到指定目录 查看命令1type name 命名别名1234alias rm=&apos;rm -i&apos;alias st=&apos;status&apos;unalias rm #取消别名 数据流重定向 标准输入：&lt;或&lt;&lt; (将由键盘输入的数据由文件代替/结束输入)标准输出：&gt;或&gt;&gt; (覆盖/追加)标准错误输出：2&gt;或2&gt;&gt; (覆盖/追加) 1234cat &gt; catfile &lt;&lt; eof&gt;This is a test.&gt;Ok now stop&gt;eof 命令执行判断：; || &amp;&amp;12345678910#依次执行echo 1; echo 2; echo 3 #若cmd1正确执行，则开始执行cmd2#若cmd1执行错误，则cmd2不执行cmd1 &amp;&amp; cmd2 #若cmd1正确执行，则不执行cmd2#若cmd1执行错误，则开始执行cmd2cmd1 || cmd2 选取命令：cut, grep cut: -d：分割字符，与-f一起用 -f：取出第几段 -c：取出固定字符区间 12345# 列出第三段，第五段echo $PATH | cut -d &apos;:&apos; -f 3,5 # 取得第5字符之后echo $PATH | cut -c 5- 排序命令:sort, wc, uniq sort [-fbMnrtuk]uniq [-ic]-c：进行计数 12# 每个人登录的次数last | cut -d &apos; &apos; -f 1 | sort | uniq -c wc [-lwm]-l：仅列出行-w：仅列出多少字-m：多少字符","categories":[{"name":"Linux","slug":"Linux","permalink":"https://pengwenwu.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://pengwenwu.github.io/tags/Linux/"}]},{"title":"hexo + github搭建个人博客教程","slug":"hexo + github搭建个人博客教程","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2018/01/14/hexo + github搭建个人博客教程/","link":"","permalink":"https://pengwenwu.github.io/2018/01/14/hexo + github搭建个人博客教程/","excerpt":"","text":"前言一年前，临近毕业。为了准备面试，才刻意去准备了github以及blog。自从找到工作后，这两个基本没怎么维护过，想想未免太功利了点。 主要是前几天，又踩到坑了，想去找以前的记录，很麻烦。之前虽然每天都会写工作总结，一些踩过的坑记在为知笔记上，没有分类、标签，后面再想去找很困难。痛定思痛，该记的东西少不掉，索性优雅一点。 之前用的是博客园，但是那个账号密码老记不住，干脆自己搭建一个吧，好歹也是一个码农。然后花了两个晚上加一个上午，通过hexo和github搭建了一个个人博客。网上教程、文档那么多，为什么花这么久时间？当然是踩坑了啊。所以下面会记录一些遇到的问题和坑。如果你看完这边文章，那你只需要两个小时就能搭建成功。欢迎有兴趣的小伙伴尝试一下。 正文环境准备 node.js git 这两个应用windows用户直接搜索下载安装就可以。如果习惯了使用linux命令的朋友，推荐windows神器cmder。可以直接在windows环境下使用linux命令，样式可调，再也不要用黑乎乎的cmd了，而且自带git，完全可以不用下载windows git。 正式安装hexohexo官方中文文档 在node.js安装好的前提下，全局安装hexo如何判断node.js是否安装成功？执行以下命令，如果能够看到版本号则说明安装成功了1node -v 安装hexo1npm install -g hexo-cli 自选合适的目录，新建文件夹&lt;folder&gt;123cd &lt;folder&gt;hexo initnpm install 不再赘述，直接看官方文档。 配置github新建仓库，仓库名必须为[your_name.github.io] 补充：本地配置github ssh连接，方便自动部署，以及clone你喜欢的主题(theme) windows用户直接在c:/用户/youername/.ssh/下查看是否有id_rsa.pub文件。没有的话命令行执行命令ssh-keygen -t rsa -C &quot;your eamil&quot;，会自动生成id_rsa.pub文件，打开后复制。 github-&gt;头像-&gt;Settings→SSH kyes→Add SSH key，粘贴复制的内容。 配置本地账户12git config --global user.name “your_username” #设置用户名git config --global user.email “your_email” #设置邮箱地址,最好使用注册邮箱地址 测试是否配置成功1ssh -T git@github.com hexo配置以及使用有两个配置文件： 一个是根目录下的_config.yml称为站点配置文件 一个是themes/landscape/_config.yml称为主题配置文件(默认主题：landscape) 站点配置如下： 1234567url: https://yourname.github.io/theme: landscape #选择你想用的主题，我用的是indigodeploy: type: git # 不要使用github repo: git@github.com:pengwenwu/pengwenwu.github.io.git # 使用ssh连接 branch: master # 默认master分支 message: add new blog # 自动部署commit备注，可不填 hexo常用命令hexo命令参考 hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate #生成hexo s == hexo server #启动服务本地预览hexo d == hexo deploy #部署hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP 在执行之前，记得安装自动部署 (–save 加不加的区别在于是否写入到依赖文件package.json中)1npm install hexo-deployer-git --save 正常本地预览，直接执行hexo s,如果要发布话最好执行clean命令，会去删除生成的public文件，完整部署命令:hexo clean &amp;&amp; hexo g &amp;&amp; hexo d。或者直接hexo d -g 注意问题安装完自动部署后，是不需要本地git init新建仓库的。执行hexo g会在根目录生成public文件夹，自动部署，本质是将public文件夹内容全部提交到仓库中去，默认会访问编译好的index.html。 如果部署完，访问your_name.github.io 404,可能有下面几个原因 首先检查仓库文件，是不是全都是public的文件内容，如果整个本地blog文件夹都提交了，首先清空仓库，然后删除本地.deploy_git文件夹，再重新部署 文件有报错，本地hexo s观察是否有报错。 不喜欢原主题的朋友，可以github去找喜欢的主题。执行命令1git clone XXXX.next.git themes\\next 这个会将新的主题下载到themes下对应的next目录，next为主题的名字。 主题的配置，可以看文档，修改对应的主题配置文件。我使用的主题是indigo,详细文档indigo markdown不会使用的朋友，参考链接markdown中文文档如果没有ide的话，可以使用在线预览Cmd Markdown","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://pengwenwu.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://pengwenwu.github.io/tags/Github/"}]},{"title":"如何将一个数组乱序？","slug":"如何将一个数组乱序？","date":"un66fin66","updated":"un00fin00","comments":true,"path":"2018/01/13/如何将一个数组乱序？/","link":"","permalink":"https://pengwenwu.github.io/2018/01/13/如何将一个数组乱序？/","excerpt":"","text":"这是很久以前博客园的博客，打个小样。 前几天php实习面试，问到一个问题：如何将一个数组乱序？答：使用自带的array_rand()或者shuffle()函数，或者用随机数取值赋值给新的数组。又问：万一一直随机到同一个数怎么办？那就进行判断，如果已经取过的位置，重新选取随机数。这样问题就来了：随着新数组长度增加，原数组中的随机数选取碰撞几率会原来越大，最后几乎是一直碰撞的。也没有想出更好的办法。 后来回家后查了一下，总结一下，有以下几种方法： 使用自带的函数 12345678function shuffle_rand1($arr)&#123; echo \"原来数组为：\"; print_r($arr); shuffle($arr); echo \"&lt;br&gt;乱序数组为：\"; print_r($arr);&#125; 第一时间想到的方法，就是随机取值，赋值给新的数组 12345678910111213141516171819function shuffle_rand2($arr)&#123; echo \"原来数组为：\"; print_r($arr); $len = count($arr); $shuffle_arr = array(); while(count($shuffle_arr)&lt;$len)&#123; $index = rand(0,$len-1); if(!in_array($index, $shuffle_arr))&#123; $shuffle_arr[] = $index; &#125; &#125; $newarr = array(); foreach ($shuffle_arr as $v) &#123; $newarr[] = $arr[$v]; &#125; echo \"&lt;br&gt;新的数组为：\"; print_r($newarr);&#125; 数组中随机取一个元素赋值给新的数组，然后将原数组最后一位赋值到该位置,数组长度减一，继续重复上述步奏 123456789101112131415function shuffle_rand3($arr)&#123; echo \"原来数组为：\"; print_r($arr); $len = count($arr); $shuffle_arr = array(); while($len&gt;0)&#123; $index = rand(0,$len-1); $shuffle_arr[] = $arr[$index]; $arr[$index] = $arr[$len-1]; $len--; &#125; echo \"&lt;br&gt;新的数组为：\"; print_r($shuffle_arr);&#125; 在具有n个元素的数组中，对0到n-1一次进行与一个随机位置元素进行交换,这种方法不需要新建一个数组，直接在原数组中进行 12345678910111213function shuffle_rand4($arr)&#123; echo \"原来数组为：\"; print_r($arr); $len = count($arr); for($i=0;$i&lt;$len;$i++)&#123; $index = rand(0,$len-1); $temp = $arr[$i]; $arr[$i] = $arr[$index]; $arr[$index] = $temp; &#125; echo \"&lt;br&gt;新的数组为：\"; print_r($arr);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://pengwenwu.github.io/categories/算法/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"算法","slug":"算法","permalink":"https://pengwenwu.github.io/tags/算法/"}]}]}