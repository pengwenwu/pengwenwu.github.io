{"meta":{"title":"Pena's Blog","subtitle":"莫道君行早，更有早行人","description":"pengwenwu的个人博客","author":"pengwenwu","url":"https://pengwenwu.github.io"},"pages":[{"title":"categories","date":"un55fin55","updated":"un00fin00","comments":true,"path":"categories/index.html","permalink":"https://pengwenwu.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"un55fin55","updated":"un00fin00","comments":true,"path":"tags/index.html","permalink":"https://pengwenwu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PHP引用","slug":"PHP引用","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2018/07/05/PHP引用/","link":"","permalink":"https://pengwenwu.github.io/2018/07/05/PHP引用/","excerpt":"","text":"官方文档 引用是什么 引用不是什么 引用做什么 引用传递 引用返回 php引用1. 变量的引用php的引用允许两个变量指向同一个内容1234567&lt;?php$a = 10;$b =&amp; $a;echo $a, $b; // 10, 10$b = 20;echo $a, $b; // 20, 20 2. 函数的引用传递1234567891011&lt;?phpfunction foo(&amp;$var)&#123; $var++;&#125;$a=5;foo($a); // 6foo($a); // 7echo $a; // 7 3. 函数的引用返回12345678910111213141516&lt;?phpfunction &amp;test()&#123; static $b = 0;//申明一个静态变量 $b = $b + 1; echo $b; return $b;&#125;$a = test();//这条语句会输出 $b的值 为１$a = 5;$a = test();//这条语句会输出 $b的值 为2$a =&amp; test();//这条语句会输出 $b的值 为3$a = 5;$a = test();//这条语句会输出 $b的值 为6 没有加&amp;, 跟普通的函数调用没有区别。 而引用返回的作用，相当于把$b的内存地址返回，赋值给$a，使得$a, $b的内存地址指向同一个地方，即相当于执行了($a =&amp; $b;) 更多的是使用在对象中：12345678910111213141516171819&lt;?phpclass Foo&#123; public $value = 42; public function &amp;getValue() &#123; return $this-&gt;value; &#125;&#125;$obj = new Foo;$myValue = &amp;$obj-&gt;getValue();echo $myValue; // 42;$obj2 = new Foo;$obj2-&gt;value = 2;$myValue =&amp; $obj2-&gt;getValue();echo $myValue; // 2 写时复制php一个比较重要的内部机制是写时复制12345&lt;?php$a = 10;$b = $a; // 此时$b, $a 指向同一地方$b = 20; // 在写入时，才会给$b 额外分配存储空间 性能优化本来之前了解的，使用引用传递能够提高运行效率，本机测试也是能提高30%左右。不过看这篇文章，介绍引用坑大于利，所以不再推荐。文章地址：https://zhuanlan.zhihu.com/p/35107602 参考文章：https://www.cnblogs.com/xiaochaohuashengmi/archive/2011/09/10/2173092.html","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"}]},{"title":"PHP静态变量","slug":"PHP静态变量","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2018/07/03/PHP静态变量/","link":"","permalink":"https://pengwenwu.github.io/2018/07/03/PHP静态变量/","excerpt":"","text":"通常意义上的静态变量是静态分配，他们的生命周期和程序的生命周期一样，只有在程序退出的时候才结束生命周期。 php的静态变量可以分为： 静态全局变量：php中的全局变量也可以理解为静态全局变量，因为除非明确unset释放，在程序运行过程中始终存在 静态局部变量：即函数内定义的静态变量，函数在执行时对变量的操作会保持到下一次函数执行，直到程序终止 静态成员变量：在类中定义的静态变量，和实例变量相对应，静态成员变量可以在所有实例中共享 静态局部变量1234567891011&lt;?phpfunction test()&#123; static $b = 0; $b = $b + 1; echo $b; return $b;&#125;test(); // 1test(); // 2test(); // 3 静态变量只能被初始化一次12345678&lt;?phpstatic $a = 0;$a = 10;var_dump($a); // 10static $a = 0;var_dump($a); // 10 静态成员变量12345678910111213&lt;?phpclass Foo&#123; public static $a = 1;&#125;$foo1 = new Foo();echo $foo1::$a; // 1$foo2 = new Foo();echo $foo2::$a; // 1echo FOO::$a; // 1 修改静态成员变量12345678910111213141516&lt;?phpclass Foo&#123; public static $a = 1;&#125;$foo1 = new Foo();echo $foo1::$a; // 1$foo1::$a = 2;echo $foo1::$a; // 2$foo2 = new Foo();echo $foo2::$a; // 2echo FOO::$a; // 2 参考链接：《深入理解PHP内核 - 静态变量》","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"}]},{"title":"CI框架3.x源码阅读笔记-1","slug":"CI框架3.x源码阅读笔记-1","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2018/07/02/CI框架3.x源码阅读笔记-1/","link":"","permalink":"https://pengwenwu.github.io/2018/07/02/CI框架3.x源码阅读笔记-1/","excerpt":"","text":"当前框架版本define(‘CI_VERSION’, ‘3.0.2’); 入口文件index.php1234567# 对比项目跟原框架增加下列代码include_once dirname(__FILE__) . '/../etc/environment.php';.........include_once dirname(__FILE__) . '/../vendor/autoload.php';include_once dirname(__FILE__) . '/../etc/load_all.php'; 加载环境配置文件通过environment文件判断并设置当前的环境1include_once dirname(__FILE__) . '/../etc/environment.php'; 通过修改apache或nginx配置，设置环境变量 1234567# apache# SetEnv key=valueSetEnv CI_ENV development_beta# nginx# key valuefastcgi_param CI_ENV beta; 在通过cli运行时，通过$_SERVER[&#39;argv&#39;]获取传递给脚本的参数数组，第一个肯定为当前脚本名。 加载composer各种包的加载1include_once dirname(__FILE__) . '/../vendor/autoload.php'; 其余初始化的文件加载包括一些监控、报警、调用链追踪1include_once dirname(__FILE__) . '/../etc/load_all.php'; 加载核心文件1require_once BASEPATH.'core/CodeIgniter.php';","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"CodeIgniter","slug":"CodeIgniter","permalink":"https://pengwenwu.github.io/tags/CodeIgniter/"}]},{"title":"workerman入门","slug":"workerman入门","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2018/06/27/workerman入门/","link":"","permalink":"https://pengwenwu.github.io/2018/06/27/workerman入门/","excerpt":"","text":"由于php不像nodejs、java一样可以常驻内存，没有现成的websock io，需要通过原生的php socket去实现服务端websocket的通信。对于菜鸟而言，还是使用现成的框架更方便，等水平足够了，才需要去考虑这些底层的实现 什么是workerman？Workerman是一款纯PHP开发的开源高性能的PHP socket 服务器框架。本身是一个PHP多进程服务器框架，具有PHP进程管理以及socket通信的模块，所以不依赖php-fpm、nginx或者apache等这些容器便可以独立运行。 官网：http://www.workerman.net/workermanworkerman手册：http://doc.workerman.net/640361 特性 纯PHP开发 支持PHP多进程 支持TCP、UDP 支持长连接 支持各种应用层协议 支持高并发 支持服务平滑重启 支持文件更新检测及自动加载 支持以指定用户运行子进程 支持对象或者资源永久保持 高性能 支持HHVM 支持分布式部署 支持守护进程化 支持多端口监听 支持标准输入输出重定向 环境要求Linux用户(含Mac OS) 安装PHP&gt;=5.3.3，并安装了pcntl、posix扩展 建议安装event或者libevent扩展，但不是必须的（注意event扩展需要PHP&gt;=5.4） Linux环境检查脚本1curl -Ss http://www.workerman.net/check.php | php 如果脚本中全部提示ok，则代表满足WorkerMan运行环境 注意：检测脚本中没有检测event扩展或者libevent扩展，如果并发连接数大于1024建议安装event扩展或者libevent扩展 如何安装扩展参考文档：http://doc.workerman.net/appendices/install-extension.html 入门安装普通安装可以参照官网，通过git下载 也可以通过composer安装1composer require workerman/workerman 开发实例websocket实例服务端实现12345678910111213141516171819&lt;?phprequire_once './vendor/autoload.php';use Workerman\\Worker;// 注意：这里与上个例子不同，使用的是websocket协议$ws_worker = new Worker(\"websocket://0.0.0.0:9501\");// 启动4个进程对外提供服务$ws_worker-&gt;count = 4;// 当收到客户端发来的数据后返回hello $data给客户端$ws_worker-&gt;onMessage = function ($connection, $data) &#123; // 向客户端发送hello $data $connection-&gt;send('hello ' . $data);&#125;;// 运行workerWorker::runAll(); 客户端实现123456789ws = new WebSocket(\"ws://127.0.0.1:9501\");ws.onopen = function() &#123; console.log(\"连接成功\"); ws.send('tom'); console.log(\"给服务端发送一个字符串：tom\");&#125;;ws.onmessage = function(e) &#123; console.log(\"收到服务端的消息：\" + e.data);&#125;; 启动与停止启动以debug(调试)方式启动1php start.php start 以daemon(守护进程)方式启动1php start.php start -d 停止1php start.php stop 重启1php start.php restart 平滑重启1php start.php reload 查看状态1php start.php status 查看连接状态1php start.php connections debug和daemon方式区别 以debug方式启动，代码中echo、var_dump、print等打印函数会直接输出在终端 以daemon方式启动，代码中echo、var_dump、print等打印会默认重定向到/dev/null文件，可以通过设置Worker::$stdoutFile = &#39;/your/path/file&#39;;来设置这个文件路径 以debug方式启动，终端关闭后workerman会随之关闭并退出 以daemon方式启动，终端关闭后workerman继续后台正常运行 什么是平滑重启？平滑重启不同于普通的重启，平滑重启可以做到在不影响用户的情况下重启服务，以便重新载入PHP程序，完成业务代码更新。 平滑重启一般应用于业务更新或者版本发布过程中，能够避免因为代码发布重启服务导致的暂时性服务不可用的影响。 注意：只有子进程运行过程中载入的文件支持reload，主进程载入的文件不支持reload。或者说Worker::runAll执行完后workerman运行过程中动态加载的文件支持reload，Worker::runAll执行前就载入的文件代码不支持reload 平滑重启原理WorkerMan分为主进程和子进程，主进程负责监控子进程，子进程负责接收客户端的连接和连接上发来的请求数据，做相应的处理并返回数据给客户端。当业务代码更新时，其实我们只要更新子进程，便可以达到更新代码的目的。 当WorkerMan主进程收到平滑重启信号时，主进程会向其中一个子进程发送安全退出(让对应进程处理完毕当前请求后才退出)信号，当这个进程退出后，主进程会重新创建一个新的子进程（这个子进程载入了新的PHP代码），然后主进程再次向另外一个旧的进程发送停止命令，这样一个进程一个进程的重启，直到所有旧的进程全部被置换为止。 我们看到平滑重启实际上是让旧的业务进程逐个退出然后并逐个创建新的进程做到的。为了在平滑重启时不影响客用户，这就要求进程中不要保存用户相关的状态信息，即业务进程最好是无状态的，避免由于进程退出导致信息丢失。 开发流程注意事项平滑重启注意：只有在on{…}回调中载入的文件平滑重启后才会自动更新，启动脚本中直接载入的文件或者写死的代码运行reload不会自动更新。 区分主进程和子进程有必要注意下代码是运行在主进程还是子进程，一般来说在Worker::runAll();调用前运行的代码都是在主进程运行的，onXXX回调运行的代码都属于子进程。注意写在Worker::runAll();后面的代码永远不会被执行。 注意： 不要在主进程中初始化数据库、memcache、redis等连接资源，因为主进程初始化的连接可能会被子进程自动继承（尤其是使用单例的时候），所有进程都持有同一个连接，服务端通过这个连接返回的数据在多个进程上都可读，会导致数据错乱。同样的，如果任何一个进程关闭连接(例如daemon模式运行时主进程会退出导致连接关闭)，都导致所有子进程的连接都被一起关闭，并发生不可预知的错误，例如mysql gone away 错误。 推荐在onWorkerStart里面初始化连接资源。 Worker类构造函数初始化一个Worker容器实例，可以设置容器的一些属性和回调接口，完成特定功能。1Worker::__construct([string $listen , array $context]) 参数$listen （可选参数，不填写表示不监听任何端口）$listen 的格式为 &lt;协议&gt;://&lt;监听地址&gt; $context一个数组。用于传递socket的上下文选项。 比如传递ssl证书1234567891011121314151617181920&lt;?phprequire_once __DIR__ . '/Workerman/Autoloader.php';use Workerman\\Worker;// 证书最好是申请的证书$context = array( 'ssl' =&gt; array( 'local_cert' =&gt; '/etc/nginx/conf.d/ssl/server.pem', // 也可以是crt文件 'local_pk' =&gt; '/etc/nginx/conf.d/ssl/server.key', ));// 这里设置的是websocket协议$worker = new Worker('websocket://0.0.0.0:4431', $context);// 设置transport开启ssl，websocket+ssl即wss$worker-&gt;transport = 'ssl';$worker-&gt;onMessage = function($con, $msg) &#123; $con-&gt;send('ok');&#125;;Worker::runAll(); 部分常用属性id1int Worker::$id 当前worker进程的id编号，范围为0到$worker-&gt;count-1 这个属性对于区分worker进程非常有用，例如1个worker实例有多个进程，开发者只想在其中一个进程中设置定时器，则可以通过识别进程编号id来做到这一点，比如只在该worker实例id编号为0的进程设置定时器 注意：进程重启后id编号值是不变的。进程编号id的分配是基于每个worker实例的。每个worker实例都从0开始给自己的进程编号，所以worker实例间进程编号会有重复，但是一个worker实例中的进程编号不会重复。123456789101112131415161718use Workerman\\Worker;use Workerman\\Lib\\Timer;require_once './Workerman/Autoloader.php';$worker = new Worker('tcp://0.0.0.0:8585');$worker-&gt;count = 4;$worker-&gt;onWorkerStart = function($worker)&#123; // 只在id编号为0的进程上设置定时器，其它1、2、3号进程不设置定时器 if($worker-&gt;id === 0) &#123; Timer::add(1, function()&#123; echo \"4个worker进程，只在0号进程设置定时器\\n\"; &#125;); &#125;&#125;;// 运行workerWorker::runAll(); count1int Worker::$count 设置当前Worker实例启动多少个进程，不设置时默认为1。 注意：此属性必须在Worker::runAll();运行前设置才有效。windows系统不支持此特性。 设置规则： 每个进程占用内存之和需要小于总内存（一般来说每个业务进程占用内存大概40M左右） 如果是IO密集型，也就是业务中涉及到一些阻塞式IO，比如一般的访问Mysql、Redis等存储都是阻塞式访问的，进程数可以开大一些，如配置成CPU核数的3倍。注意非阻塞式IO属于CPU密集型，而不属于IO密集型。 如果是CPU密集型，也就是业务中没有阻塞式IO开销，例如使用异步IO读取网络资源，进程不会被业务代码阻塞的情况下，可以把进程数设置成和CPU核数一样 WorkerMan自身的IO都是非阻塞的，例如Connection-&gt;send等都是非阻塞的，属于CPU密集型操作。如果不清楚自己业务偏向于哪种类型，可设置进程数为CPU核数的2倍左右即可。 transport1string Worker::$transport 设置当前Worker实例所使用的传输层协议，目前只支持3种(tcp、udp、ssl)。不设置默认为tcp。 注意：ssl需要Workerman版本&gt;=3.3.7 connections1array Worker::$connections 此属性中存储了当前进程的所有的客户端连接对象，其中id为connection的id编号 格式为：1array(id=&gt;connection, id=&gt;connection, ...) stdoutFile1static string Worker::$stdoutFile 此属性为全局静态属性，如果以守护进程方式(-d启动)运行，则所有向终端的输出(echo var_dump等)都会被重定向到stdoutFile指定的文件中。 如果不设置，并且是以守护进程方式运行，则所有终端输出全部重定向到/dev/null 注意：此属性必须在Worker::runAll();运行前设置才有效。 1234567891011121314&lt;?phpuse Workerman\\Worker;require_once __DIR__ . '/Workerman/Autoloader.php';Worker::$daemonize = true;// 所有的打印输出全部保存在/tmp/stdout.log文件中Worker::$stdoutFile = '/tmp/stdout.log';$worker = new Worker('text://0.0.0.0:8484');$worker-&gt;onWorkerStart = function($worker)&#123; echo \"Worker start\\n\";&#125;;// 运行workerWorker::runAll(); reloadable设置当前Worker实例是否可以reload，即收到reload信号后是否退出重启。不设置默认为true，收到reload信号后自动重启进程。1bool Worker::$reloadable daemonize1static bool Worker::$daemonize 此属性为全局静态属性，表示是否以daemon(守护进程)方式运行。如果启动命令使用了 -d 参数，则该属性会自动设置为true。也可以代码中手动设置 回调属性onWorkerStart1callback Worker::$onWorkerStart 设置Worker子进程启动时的回调函数，每个子进程启动时都会执行。 注意：onWorkerStart是在子进程启动时运行的，如果开启了多个子进程($worker-&gt;count &gt; 1)，每个子进程运行一次，则总共会运行$worker-&gt;count次。 回调函数的参数: $worker: Worker对象 onWorkerReload1callback Worker::$onWorkerReload 设置Worker收到reload信号后执行的回调。 可以利用onWorkerReload回调做很多事情，例如在不需要重启进程的情况下重新加载业务配置文件。 注意： 子进程收到reload信号默认的动作是退出重启，以便新进程重新加载业务代码完成代码更新。所以reload后子进程在执行完onWorkerReload回调后便立刻退出是正常现象。 如果在收到reload信号后只想让子进程执行onWorkerReload，不想退出，可以在初始化Worker实例时设置对应的Worker实例的reloadable属性为false。 回调函数的参数: $worker: Worker对象 onConnect1callback Worker::$onConnect 当客户端与Workerman建立连接时(TCP三次握手完成后)触发的回调函数。每个连接只会触发一次onConnect回调。 注意：onConnect事件仅仅代表客户端与Workerman完成了TCP三次握手，这时客户端还没有发来任何数据，此时除了通过$connection-&gt;getRemoteIp()获得对方ip，没有其他可以鉴别客户端的数据或者信息，所以在onConnect事件里无法确认对方是谁。要想知道对方是谁，需要客户端发送鉴权数据，例如某个token或者用户名密码之类，在onMessage回调里做鉴权。 回调函数的参数: $connection: 连接对象 onMessage1callback Worker::$onMessage 当客户端通过连接发来数据时(Workerman收到数据时)触发的回调函数 回调函数的参数: $connection: 连接对象 $data: 客户端连接上发来的数据 onClose1callback Worker::$onClose 当客户端连接与Workerman断开时触发的回调函数。不管连接是如何断开的，只要断开就会触发onClose。每个连接只会触发一次onClose。 注意：如果对端是由于断网或者断电等极端情况断开的连接，这时由于无法及时发送tcp的fin包给workerman，workerman就无法得知连接已经断开，也就无法及时触发onClose。这种情况需要通过应用层心跳来解决。 回调函数的参数: $connection: 连接对象 onBufferDrain1callback Worker::$onBufferDrain 每个连接都有一个单独的应用层发送缓冲区，缓冲区大小由TcpConnection::$maxSendBufferSize决定，默认值为1MB，可以手动设置更改大小，更改后会对所有连接生效。 该回调可能会在调用Connection::send后立刻被触发，比如发送大数据或者连续快速的向对端发送数据，由于网络等原因数据被大量积压在对应连接的发送缓冲区，当超过TcpConnection::$maxSendBufferSize上限时触发。 回调函数的参数: $connection: 连接对象 onBufferDrain1callback Worker::$onBufferDrain 该回调在应用层发送缓冲区数据全部发送完毕后触发。一般与onBufferFull配合使用，例如在onBufferFull时停止向对端继续send数据，在onBufferDrain恢复写入数据。 回调函数的参数: $connection: 连接对象 onError1callback Worker::$onError 当客户端的连接上发生错误时触发。 目前错误类型有 调用Connection::send由于客户端连接断开导致的失败（紧接着会触发onClose回调） (code:WORKERMAN_SEND_FAIL msg:client closed) 在触发onBufferFull后(发送缓冲区已满)，仍然调用Connection::send，并且发送缓冲区仍然是满的状态导致发送失败(不会触发onClose回调)(code:WORKERMAN_SEND_FAIL msg:send buffer full and drop package) 使用AsyncTcpConnection异步连接失败时(紧接着会触发onClose回调) (code:WORKERMAN_CONNECT_FAIL msg:stream_socket_client返回的错误消息) 回调函数的参数: $connection: 连接对象$code: 错误码$msg: 错误消息 接口runAll1void Worker::runAll(void) 运行所有Worker实例。 注意： Worker::runAll()执行后将永久阻塞，也就是说位于Worker::runAll()后面的代码将不会被执行。所有Worker实例化应该都在Worker::runAll()前进行。 stopAll1void Worker::stopAll(void) 停止当前进程（子进程）的所有Worker实例并退出。 此方法用于安全退出当前子进程，作用相当于调用exit/die退出当前子进程。 与直接调用exit/die区别是，直接调用exit或者die无法触发onWorkerStop回调，并且会导致一条WORKER EXIT UNEXPECTED错误日志。 listen1void Worker::listen(void) 用于实例化Worker后执行监听。 Connection类属性idprotocol1string Connection::$protocol 设置当前连接的协议类 worker1Worker Connection::$worker 此属性为只读属性，即当前connection对象所属的worker实例 123456789101112131415use Workerman\\Worker;require_once __DIR__ . '/Workerman/Autoloader.php';$worker = new Worker('websocket://0.0.0.0:8484');// 当一个客户端发来数据时，转发给当前进程所维护的其它所有客户端$worker-&gt;onMessage = function($connection, $data)&#123; foreach($connection-&gt;worker-&gt;connections as $con) &#123; $con-&gt;send($data); &#125;&#125;;// 运行workerWorker::runAll(); maxSendBufferSize1int Connection::$maxSendBufferSize 此属性用来设置当前连接的应用层发送缓冲区大小。不设置默认为Connection::$defaultMaxSendBufferSize(1MB)。 defaultMaxSendBufferSize1static int Connection::$defaultMaxSendBufferSize 此属性为全局静态属性，用来设置所有连接的默认应用层发送缓冲区大小。不设置默认为1MB。 Connection::$defaultMaxSendBufferSize可以动态设置，设置后只对之后产生的新连接有效 maxPackageSize1static int Connection::$maxPackageSize 此属性为全局静态属性，用来设置每个连接能够接收的最大包包长。不设置默认为10MB。 回调属性与worker的回调属性作用相同 接口sendgetRemoteIpetRemotePortTimer定时器类add1int \\Workerman\\Lib\\Timer::add(float $time_interval, callable $callback [,$args = array(), bool $persistent = true]) 定时执行某个函数或者类方法 注意：定时器是在当前进程中运行的，workerman中不会创建新的进程或者线程去运行定时器。 参数time_interval: 多长时间执行一次，单位秒，支持小数，可以精确到0.001，即精确到毫秒级别 callback: 回调函数注意：如果回调函数是类的方法，则方法必须是public属性 args: 回调函数的参数，必须为数组，数组元素为参数值 persistent: 是否是持久的，如果只想定时执行一次，则传递false（只执行一次的任务在执行完毕后会自动销毁，不必调用Timer::del()）。默认是true，即一直定时执行 返回值返回一个整数，代表计时器的timerid，可以通过调用Timer::del($timerid)销毁这个计时器。 示例123456789101112131415161718192021222324252627use \\Workerman\\Worker;use \\Workerman\\Lib\\Timer;require_once __DIR__ . '/Workerman/Autoloader.php';$ws_worker = new Worker('websocket://0.0.0.0:8080');$ws_worker-&gt;count = 8;// 连接建立时给对应连接设置定时器$ws_worker-&gt;onConnect = function($connection)&#123; // 每10秒执行一次 $time_interval = 10; $connect_time = time(); // 给connection对象临时添加一个timer_id属性保存定时器id $connection-&gt;timer_id = Timer::add($time_interval, function()use($connection, $connect_time) &#123; $connection-&gt;send($connect_time); &#125;);&#125;;// 连接关闭时，删除对应连接的定时器$ws_worker-&gt;onClose = function($connection)&#123; // 删除定时器 Timer::del($connection-&gt;timer_id);&#125;;// 运行workerWorker::runAll(); 更多示例：http://doc.workerman.net/timer/add.html del1boolean \\Workerman\\Lib\\Timer::del(int $timer_id) 删除某个定时器 示例定时器回调中删除当前定时器12345678910111213141516171819202122use \\Workerman\\Worker;use \\Workerman\\Lib\\Timer;require_once __DIR__ . '/Workerman/Autoloader.php';$task = new Worker();$task-&gt;onWorkerStart = function($task)&#123; // 注意，回调里面使用当前定时器id必须使用引用(&amp;)的方式引入 $timer_id = Timer::add(1, function()use(&amp;$timer_id) &#123; static $i = 0; echo $i++.\"\\n\"; // 运行10次后删除定时器 if($i === 10) &#123; Timer::del($timer_id); &#125; &#125;);&#125;;// 运行workerWorker::runAll(); 定时器注意事项 只能在onXXXX回调中添加定时器。全局的定时器推荐在onWorkerStart回调中设置，针对某个连接的定时器推荐在onConnect中设置。 添加的定时任务在当前进程执行(不会启动新的进程或者线程)，如果任务很重（特别是涉及到网络IO的任务），可能会导致该进程阻塞，暂时无法处理其它业务。所以最好将耗时的任务放到单独的进程运行，例如建立一个/多个Worker进程运行 当前进程忙于其它业务时或者当一个任务没有在预期的时间运行完，这时又到了下一个运行周期，则会等待当前任务完成才会运行，这会导致定时器没有按照预期时间间隔运行。也就是说当前进程的业务都是串行执行的，如果是多进程则进程间的任务运行是并行的。 多进程设置了定时任务造可能会造成并发问题 可能会有1毫秒左右的误差 定时器不能跨进程删除，例如a进程设置的定时器无法在b进程直接调用Timer::del接口删除 不同进程间的定时器id可能会重复，但是同一个进程内产生的定时器id不会重复 常见问题心跳注意：长连接应用必须加心跳，否则连接可能由于长时间未通讯被路由节点强行断开。 心跳作用主要有两个： 客户端定时给服务端发送点数据，防止连接由于长时间没有通讯而被某些节点的防火墙关闭导致连接断开的情况。 服务端可以通过心跳来判断客户端是否在线，如果客户端在规定时间内没有发来任何数据，就认为客户端下线。这样可以检测到客户端由于极端情况(断电、断网等)下线的事件。 建议值：建议心跳间隔小于60秒 示例自动断开连接12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php/** * Created by PhpStorm. * User: pengwenwu * Date: 2018/6/23 * Time: 23:31 */require_once './vendor/autoload.php';use Workerman\\Worker;use Workerman\\Lib\\Timer;$ws_worker = new Worker(\"websocket://0.0.0.0:9501\");// 启动4个进程对外提供服务$ws_worker-&gt;count = 4;// 心跳间隔25秒define('HEARTBEAT_TIME', 25);$ws_worker-&gt;onMessage = function ($connection, $data) &#123; // 给connection临时设置一个lastMessageTime属性，用来记录上次收到消息的时间 $connection-&gt;lastMessageTime = time(); // 其它业务逻辑... $connection-&gt;send('hello' . $data);&#125;;// 进程启动后设置一个每秒运行一次的定时器$ws_worker-&gt;onWorkerStart = function ($worker) &#123; Timer::add(1, function () use ($worker) &#123; $time_now = time(); foreach ($worker-&gt;connections as $connection) &#123; // 有可能该connection还没收到过消息，则lastMessageTime设置为当前时间 if (empty($connection-&gt;lastMessageTime)) &#123; $connection-&gt;lastMessageTime = $time_now; continue; &#125; // 上次通讯时间间隔大于心跳间隔，则认为客户端已经下线，关闭连接 if ($time_now - $connection-&gt;lastMessageTime &gt; HEARTBEAT_TIME) &#123; $connection-&gt;close(); &#125; &#125; &#125;);&#125;;Worker::runAll(); 更多详细请参考官方手册","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"workerman","slug":"workerman","permalink":"https://pengwenwu.github.io/tags/workerman/"},{"name":"websocket","slug":"websocket","permalink":"https://pengwenwu.github.io/tags/websocket/"},{"name":"php","slug":"php","permalink":"https://pengwenwu.github.io/tags/php/"}]},{"title":"WebSocket入门","slug":"WebSocket入门","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2018/06/18/WebSocket入门/","link":"","permalink":"https://pengwenwu.github.io/2018/06/18/WebSocket入门/","excerpt":"","text":"为什么需要WebSocket？虽然有HTTP协议，但是一个很明显的缺点是：所有请求只能有客户端发起，向服务端请求。而服务端有任何状态变化，无法直接通知到客户端。简单处理的方法就是轮询，连续不断发起请求，但是这个非常浪费资源，因为需要不断请求连接。最常见的例子就是聊天室。 WebSocket优点： 支持双向通信，实时性更强 更好的支持二进制 较少的控制开销，数据交换时，数据包请求头较小 支持更多扩展 websocket也是通过http请求去建立连接，请求格式如下：1234567GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13 跟普通http请求的区别： GET请求的地址不是类似/path/，而是以ws://开头的地址 请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接 Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据 Sec-WebSocket-Version指定了WebSocket的协议版本 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 服务器返回数据：1234HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: server-random-string 该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议 成功建立连接后，客户端和服务端就可以直接主动发消息给对方。消息传递的格式有两种：文本，二进制数据.通常可以发送JSON数据，方便处理 WebSocket对象123var ws = new WebSokcet(url, [protocol])const ws = new WebSocket('ws://echo.websocket.org', ['myProtocol1', 'myProtocol2']) WebSocket 构造函数可接受两个参数，其中，第一个参数必须是以 ws:// 或 wss:// 开头的完全限定的 URL第二个为非必要参数，用于指定可接受的子协议，有两种可能的类型: String 类型，值为客户端和服务器端均能理解的协议 Arrary 类型，包含一组客户端支持的协议（String 类型） WebSocket 属性Socket.readyState只读属性 readyState 表示连接状态，可以是以下值： 0 | WebSocket.CONNECTING：表示连接尚未建立 1 | WebSocket.OPEN：表示连接已经建立 2 | WebSocket.CLOSEING：表示连接正在关闭 3 | WebSocket.CLOSED: 表示连接已经关闭或者连接不能打开 bufferedAmountWebSocket 对象的 bufferedAmount 属性可以用检查已经进入发送队列，但是还未发送到服务器的字节数。可以用来判断发送是否结束 protocolWebSocket 对象的 protocol 属性值为 WebSocket 打开连接握手期间，服务器端所选择的协议名 protocol 属性在最初的握手完成之前为空，如果服务器没有选择客户端提供的某个协议，则该属性保持空值 WebSockets事件处理WebSocket 对象具有以下 4 个事件： open 事件当服务器响应了 WebSocket 连接请求，触发open事件并建立一个连接，此时WebSocket已经准备好发送和接收数据，open事件对应的回调函数是onopen()12345678ws.onopen = (event) =&gt; &#123; console.log('开启连接');&#125;// 或者ws.addEventListener('open', (event) =&gt; &#123; console.log('开启连接');&#125;, false) message事件message事件在接收到消息是触发，消息内容存储在事件对象event的data中，对应的回调函数是onmessage()1234567ws.onmessage = (event) =&gt; &#123; if (typeof event.data === 'string') &#123; console.log('接收到的string消息内容为：' + event.data) &#125; else &#123; console.log('其他类型消息') &#125;&#125; 除了普通文件，WebSocket消息内容还可以是二进制，这种数据作为Blob消息或者ArraryBuffer消息处理。暂不赘述。 error事件error事件在响应意外发生故障时触发，对应的回调函数是onerror()。错误会导致WebSocket连接关闭。 close事件close事件在连接关闭时触发，对应的回调函数是onclose()。一旦连接关闭，客户端和服务器端不在接续接收和发送消息。close事件的3个常用属性： wasClean：布尔值，表示连接是否被正确关闭。如果是来自服务器的close帧的响应，则为true；如果是因为其他原因关闭，则为false code：服务器发送的关闭连接握手状态码 reason：服务器发送的关闭连接握手状态 WebSocket方法WebSocket API提供两个方法供调用。 send()使用send()方法可以从客户端向服务端发送消息。前提是必须当WebSocket在客户端和服务端建立全双工双向连接后，才可以调用该方法。所以一般是在open事件触发之后，close触发之前调用send()发送消息123ws.onopen = (event) &#123; ws.send('hello websocket');&#125; close()通过使用close()方法，可以人为的手动关闭WebSocket连接或者终止连接尝试。如果连接已关闭，则该方法什么也不做 可以向close()方法传递两个参数： code：Number类型，状态代码 reason: String类型，文本字符串，传递一些关于关闭连接的信息 参考链接：《WebSocket 教程 - 阮一峰》《WebSocket客户端编程》","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://pengwenwu.github.io/tags/WebSocket/"}]},{"title":"使用laradock配置LNMP环境","slug":"使用laradock配置LNMP环境","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/06/10/使用laradock配置LNMP环境/","link":"","permalink":"https://pengwenwu.github.io/2018/06/10/使用laradock配置LNMP环境/","excerpt":"","text":"介绍laradock是一个为php配置的完整的docker环境，可以通过修改配置文件，完成对不同版本、不同扩展、不同框架的php docker环境配置。从此对虚拟机说再见 使用clone到项目的同级目录或者使用Git 子模块1git clone https://github.com/Laradock/laradock.git laradock 这里使用CodeIgniter框架举个例子，目录结构是这样12|--- CodeIgniter|--- laradock 复制配置文件.env 才是配置文件123# 进入laradockm目录cd laradockcp env-example .env 增加配置参数如果需要使用mysql，redis等，.env需要新增配置HOST地址1234# .env 末尾新增DB_HOST=mysqlREDIS_HOST=redisQUEUE_HOST=rabbitmq 修改nginx默认挂在目录1vim laradock/nginx/sites/default.conf 修改default.conf配置文件123# 原配置# root /var/www/publicroot /var/www/CodeIgniter 启动容器这里有个坑，由于最近更新了mysql8，而laradoc的mysql中的Dockerfile默认是from latest拉去最新镜像，会导致mysql无法后台运行，秒退，应该是旧配置挂载问题1docker-compose up -d nginx mysql phpmyadmin redis workspace 这里需要重新构建mysql1234docker-compose build --build-arg MYSQL_VERSION=5.7 mysql# 构建完，重启容器docker-compose up -d mysql 查看可以通过docker-compose ps查看各个容器运行状态，以及暴露的端口12345678 Name Command State Ports--------------------------------------------------------------------------------------------------------laradoc_mysql_1 docker-entrypoint.sh mysqld Up 0.0.0.0:3306-&gt;3306/tcplaradoc_nginx_1 nginx Up 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:80-&gt;80/tcplaradoc_php-fpm_1 docker-php-entrypoint php-fpm Up 9000/tcplaradoc_phpmyadmin_1 /run.sh phpmyadmin Up 0.0.0.0:8080-&gt;80/tcp, 9000/tcplaradoc_redis_1 docker-entrypoint.sh redis ... Up 0.0.0.0:6379-&gt;6379/tcplaradoc_workspace_1 /sbin/my_init Up 0.0.0.0:2222-&gt;22/tcp 这里看到，nginx默认80端口，打开浏览器，输入localhost即可访问，正常返回的是CI框架的默认首页 Welcome to CodeIgniter! phpmyadmin的端口是8080，浏览器输入localhost:8080，则可以访问phpmyadmin。服务器地址是之前配置的 DB_HOST = mysql，账号密码可以查看.env配置文件，默认是root root，这些都是可以在启动命令的参数里设置 参考链接：《Laradock》","categories":[{"name":"Docker","slug":"Docker","permalink":"https://pengwenwu.github.io/categories/Docker/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"Docker","slug":"Docker","permalink":"https://pengwenwu.github.io/tags/Docker/"}]},{"title":"git子模块","slug":"git子模块","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/06/10/git子模块/","link":"","permalink":"https://pengwenwu.github.io/2018/06/10/git子模块/","excerpt":"","text":"子模块文档：Git 工具 - 子模块 在一个项目中要引入另外一个项目，比如我在当前项目里，想要引入laradock docker环境，需要怎么操作？难道需要copy一份代码过来？怎么保证同步更新？ 添加子模块在当前项目中执行git submodule add命令1git submodule add https://github.com/Laradock/laradock.git laradock 此时，会在当前项目下新建一个laradock项目，执行git status会看到下面两项：123456789$ git statusOn branch masterYour branch is up to date with 'origin/master'.Changes to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) new file: .gitmodules new file: laradock .gitmodules是一个配置文件1234$ cat .gitmodules[submodule \"laradock\"] path = laradock url = https://github.com/Laradock/laradock.git 如果此时，同时修改原项目文件，以及子项目文件，执行git diff12345678910111213141516$ git diffdiff --git a/README.md b/README.mdindex e02af03..a6a0276 100644--- a/README.md+++ b/README.md@@ -1,2 +1,4 @@ # bbs 基于CodeIgniter框架开发的bbs系统++&gt; 新增laradock项目引入diff --git a/laradock b/laradock--- a/laradock+++ b/laradock@@ -1 +1 @@-Subproject commit 66c61d9a72ea52ab04ddb1999b0998f7ba10a0e4+Subproject commit 66c61d9a72ea52ab04ddb1999b0998f7ba10a0e4-dirty 修改submodule需要进入到对应的子项目目录去修改,提交完毕之后，回到父级项目提交。 新clone submodule项目先clone父级项目，然后进入子项目，发现时空文件夹，需要依次执行1234# 在子项目目录git submodule init git submodule update 删除submodulegit 并不支持直接删除Submodule, 需要手动删除对应的文件1234567891011121314151617# 进入父级项目git rm --cached pod-library# 删除子项目rm -rf pod-library# 删除子项目配置文件rm .gitmodules# 更改git的配置文件config:vim .git/config# 删除父级项目git配置中的子项目配置[submodule \"pod-library\"] url = git@github.com:jjz/pod-library.git# 完成新的提交 参考资料：使用Git Submodule管理子模块","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"}]},{"title":"dokcer入门篇","slug":"dokcer入门篇","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2018/06/07/dokcer入门篇/","link":"","permalink":"https://pengwenwu.github.io/2018/06/07/dokcer入门篇/","excerpt":"","text":"阅读《Docker — 从入门到实践》 windows使用 下载docker for windows，安装 使用镜像加速，我自己使用的是阿里云镜像加速setting-&gt;Daemon-&gt;Registry mirrors-&gt;粘贴自己的加速器地址 可以使用gui界面，Kitematic 常用命令获取镜像可以使用docker pull --help查看1234docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]# etcdocker pull ubuntu:16.04 运行1234docker run -it --rm ubuntu:16.04 bash# 查看当前系统版本cat /etc/os-release -it: -i: 交互式操作, -t: 终端 --rm: 执行退出后删除该容器实例 bash: shell使用的方式 镜像列表1234docker image ls# etcREPOSITORY TAG IMAGE ID CREATED SIZE 各列意义：仓库名, 标签, 镜像id, 创建时间, 解压后文件大小镜像ID 则是镜像的唯一标识，一个镜像可以对应多个标签 镜像大小1docker system df 删除镜像1docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] 启动已终止的container镜像1docker [container] start 后台运行容器-d参数能够让容器后台运行，保证输出结果不会打印出来。但容器是否长久运行（一直后台挂起），跟-d参数无关，需要一直有指令执行，才不会“秒退”12345# -c exec执行docker run ubuntu:17.10 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"# 后台运行docker run -d ubuntu:17.10 /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 可以通过docker [container] logs去查看容器输出信息 终止运行1docker [contanier] stop 进入容器1234docker attach # 推荐使用docker exec -it [container id] /bin/bash 两者的区别：前者exit退出后，会停止当前容器；而exec仍然会保持运行 删除容器1234docker container rm # 清楚所有处于终止状态的容器docker container prune commit为什么不建议使用docker commit?使用docker commit提交后，对于其他使用者而言，这个image镜像是一个黑箱，别人无处得知执行过什么命令、如何生成的镜像 Dokcerfile 定制镜像FROM指定基础镜像RUN执行命令 shell格式：RUN &lt;命令&gt; exec格式：RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;] 构建镜像1234docker build [选项] &lt;上下文路径/URL/-&gt;# etc, 注意镜像构建上下文(context)docker build -t nginx:v3 . Dockerfile 指令详解CMD 启动命令CMD 指令就是用于指定默认的容器主进程的启动命令的，也分为shell格式以及exec格式 shell格式：CMD &lt;命令&gt; exec格式：CMD [“可执行文件”, “参数1”, “参数2”…] 参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数 一般推荐使用exec格式，这类格式在解析时会被解析成JSON数组，因此要使用双引号 如果是shell格式，实际会被包装成sh -c的格式1CMD echo $HOME 实际执行会变成：1CMD [ \"sh\", \"-c\", \"echo $HOME\" ] 注意：Docker不是虚拟机，容器中的应用都是前台执行，没有后台服务的概念 错误示范：1CMD service nginx start 这里容器执行后会秒退出，因为上面的命令会被转化为CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start]，主进程是sh，当service nginx start执行结束后，sh也就结束了，sh作为主进程结束，所以容器也会退出 正确做法：1CMD [ \"nginx\", \"-g\", \"daemon off;\" ] 这边执行docker run的时候，不需要再跟/bin/bash启动命令，因为会覆盖。否则就是秒结束进程 ENTRYPOINT 入口点如果指定了ENTRYPOINT，CMD就不会直接执行命令，而是讲内容作为参数传给ENTRYPOINT，实际执行指令会变为：1ENTRYPOINT \"&lt;CMD&gt;\" 场景一：让镜像变成像命令一样使用1docker run myip -i 场景二：应用运行前的准备工作在启动主进程之前，需要一些准备工作，比如数据库的配置、初始化 ENV 设置环境变量两种格式： ENV \\ \\ ENV \\=\\ \\=\\ … 123# 含有空格的值使用双引号ENV VERSION=1.0 DEBUG=on \\ NAME=\"Happy Feet\" ARG构建参数格式：ARG &lt;参数名&gt;[=&lt;默认值&gt;] 构建参数和ENV效果一样，都是设置环境变量，唯一的区别是，ARG构建的环境变量，在将来容器运行的时候，不会存储这些环境变量 Dokcerfile中的ARG指令是定义参数名称，以及其默认值。可以通过构建命令docker build中用--build-arg &lt;参数名&gt;=&lt;值&gt;来覆盖 VOLUME 定义匿名卷格式为： VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…] VOLUME &lt;路径&gt; 容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中 1VOLUME /data 这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化 1docker run -d -v mydata:/data xxxx 这里mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置 EXPOSE 声明端口格式为：EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处: 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射 在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口 要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 WORKDIR 指定工作目录格式为: WORKDIR &lt;工作目录路径&gt; 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录 USER 指定当前用户格式：USER &lt;用户名&gt; USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份 HEALTHCHECK 健康检查HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常 格式： HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 ONBUILD格式：ONBUILD &lt;其它指令&gt; NOBUILD指令是别人定制镜像。即使用FROM的时候，才执行的命令 推送镜像12345# 先打标签docker tag ubuntu:17.10 username/ubuntu:17.10# 在pushdocker push username/ubuntu:17.10 配置私有仓库配置私有仓库 数据卷数据卷 是一个可供一个或多个容器使用的特殊目录： 数据卷可以在容器之间共享和重用 对 数据卷 的修改会立马生效 对 数据卷 的更新，不会影响镜像 数据卷 默认会一直存在，即使容器被删除 注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷。 外部访问容器使用- P标记时，Docker会随机映射 49000~49900 的端口到内部容器开放的网络端口 - p可以指定要映射的端口，也可以指定地址ip:hostPort:containerPort 1docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py 查看映射端口配置docker port1docker port nostalgic_morse 5000 容器有自己的内部网络和 ip 地址 -p 标记可以多次使用来绑定多个端口 容器互联查看已有网络1docker network ls 新建网络1docker network create -d bridge my-net -d 可以指定Docker网络类型，有bridge, overlay，其中 overlay 网络类型用于 Swarm mode(集群服务) 连接容器运行一个容器并连接到新建的 my-net 网络123456789101112docker run -it --rm --name busybox1 --network my-net busybox sh# 再运行一个容器docker run -it --rm --name busybox2 --network my-net busybox sh# 测试连接# 在busybox1 容器里，执行# /ping busybox2PING busybox2 (172.19.0.3): 56 data bytes64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.060 ms64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.046 ms64 bytes from 172.19.0.3: seq=2 ttl=64 time=0.075 ms Compose 项目Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。Compose 中有两个重要的概念： 服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。 项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。 Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。 Compose 命令说明命令对象与格式docker-compose 命令的基本的使用格式是:1docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...] 命令选项 -f, –file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。 -p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。 –x-networking 使用 Docker 的可拔插网络后端特性 –x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge –verbose 输出更多调试信息。 -v, –version 打印版本并退出 命令使用说明Tips: 这里的service name是指服务的名称，不是container name 或者 container id build构建（重新构建）项目中的服务容器1docker-compose build [options] [SERVICE...] 服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db选项包括： --force-rm 删除构建过程中的临时容器 --no-cache 构建镜像过程中不使用 cache（这将加长构建过程） --pull 始终尝试通过 pull 来获取更新版本的镜像 config验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因 down此命令将会停止 up 命令所启动的容器，并移除网络 exec进入指定的容器123# 如果执行/bin/bash失败，报错OCI runtime exec failed,是因为bash不存在，替换成sh docker-compose exec web /bin/sh images列出 Compose 文件中包含的镜像 kill格式为 docker-compose kill [options] [SERVICE...] 通过发送 SIGKILL 信号来强制停止服务容器 支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号 1docker-compose kill -s SIGINT logs查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 –no-color 来关闭颜色。 格式为：docker-compose logs [options] [SERVICE...] pause暂停服务格式为：docker-compose pause [SERVICE...] port打印某个容器端口所映射的公共端口 格式为 docker-compose port [options] SERVICE PRIVATE_PORT 选项： –protocol=proto 指定端口协议，tcp（默认值）或者 udp。 –index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1） pspullpushrestartstoprmrun格式为 docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]1docker-compose run ubuntu ping docker.com 默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。 该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。 两个不同点： 给定命令将会覆盖原有的自动运行命令； 不会自动创建端口，以避免冲突。 如果不希望自动启动关联的容器，可以使用 –no-deps 选项，例如:1docker-compose run --no-deps web python manage.py shell 将不会启动 web 容器所关联的其它容器. 选项： -d 后台运行容器。 –name NAME 为容器指定一个名字。 –entrypoint CMD 覆盖默认的容器启动指令。 -e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。 -u, –user=”” 指定运行容器的用户名或者 uid。 –no-deps 不自动启动关联的服务容器。 –rm 运行命令后自动删除容器，d 模式下将忽略。 -p, –publish=[] 映射容器端口到本地主机。 –service-ports 配置服务端口并映射到本地主机。 -T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。 scale设置指定服务运行的容器个数 格式为 docker-compose scale [options] [SERVICE=NUM...] 通过 service=num 的参数来设置数量。例如：1docker-compose scale web=3 db=2 一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。 topunpause启动已暂停的服务 up格式为 docker-compose up [options] [SERVICE...] 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作 链接的服务都将会被自动启动，除非已经处于运行状态 默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试 如果使用 docker-compose up -d，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。 选项： -d 在后台运行服务容器。 –no-color 不使用颜色来区分不同的服务的控制台输出。 –no-deps 不启动服务所链接的容器。 –force-recreate 强制重新创建容器，不能与 –no-recreate 同时使用。 –no-recreate 如果容器已经存在了，则不重新创建，不能与 –force-recreate 同时使用。 –no-build 不自动构建缺失的服务镜像。 -t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒） Compose 模板文件模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 docker run 相关参数的含义都是类似的。 默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。123456789version: '3'services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像 如果使用 build 指令，在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中再次设置。 build指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。 可以使用 context 指令指定 Dockerfile 所在文件夹的路径 使用 dockerfile 指令指定 Dockerfile 文件名 使用 arg 指令指定构建镜像时的变量 使用 cache_from 指定构建镜像的缓存12345build: context: . cache_from: - alpine:latest - corp/web_app:3.14 cap_add, cap_drop指定容器的内核能力（capacity）分配 command覆盖容器启动后默认执行的命令1command: echo \"hello world\" container_name指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式1container_name: docker-web-container 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称 devices指定设备映射关系。12devices: - \"/dev/ttyUSB1:/dev/ttyUSB0\" depends_on解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web1234567891011121314version: '3'services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 注意：web 服务不会等待 redis db 「完全启动」之后才启动。 dns自定义 DNS 服务器。可以是一个值，也可以是一个列表。12345dns: 8.8.8.8dns: - 8.8.8.8 - 114.114.114.114 env_file从文件中获取环境变量，可以为单独的文件路径或列表。 如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径 如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准 123456env_file: .envenv_file: - ./common.env - ./apps/web.env - /opt/secrets.env 环境变量文件中每一行必须符合格式，支持 # 开头的注释行。12# common.env: Set development environmentPROG_ENV=development environment设置环境变量。可以使用数组或字典两种格式 只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据 1234567environment: RACK_ENV: development SESSION_SECRET:environment: - RACK_ENV=development - SESSION_SECRET 如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。 expose暴露端口，但不映射到宿主机，只被连接的服务访问 仅可以指定内部端口为参数 123expose: - \"3000\" - \"8000\" image指定为镜像名称或镜像 ID 读取变量Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。 例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。 12345version: \"3\"services:db: image: \"mongo:$&#123;MONGO_VERSION&#125;\" 如果执行 MONGO_VERSION=3.2 docker-compose up 则会启动一个 mongo:3.2 镜像的容器；如果执行 MONGO_VERSION=2.8 docker-compose up 则会启动一个 mongo:2.8 镜像的容器。 若当前目录存在 .env 文件，执行 docker-compose 命令时将从该文件中读取变量。 在当前目录新建 .env 文件并写入以下内容。12# 支持 # 号注释MONGO_VERSION=3.6 执行 docker-compose up 则会启动一个 mongo:3.6 镜像的容器。 附录常见问题总结常见问题总结 资源链接资源链接 进阶深入进阶深入，参考原文档《Docker — 从入门到实践》","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://pengwenwu.github.io/tags/Docker/"}]},{"title":"js和php闭包使用和区别","slug":"js和php闭包使用和区别","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2018/05/25/js和php闭包使用和区别/","link":"","permalink":"https://pengwenwu.github.io/2018/05/25/js和php闭包使用和区别/","excerpt":"","text":"匿名函数 如果只是省去函数名，单纯的当作一个函数式方法返回，只能称为匿名函数（闭包需要将匿名函数当作结果返回），比如： 12345// jsvar foo = function(x, y) &#123; return x + y ;&#125;;console.log(foo(1, 2)); // 3 123456&lt;?php// php$foo = function($a, $b) &#123; return $a + $b;&#125;; // 一定要加分号echo $foo(1, 2); // 3 闭包 闭包通常是用来创建内部变量，使得这些变量不得被外部随意修改，而只能通过指定的函数接口去修改 js闭包这里举一个阮老师博客里的例子，阮老师博客：学习Javascript闭包（Closure） js基础参考链接：深入理解JS中声明提升、作用域（链）和this关键字 js比较特殊的一点是：函数内部可以直接读取到全局变量（对于阮老师的这句话不是很能理解，大概是想表达的意思：父作用域的变量可以在子作用域直接访问，而不需要去声明访问真正的全局变量？） 大部分语言，变量都是先声明在使用，而对于js，具有声明提升的特性（不管在哪里声明，都会在代码执行前处理） 函数和变量的声明总是会隐式地被移动到当前作用域的顶部，函数的声明优先级高于变量的声明 var 会在当前作用域声明一个变量，而未声明的变量，会隐式地创建一个全局变量 123// 声明提升console.log(a); // 1, 未报错var a = 1; 123456789101112131415161718192021// 上文链接中的例子function testOrder(arg) &#123; console.log(arg); // arg是形参，不会被重新定义 console.log(a); // 因为函数声明比变量声明优先级高，所以这里a是函数 var arg = 'hello'; // var arg;变量声明被忽略， arg = 'hello'被执行 var a = 10; // var a;被忽视; a = 10被执行，a变成number function a() &#123; console.log('fun'); &#125; // 被提升到作用域顶部 console.log(a); // 输出10 console.log(arg); // 输出hello&#125;; testOrder('hi');/* 输出：hi function a() &#123; console.log('fun'); &#125;10 hello */ 12345678// 全局作用域var foo = 42;function test() &#123; // 局部作用域 foo = 21;&#125;test();foo; // 21 12345678// 全局作用域foo = 42;function test() &#123; // 局部作用域 var foo = 21;&#125;test();foo; // 42 js变量的查找是从里往外的，直到最顶层（全局作用域），并且一旦找到，即停止向上查找。所有内部函数可以访问函数外部的变量，反之无效 12345678function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log(a, b, c); &#125; bar(b * 3);&#125;foo(2); 1234function foo() &#123; var a = 1;&#125;console.log(a); //a is not defined 123456789101112131415function foo1() &#123; var num = 0; addNum = function() &#123; // 这里未通过var去声明，默认是全局变量 num += 1; &#125;; function foo2() &#123; console.log(num); &#125; return foo2;&#125;var tmp = foo1();tmp(); // 0addNum();tmp(); // 1 这里第二次调用foo2函数，foo1函数的局部变量num并没有被初始化为0，说明打印的是内存中的num。正常函数在每次调用结束后都会销毁局部变量，在重新调用的时候会再次声明变量；而这边没有重新声明的原因是：把foo2函数赋值给了一个全局变量tmp，导致foo2函数一直存在内存中，而foo2函数依赖于foo1函数存在，所以foo1函数也存在内存中，并没有被销毁，所以foo1的局部变量也是存在内存中。 this的上下文基于函数调用的情况。和函数在哪定义无关，而和函数怎么调用有关。 在全局上下文（任何函数以外），this指向全局对象(windows) 在函数内部时，this由函数怎么调用来确定 当函数作为对象方法调用时，this指向该对象 下面是阮老师博客里的两个思考题： 12345678910var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); // The Window 1234567891011var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()());// My Object this的作用域好像一直是个比较奇怪的东西，对于上面两个例子，我的理解是：第一个例子，是在方法里调用的this，而这个this并没有声明，会隐式地创建一个全局变量，所以调用的全局的name；第二个，调用的that的时候，会向顶级链式查找是否声明that，而这个that有this赋值，这里的this又是通过对象方法调用，则该this指向这个object对象，所有最终调用的是object作用域内的name。不知道这么理解是不是有问题，还望大神指正。 那其实js闭包的主要目的：访问函数内部的局部变量，即延长作用域链参考链接：js闭包MDN文档 php闭包php回调函数mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $… ]] )mixed call_user_func_array ( callable $callback , array $param_arr ) 这两个函数都是把第一个参数作为回调函数d调用，后面接收参数，区别就是第二个函数第二参数接收数组；在使用上唯一的区别就是，call_user_func函数无法接收引用传递; 个人觉得同样是使用，call_user_func 相比call_user_func_array完全可以被替代，不知道是不是有一些性能上的优势。具体使用样例，请参考官方文档。 123456789&lt;?php// 引用传递function foo(&amp;$a, &amp;$b) &#123; $a ++; $b --;&#125;;$a = $b = 10;call_user_func_array('foo', [&amp;$a, &amp;$b]);echo $a.\"\\n\", $b; // 11, 9 基本用法基本用法，跟js的闭包类似 普通调用 123456&lt;?phpglobal $tmp = 'hello world';function foo() &#123; var_dump(global $tmp);&#125;foo(); // null, 函数内部无法直接调用上级作用域的变量，除非声明为全局变量 12345678910&lt;?php$foo1 = function() &#123; $a = 10; $foo2 = function() &#123; var_dump($a); &#125;; return $foo2;&#125;;$tmp = $foo1();$tmp(); // null，原因同上 php想要能够获取上级作用域的变量，需要通过use传递 123456789101112&lt;?php$foo1 = function () &#123; $a = 10; $foo2 = function () use ($a) &#123; var_dump($a); $a ++; &#125;; $foo2(); return $foo2;&#125;;$tmp = $foo1();$tmp(); // 10, 10, use并不能实际改变变量的值，只是值传递 123456789101112&lt;?php$foo1 = function () &#123; $a = 10; $foo2 = function () use (&amp;$a) &#123; var_dump($a); $a ++; &#125;; $foo2(); return $foo2;&#125;;$tmp = $foo1();$tmp(); // 10, 11, 通过值传递改变变量的值 下面两段代码的区别，不是很明白，望大佬指点，为什么后一个值传递就可以获取到已经改变后变量的值。好像都是在调用方法之前，已经执行过变量的递增了吧？ 123456789101112&lt;?php// 值传递$foo1 = function () &#123; $a = 10; $foo2 = function () use ($a) &#123; var_dump($a); &#125;; $a ++; return $foo2;&#125;;$tmp = $foo1();$tmp(); // 10 123456789101112&lt;?php// 引用传递$foo1 = function () &#123; $a = 10; $foo2 = function () use (&amp;$a) &#123; var_dump($a); &#125;; $a ++; return $foo2;&#125;;$tmp = $foo1();$tmp(); // 11 正确使用 1234567891011&lt;?php// 值传递$foo = function () &#123; $a = 10; $foo2 = function ($num) use ($a) &#123; var_dump($num + $a); &#125;; return $foo2;&#125;;$tmp = $foo();$tmp(100); // 110 1234567891011121314&lt;?php// 引用传递$foo = function () &#123; $a = 10; $foo2 = function ($num) use (&amp;$a) &#123; var_dump($num + $a); $a ++; &#125;; return $foo2;&#125;;$tmp = $foo();$tmp(100); // 110$tmp(100); // 111$tmp(100); // 112 跟js类似，保证变量常驻内存 php Closure 类 Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域public static Closure Closure::bind ( Closure $closure , object $newthis [, mixed $newscope = ‘static’ ] ) Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域public Closure Closure::bindTo ( object $newthis [, mixed $newscope = ‘static’ ] )对这两个方法不是很能理解。。。求指教 共同点都是为了扩展作用域，获取内部变量 区别js能够在方法内部直接获取到父级作用域的变量，而php需要通过use声明，并且默认是值传递 应用场景 不是很能理解应用场景，搜索了一下，很多只是写了一个闭包实现的购物车，感觉并不是那么的实用。 如果只是单纯的使用匿名函数，感觉还不如封装成一个私有方法 这些只是个人粗鄙的理解，望指正.","categories":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"JS","slug":"JS","permalink":"https://pengwenwu.github.io/tags/JS/"},{"name":"闭包","slug":"闭包","permalink":"https://pengwenwu.github.io/tags/闭包/"}]},{"title":"phpstorm或vscode使用psr2规范","slug":"phpstorm或vscode使用psr2规范","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2018/05/14/phpstorm或vscode使用psr2规范/","link":"","permalink":"https://pengwenwu.github.io/2018/05/14/phpstorm或vscode使用psr2规范/","excerpt":"","text":"安装composer 全局安装phpcs 1composer global require squizlabs/php_codesniffer vscode直接插件搜索phpcs安装phpstorm全局安装phpcs后，会在C:\\Users{user name}\\AppData\\Roaming\\Composer\\vendor\\bin下生成一个phpcs.bat，后面会用到 phpstorm -&gt; setting languages &amp; Frameworks-&gt;PHP-&gt;Code Sniffer点击Configuration右侧的按钮 找到刚才的phpcs.bat，点击Validate，确认 Editor-&gt;Inspection-&gt;PHP 双击PHP Code Sniffer validation，点击Coding standard右侧的刷新按钮，然后选择psr2，确定 参考链接: 如何优雅地使用phpstorm?","categories":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"PSR","slug":"PSR","permalink":"https://pengwenwu.github.io/tags/PSR/"}]},{"title":"array_map, array_walk, array_filter的区别及使用","slug":"array-map-array-walk-array-filter的区别及使用","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2018/05/13/array-map-array-walk-array-filter的区别及使用/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/array-map-array-walk-array-filter的区别及使用/","excerpt":"","text":"array_map, array_walk, array_filter的区别及使用 12345678910111213141516171819202122232425262728&lt;?php// array_map, array_walk, array_filter的区别$arr = [1, 2, 3, 4];function foo($value)&#123; return $value * $value;&#125;function filter($value)&#123; return $value &gt; 2;&#125;function walk(&amp;$value)&#123; $value = $value * $value;&#125;// array_map 会返回新的数组, 不对原数组产生影响$new_arr = array_map('foo', $arr);echo '原数组:'.var_export($arr, 1).\"\\n\", 'array_map修改后的数组：'.var_export($new_arr, 1).\"\\n\".\"&lt;hr/&gt;\";// array_walk 返回bool值，callback需要通过值传递改变原有数组$res = array_walk($arr, 'walk');echo '修改后的数组:'.var_export($arr, 1).\"\\n\", 'array_walk返回结果：'.var_export($res, 1).\"\\n\".\"&lt;hr/&gt;\";// array_filter 返回筛选后的新数组，不对原数组产生影响$new_arr = array_filter($arr, 'filter');echo '原数组:'.var_export($arr, 1).\"\\n\", 'array_filter返回结果：'.var_export($new_arr, 1).\"\\n\".\"&lt;hr/&gt;\";","categories":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"}]},{"title":"windows下cmd/powershell中文乱码解决方法","slug":"windows下cmd-powershell中文乱码解决方法","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/05/13/windows下cmd-powershell中文乱码解决方法/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/windows下cmd-powershell中文乱码解决方法/","excerpt":"","text":"windows下cmd或者powershell运行php文件中文乱码 解决方法执行下面的命令，切换成utf-8编码 chcp 65001 这个指标不治本，查了说是可以修改注册表，但是好像又会带来其他的坑（中文软件乱码、nodejs乱码），未测试过，不予评价。参考链接：https://www.zhihu.com/question/54724102","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://pengwenwu.github.io/categories/环境配置/"}],"tags":[{"name":"中文乱码","slug":"中文乱码","permalink":"https://pengwenwu.github.io/tags/中文乱码/"}]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2018/05/13/hexo常用命令/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/hexo常用命令/","excerpt":"","text":"hexo常用命令123456hexo n &quot;博客名称&quot; =&gt; hexo new &quot;博客名称&quot; hexo clean # 清楚缓存hexo g =&gt; hexo generate #生成hexo p =&gt; hexo publish # 发布hexo s =&gt; hexo server #启动服务预览hexo d =&gt; hexo deploy #部署 发布流程123hexo cleanhexo ghexo d","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"https://pengwenwu.github.io/tags/Hexo/"}]},{"title":"git reset 和 revert 的区别和使用","slug":"git-reset-和-revert-的区别和使用","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/05/13/git-reset-和-revert-的区别和使用/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/git-reset-和-revert-的区别和使用/","excerpt":"","text":"git revert 撤销某次提交, 保留之前的commit, 同时创建一个新的commit(可用于公共分支)git reset 撤销某个提交， 删除之前的commit, head回退 (多用于私有分支)区别: git revert 只是撤销某个commit, 保留该commit之前的提交结果 DEMO commit3: add log3commit2: add log2commit1: add log1 HEAD用法 HEAD^: 指向上一次commit HEAD~100: 指向前第一百个commit HEAD commit_id: 直接指向某个commit –soft、–mixed(默认)、–hard的区别 –soft: 只是重置HEAD到某一个commit, 其余不会有任何变化(缓存区和工作目录都不会被改变) –mixed(默认): 重置HEAD, 文件修改都将保存到缓存区(缓存区和你指定的提交同步，但工作目录不受影响) –hard: 修改当前所有内容, 所有本地修改都将丢失(缓存区和工作目录都同步到你指定的提交). 找回执行命令: git reflow","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"}]},{"title":"git pull更新指定文件","slug":"git-pull更新指定文件","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/05/13/git-pull更新指定文件/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/git-pull更新指定文件/","excerpt":"","text":"经常会遇到，几个文件一起提交了，但是某些文件是要先执行的，不然一起pull下来会加载报错 更新git指定文件git fetchgit checkout origin/master – path/to/file","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"}]},{"title":"阅读《微服务设计》笔记","slug":"阅读《微服务设计》笔记","date":"un66fin66","updated":"un44fin44","comments":true,"path":"2018/03/03/阅读《微服务设计》笔记/","link":"","permalink":"https://pengwenwu.github.io/2018/03/03/阅读《微服务设计》笔记/","excerpt":"","text":"记录阅读《微服务设计》收获的点 什么是微服务？一些协同工作的小而自治的服务 打破外键关系对于有外键关系的表如何做服务拆分？通过api调用访问 优点：数据表拆分，进而服务拆分 缺点：增加了数据库的调用，会影响性能。需要测试是否在可接受范围内，权衡拆分服务带来的好处 共享表拆分共享表拆分后，如何保证插入数据的一致性？设计之初为了减少数据库的调用，必然会建立基于外键的共享表。拆分之后，如何保证同时插入多张表数据的一致性？（某张表插入失败） 通过事务处理 推荐对及时性较弱的操作，异常捕获后放入队列或者日志文件中进行延迟处理，保证最终一致性 终止整个操作，再发起补偿事务来抵消之前的操作（自动化处理） 分布式事务。通过专门的事务管理器工具来协调底层事务（不推荐，易出错，难扩展） 阅读完感觉云里雾里，可能是自己的水平还没到达那个深度。收获大概是：了解了后端的架构，后期拓展可能会遇到的问题，以及解决这样问题的思路。","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://pengwenwu.github.io/tags/微服务/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2018/01/21/Linux常用命令/","link":"","permalink":"https://pengwenwu.github.io/2018/01/21/Linux常用命令/","excerpt":"","text":"记录一些阅读《鸟哥的Linux私房菜-基础学习篇》中不太熟悉的命令 软连接、硬链接 软连接：连接文件的内容只会写上目标文件的“文件名”，实际是通过记录的目标文件地址去访问实际存储内容。大小就是文件名大小。如果删除目标文件，则当前文件无法访问。(等同于windows的快捷方式) 硬连接：只能针对单个文件，实际会创建一个一模一样的“文件”(权限、大小)，连接数增加。连接到同一个地址，只是使用了不同的文件名，均可以对源文件进行数据修改，删除任意一个，不影响其余文件访问 12345cp -s test test1 ln -s test test1 # 软连接(快捷方式)cp -l demo.php demo1.php ln -l demo.php demo1.php # 硬链接(只支持单个文件) 查看分区1fdisk -l 解压缩123#-z gzip压缩，-j bzip2压缩tar -zcvf [newfilename] filename tar -zxvf filename.tar.gz [-C 目录] 解压要到指定目录 查看命令1type name 命名别名1234alias rm=&apos;rm -i&apos;alias st=&apos;status&apos;unalias rm #取消别名 数据流重定向 标准输入：&lt;或&lt;&lt; (将由键盘输入的数据由文件代替/结束输入)标准输出：&gt;或&gt;&gt; (覆盖/追加)标准错误输出：2&gt;或2&gt;&gt; (覆盖/追加) 1234cat &gt; catfile &lt;&lt; eof&gt;This is a test.&gt;Ok now stop&gt;eof 命令执行判断：; || &amp;&amp;12345678910#依次执行echo 1; echo 2; echo 3 #若cmd1正确执行，则开始执行cmd2#若cmd1执行错误，则cmd2不执行cmd1 &amp;&amp; cmd2 #若cmd1正确执行，则不执行cmd2#若cmd1执行错误，则开始执行cmd2cmd1 || cmd2 选取命令：cut, grep cut: -d：分割字符，与-f一起用 -f：取出第几段 -c：取出固定字符区间 12345# 列出第三段，第五段echo $PATH | cut -d &apos;:&apos; -f 3,5 # 取得第5字符之后echo $PATH | cut -c 5- 排序命令:sort, wc, uniq sort [-fbMnrtuk]uniq [-ic]-c：进行计数 12# 每个人登录的次数last | cut -d &apos; &apos; -f 1 | sort | uniq -c wc [-lwm]-l：仅列出行-w：仅列出多少字-m：多少字符","categories":[{"name":"Linux","slug":"Linux","permalink":"https://pengwenwu.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://pengwenwu.github.io/tags/Linux/"}]},{"title":"hexo + github搭建个人博客教程","slug":"hexo + github搭建个人博客教程","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2018/01/14/hexo + github搭建个人博客教程/","link":"","permalink":"https://pengwenwu.github.io/2018/01/14/hexo + github搭建个人博客教程/","excerpt":"","text":"前言一年前，临近毕业。为了准备面试，才刻意去准备了github以及blog。自从找到工作后，这两个基本没怎么维护过，想想未免太功利了点。 主要是前几天，又踩到坑了，想去找以前的记录，很麻烦。之前虽然每天都会写工作总结，一些踩过的坑记在为知笔记上，没有分类、标签，后面再想去找很困难。痛定思痛，该记的东西少不掉，索性优雅一点。 之前用的是博客园，但是那个账号密码老记不住，干脆自己搭建一个吧，好歹也是一个码农。然后花了两个晚上加一个上午，通过hexo和github搭建了一个个人博客。网上教程、文档那么多，为什么花这么久时间？当然是踩坑了啊。所以下面会记录一些遇到的问题和坑。如果你看完这边文章，那你只需要两个小时就能搭建成功。欢迎有兴趣的小伙伴尝试一下。 正文环境准备 node.js git 这两个应用windows用户直接搜索下载安装就可以。如果习惯了使用linux命令的朋友，推荐windows神器cmder。可以直接在windows环境下使用linux命令，样式可调，再也不要用黑乎乎的cmd了，而且自带git，完全可以不用下载windows git。 正式安装hexohexo官方中文文档 在node.js安装好的前提下，全局安装hexo如何判断node.js是否安装成功？执行以下命令，如果能够看到版本号则说明安装成功了1node -v 安装hexo1npm install -g hexo-cli 自选合适的目录，新建文件夹&lt;folder&gt;123cd &lt;folder&gt;hexo initnpm install 不再赘述，直接看官方文档。 配置github新建仓库，仓库名必须为[your_name.github.io] 补充：本地配置github ssh连接，方便自动部署，以及clone你喜欢的主题(theme) windows用户直接在c:/用户/youername/.ssh/下查看是否有id_rsa.pub文件。没有的话命令行执行命令ssh-keygen -t rsa -C &quot;your eamil&quot;，会自动生成id_rsa.pub文件，打开后复制。 github-&gt;头像-&gt;Settings→SSH kyes→Add SSH key，粘贴复制的内容。 配置本地账户12git config --global user.name “your_username” #设置用户名git config --global user.email “your_email” #设置邮箱地址,最好使用注册邮箱地址 测试是否配置成功1ssh -T git@github.com hexo配置以及使用有两个配置文件： 一个是根目录下的_config.yml称为站点配置文件 一个是themes/landscape/_config.yml称为主题配置文件(默认主题：landscape) 站点配置如下： 1234567url: https://yourname.github.io/theme: landscape #选择你想用的主题，我用的是indigodeploy: type: git # 不要使用github repo: git@github.com:pengwenwu/pengwenwu.github.io.git # 使用ssh连接 branch: master # 默认master分支 message: add new blog # 自动部署commit备注，可不填 hexo常用命令hexo命令参考 hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate #生成hexo s == hexo server #启动服务本地预览hexo d == hexo deploy #部署hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP 在执行之前，记得安装自动部署 (–save 加不加的区别在于是否写入到依赖文件package.json中)1npm install hexo-deployer-git --save 正常本地预览，直接执行hexo s,如果要发布话最好执行clean命令，会去删除生成的public文件，完整部署命令:hexo clean &amp;&amp; hexo g &amp;&amp; hexo d。或者直接hexo d -g 注意问题安装完自动部署后，是不需要本地git init新建仓库的。执行hexo g会在根目录生成public文件夹，自动部署，本质是将public文件夹内容全部提交到仓库中去，默认会访问编译好的index.html。 如果部署完，访问your_name.github.io 404,可能有下面几个原因 首先检查仓库文件，是不是全都是public的文件内容，如果整个本地blog文件夹都提交了，首先清空仓库，然后删除本地.deploy_git文件夹，再重新部署 文件有报错，本地hexo s观察是否有报错。 不喜欢原主题的朋友，可以github去找喜欢的主题。执行命令1git clone XXXX.next.git themes\\next 这个会将新的主题下载到themes下对应的next目录，next为主题的名字。 主题的配置，可以看文档，修改对应的主题配置文件。我使用的主题是indigo,详细文档indigo markdown不会使用的朋友，参考链接markdown中文文档如果没有ide的话，可以使用在线预览Cmd Markdown","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://pengwenwu.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://pengwenwu.github.io/tags/Github/"}]},{"title":"如何将一个数组乱序？","slug":"如何将一个数组乱序？","date":"un66fin66","updated":"un00fin00","comments":true,"path":"2018/01/13/如何将一个数组乱序？/","link":"","permalink":"https://pengwenwu.github.io/2018/01/13/如何将一个数组乱序？/","excerpt":"","text":"这是很久以前博客园的博客，打个小样。 前几天php实习面试，问到一个问题：如何将一个数组乱序？答：使用自带的array_rand()或者shuffle()函数，或者用随机数取值赋值给新的数组。又问：万一一直随机到同一个数怎么办？那就进行判断，如果已经取过的位置，重新选取随机数。这样问题就来了：随着新数组长度增加，原数组中的随机数选取碰撞几率会原来越大，最后几乎是一直碰撞的。也没有想出更好的办法。 后来回家后查了一下，总结一下，有以下几种方法： 使用自带的函数 12345678function shuffle_rand1($arr)&#123; echo \"原来数组为：\"; print_r($arr); shuffle($arr); echo \"&lt;br&gt;乱序数组为：\"; print_r($arr);&#125; 第一时间想到的方法，就是随机取值，赋值给新的数组 12345678910111213141516171819function shuffle_rand2($arr)&#123; echo \"原来数组为：\"; print_r($arr); $len = count($arr); $shuffle_arr = array(); while(count($shuffle_arr)&lt;$len)&#123; $index = rand(0,$len-1); if(!in_array($index, $shuffle_arr))&#123; $shuffle_arr[] = $index; &#125; &#125; $newarr = array(); foreach ($shuffle_arr as $v) &#123; $newarr[] = $arr[$v]; &#125; echo \"&lt;br&gt;新的数组为：\"; print_r($newarr);&#125; 数组中随机取一个元素赋值给新的数组，然后将原数组最后一位赋值到该位置,数组长度减一，继续重复上述步奏 123456789101112131415function shuffle_rand3($arr)&#123; echo \"原来数组为：\"; print_r($arr); $len = count($arr); $shuffle_arr = array(); while($len&gt;0)&#123; $index = rand(0,$len-1); $shuffle_arr[] = $arr[$index]; $arr[$index] = $arr[$len-1]; $len--; &#125; echo \"&lt;br&gt;新的数组为：\"; print_r($shuffle_arr);&#125; 在具有n个元素的数组中，对0到n-1一次进行与一个随机位置元素进行交换,这种方法不需要新建一个数组，直接在原数组中进行 12345678910111213function shuffle_rand4($arr)&#123; echo \"原来数组为：\"; print_r($arr); $len = count($arr); for($i=0;$i&lt;$len;$i++)&#123; $index = rand(0,$len-1); $temp = $arr[$i]; $arr[$i] = $arr[$index]; $arr[$index] = $temp; &#125; echo \"&lt;br&gt;新的数组为：\"; print_r($arr);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://pengwenwu.github.io/categories/算法/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"算法","slug":"算法","permalink":"https://pengwenwu.github.io/tags/算法/"}]},{"title":"Hello World","slug":"hello-world","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2018/01/10/hello-world/","link":"","permalink":"https://pengwenwu.github.io/2018/01/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}