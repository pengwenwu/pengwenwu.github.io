{"meta":{"title":"Pena's Blog","subtitle":"莫道君行早，更有早行人","description":"pengwenwu的个人博客","author":"pengwenwu","url":"https://pengwenwu.github.io"},"pages":[{"title":"tags","date":"un55fin55","updated":"un00fin00","comments":true,"path":"tags/index.html","permalink":"https://pengwenwu.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"un55fin55","updated":"un00fin00","comments":true,"path":"categories/index.html","permalink":"https://pengwenwu.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"js和php闭包使用和区别","slug":"js和php闭包使用和区别","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2018/05/25/js和php闭包使用和区别/","link":"","permalink":"https://pengwenwu.github.io/2018/05/25/js和php闭包使用和区别/","excerpt":"","text":"匿名函数 如果只是省去函数名，单纯的当作一个函数式方法返回，只能称为匿名函数（闭包需要将匿名函数当作结果返回），比如： 12345// jsvar foo = function(x, y) &#123; return x + y ;&#125;;console.log(foo(1, 2)); // 3 123456&lt;?php// php$foo = function($a, $b) &#123; return $a + $b;&#125;; // 一定要加分号echo $foo(1, 2); // 3 闭包 闭包通常是用来创建内部变量，使得这些变量不得被外部随意修改，而只能通过指定的函数接口去修改 js闭包这里举一个阮老师博客里的例子，阮老师博客：学习Javascript闭包（Closure） js基础参考链接：深入理解JS中声明提升、作用域（链）和this关键字 js比较特殊的一点是：函数内部可以直接读取到全局变量（对于阮老师的这句话不是很能理解，大概是想表达的意思：父作用域的变量可以在子作用域直接访问，而不需要去声明访问真正的全局变量？） 大部分语言，变量都是先声明在使用，而对于js，具有声明提升的特性（不管在哪里声明，都会在代码执行前处理） 函数和变量的声明总是会隐式地被移动到当前作用域的顶部，函数的声明优先级高于变量的声明 var 会在当前作用域声明一个变量，而未声明的变量，会隐式地创建一个全局变量 123// 声明提升console.log(a); // 1, 未报错var a = 1; 123456789101112131415161718192021// 上文链接中的例子function testOrder(arg) &#123; console.log(arg); // arg是形参，不会被重新定义 console.log(a); // 因为函数声明比变量声明优先级高，所以这里a是函数 var arg = 'hello'; // var arg;变量声明被忽略， arg = 'hello'被执行 var a = 10; // var a;被忽视; a = 10被执行，a变成number function a() &#123; console.log('fun'); &#125; // 被提升到作用域顶部 console.log(a); // 输出10 console.log(arg); // 输出hello&#125;; testOrder('hi');/* 输出：hi function a() &#123; console.log('fun'); &#125;10 hello */ 12345678// 全局作用域var foo = 42;function test() &#123; // 局部作用域 foo = 21;&#125;test();foo; // 21 12345678// 全局作用域foo = 42;function test() &#123; // 局部作用域 var foo = 21;&#125;test();foo; // 42 js变量的查找是从里往外的，直到最顶层（全局作用域），并且一旦找到，即停止向上查找。所有内部函数可以访问函数外部的变量，反之无效 12345678function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log(a, b, c); &#125; bar(b * 3);&#125;foo(2); 1234function foo() &#123; var a = 1;&#125;console.log(a); //a is not defined 123456789101112131415function foo1() &#123; var num = 0; addNum = function() &#123; // 这里未通过var去声明，默认是全局变量 num += 1; &#125;; function foo2() &#123; console.log(num); &#125; return foo2;&#125;var tmp = foo1();tmp(); // 0addNum();tmp(); // 1 这里第二次调用foo2函数，foo1函数的局部变量num并没有被初始化为0，说明打印的是内存中的num。正常函数在每次调用结束后都会销毁局部变量，在重新调用的时候会再次声明变量；而这边没有重新声明的原因是：把foo2函数赋值给了一个全局变量tmp，导致foo2函数一直存在内存中，而foo2函数依赖于foo1函数存在，所以foo1函数也存在内存中，并没有被销毁，所以foo1的局部变量也是存在内存中。 this的上下文基于函数调用的情况。和函数在哪定义无关，而和函数怎么调用有关。 在全局上下文（任何函数以外），this指向全局对象(windows) 在函数内部时，this由函数怎么调用来确定 当函数作为对象方法调用时，this指向该对象 下面是阮老师博客里的两个思考题： 12345678910var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); // The Window 1234567891011var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()());// My Object this的作用域好像一直是个比较奇怪的东西，对于上面两个例子，我的理解是：第一个例子，是在方法里调用的this，而这个this并没有声明，会隐式地创建一个全局变量，所以调用的全局的name；第二个，调用的that的时候，会向顶级链式查找是否声明that，而这个that有this赋值，这里的this又是通过对象方法调用，则该this指向这个object对象，所有最终调用的是object作用域内的name。不知道这么理解是不是有问题，还望大神指正。 那其实js闭包的主要目的：访问函数内部的局部变量，即延长作用域链参考链接：js闭包MDN文档 php闭包php回调函数mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $… ]] )mixed call_user_func_array ( callable $callback , array $param_arr ) 这两个函数都是把第一个参数作为回调函数d调用，后面接收参数，区别就是第二个函数第二参数接收数组；在使用上唯一的区别就是，call_user_func函数无法接收引用传递; 个人觉得同样是使用，call_user_func 相比call_user_func_array完全可以被替代，不知道是不是有一些性能上的优势。具体使用样例，请参考官方文档。 123456789&lt;?php// 引用传递function foo(&amp;$a, &amp;$b) &#123; $a ++; $b --;&#125;;$a = $b = 10;call_user_func_array('foo', [&amp;$a, &amp;$b]);echo $a.\"\\n\", $b; // 11, 9 基本用法基本用法，跟js的闭包类似 普通调用 123456&lt;?phpglobal $tmp = 'hello world';function foo() &#123; var_dump(global $tmp);&#125;foo(); // null, 函数内部无法直接调用上级作用域的变量，除非声明为全局变量 12345678910&lt;?php$foo1 = function() &#123; $a = 10; $foo2 = function() &#123; var_dump($a); &#125;; return $foo2;&#125;;$tmp = $foo1();$tmp(); // null，原因同上 php想要能够获取上级作用域的变量，需要通过use传递 123456789101112&lt;?php$foo1 = function () &#123; $a = 10; $foo2 = function () use ($a) &#123; var_dump($a); $a ++; &#125;; $foo2(); return $foo2;&#125;;$tmp = $foo1();$tmp(); // 10, 10, use并不能实际改变变量的值，只是值传递 123456789101112&lt;?php$foo1 = function () &#123; $a = 10; $foo2 = function () use (&amp;$a) &#123; var_dump($a); $a ++; &#125;; $foo2(); return $foo2;&#125;;$tmp = $foo1();$tmp(); // 10, 11, 通过值传递改变变量的值 下面两段代码的区别，不是很明白，望大佬指点，为什么后一个值传递就可以获取到已经改变后变量的值。好像都是在调用方法之前，已经执行过变量的递增了吧？ 123456789101112&lt;?php// 值传递$foo1 = function () &#123; $a = 10; $foo2 = function () use ($a) &#123; var_dump($a); &#125;; $a ++; return $foo2;&#125;;$tmp = $foo1();$tmp(); // 10 123456789101112&lt;?php// 引用传递$foo1 = function () &#123; $a = 10; $foo2 = function () use (&amp;$a) &#123; var_dump($a); &#125;; $a ++; return $foo2;&#125;;$tmp = $foo1();$tmp(); // 11 正确使用 1234567891011&lt;?php// 值传递$foo = function () &#123; $a = 10; $foo2 = function ($num) use ($a) &#123; var_dump($num + $a); &#125;; return $foo2;&#125;;$tmp = $foo();$tmp(100); // 110 1234567891011121314&lt;?php// 引用传递$foo = function () &#123; $a = 10; $foo2 = function ($num) use (&amp;$a) &#123; var_dump($num + $a); $a ++; &#125;; return $foo2;&#125;;$tmp = $foo();$tmp(100); // 110$tmp(100); // 111$tmp(100); // 112 跟js类似，保证变量常驻内存 php Closure 类 Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域public static Closure Closure::bind ( Closure $closure , object $newthis [, mixed $newscope = ‘static’ ] ) Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域public Closure Closure::bindTo ( object $newthis [, mixed $newscope = ‘static’ ] )对这两个方法不是很能理解。。。求指教 共同点都是为了扩展作用域，获取内部变量 区别js能够在方法内部直接获取到父级作用域的变量，而php需要通过use声明，并且默认是值传递 应用场景 不是很能理解应用场景，搜索了一下，很多只是写了一个闭包实现的购物车，感觉并不是那么的实用。 如果只是单纯的使用匿名函数，感觉还不如封装成一个私有方法 这些只是个人粗鄙的理解，望指正.","categories":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/categories/PHP/"}],"tags":[{"name":"js","slug":"js","permalink":"https://pengwenwu.github.io/tags/js/"},{"name":"php","slug":"php","permalink":"https://pengwenwu.github.io/tags/php/"},{"name":"闭包","slug":"闭包","permalink":"https://pengwenwu.github.io/tags/闭包/"}]},{"title":"phpstorm或vscode使用psr2规范","slug":"phpstorm或vscode使用psr2规范","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2018/05/14/phpstorm或vscode使用psr2规范/","link":"","permalink":"https://pengwenwu.github.io/2018/05/14/phpstorm或vscode使用psr2规范/","excerpt":"","text":"安装composer 全局安装phpcs 1composer global require squizlabs/php_codesniffer vscode直接插件搜索phpcs安装phpstorm全局安装phpcs后，会在C:\\Users{user name}\\AppData\\Roaming\\Composer\\vendor\\bin下生成一个phpcs.bat，后面会用到 phpstorm -&gt; setting languages &amp; Frameworks-&gt;PHP-&gt;Code Sniffer点击Configuration右侧的按钮 找到刚才的phpcs.bat，点击Validate，确认 Editor-&gt;Inspection-&gt;PHP 双击PHP Code Sniffer validation，点击Coding standard右侧的刷新按钮，然后选择psr2，确定 参考链接: 如何优雅地使用phpstorm?","categories":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"PSR","slug":"PSR","permalink":"https://pengwenwu.github.io/tags/PSR/"}]},{"title":"array_map, array_walk, array_filter的区别及使用","slug":"array-map-array-walk-array-filter的区别及使用","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2018/05/13/array-map-array-walk-array-filter的区别及使用/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/array-map-array-walk-array-filter的区别及使用/","excerpt":"","text":"array_map, array_walk, array_filter的区别及使用 12345678910111213141516171819202122232425262728&lt;?php// array_map, array_walk, array_filter的区别$arr = [1, 2, 3, 4];function foo($value)&#123; return $value * $value;&#125;function filter($value)&#123; return $value &gt; 2;&#125;function walk(&amp;$value)&#123; $value = $value * $value;&#125;// array_map 会返回新的数组, 不对原数组产生影响$new_arr = array_map('foo', $arr);echo '原数组:'.var_export($arr, 1).\"\\n\", 'array_map修改后的数组：'.var_export($new_arr, 1).\"\\n\".\"&lt;hr/&gt;\";// array_walk 返回bool值，callback需要通过值传递改变原有数组$res = array_walk($arr, 'walk');echo '修改后的数组:'.var_export($arr, 1).\"\\n\", 'array_walk返回结果：'.var_export($res, 1).\"\\n\".\"&lt;hr/&gt;\";// array_filter 返回筛选后的新数组，不对原数组产生影响$new_arr = array_filter($arr, 'filter');echo '原数组:'.var_export($arr, 1).\"\\n\", 'array_filter返回结果：'.var_export($new_arr, 1).\"\\n\".\"&lt;hr/&gt;\";","categories":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"}]},{"title":"windows下cmd/powershell中文乱码解决方法","slug":"windows下cmd-powershell中文乱码解决方法","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/05/13/windows下cmd-powershell中文乱码解决方法/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/windows下cmd-powershell中文乱码解决方法/","excerpt":"","text":"windows下cmd或者powershell运行php文件中文乱码 解决方法执行下面的命令，切换成utf-8编码 chcp 65001 这个指标不治本，查了说是可以修改注册表，但是好像又会带来其他的坑（中文软件乱码、nodejs乱码），未测试过，不予评价。参考链接：https://www.zhihu.com/question/54724102","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://pengwenwu.github.io/categories/环境配置/"}],"tags":[{"name":"中文乱码","slug":"中文乱码","permalink":"https://pengwenwu.github.io/tags/中文乱码/"}]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2018/05/13/hexo常用命令/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/hexo常用命令/","excerpt":"","text":"hexo常用命令123456hexo n &quot;博客名称&quot; =&gt; hexo new &quot;博客名称&quot; hexo clean # 清楚缓存hexo g =&gt; hexo generate #生成hexo p =&gt; hexo publish # 发布hexo s =&gt; hexo server #启动服务预览hexo d =&gt; hexo deploy #部署 发布流程123hexo cleanhexo ghexo d","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"},{"name":"hexo","slug":"hexo","permalink":"https://pengwenwu.github.io/tags/hexo/"}]},{"title":"git reset 和 revert 的区别和使用","slug":"git-reset-和-revert-的区别和使用","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/05/13/git-reset-和-revert-的区别和使用/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/git-reset-和-revert-的区别和使用/","excerpt":"","text":"git revert 撤销某次提交, 保留之前的commit, 同时创建一个新的commit(可用于公共分支)git reset 撤销某个提交， 删除之前的commit, head回退 (多用于私有分支)区别: git revert 只是撤销某个commit, 保留该commit之前的提交结果 DEMO commit3: add log3commit2: add log2commit1: add log1 HEAD用法 HEAD^: 指向上一次commit HEAD~100: 指向前第一百个commit HEAD commit_id: 直接指向某个commit –soft、–mixed(默认)、–hard的区别 –soft: 只是重置HEAD到某一个commit, 其余不会有任何变化(缓存区和工作目录都不会被改变) –mixed(默认): 重置HEAD, 文件修改都将保存到缓存区(缓存区和你指定的提交同步，但工作目录不受影响) –hard: 修改当前所有内容, 所有本地修改都将丢失(缓存区和工作目录都同步到你指定的提交). 找回执行命令: git reflow","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"}]},{"title":"git pull更新指定文件","slug":"git-pull更新指定文件","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/05/13/git-pull更新指定文件/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/git-pull更新指定文件/","excerpt":"","text":"经常会遇到，几个文件一起提交了，但是某些文件是要先执行的，不然一起pull下来会加载报错 更新git指定文件git fetchgit checkout origin/master – path/to/file","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"}]},{"title":"阅读《微服务设计》笔记","slug":"阅读《微服务设计》笔记","date":"un66fin66","updated":"un11fin11","comments":true,"path":"2018/03/03/阅读《微服务设计》笔记/","link":"","permalink":"https://pengwenwu.github.io/2018/03/03/阅读《微服务设计》笔记/","excerpt":"","text":"记录阅读《微服务设计》收获的点 什么是微服务？一些协同工作的小而自治的服务 打破外键关系对于有外键关系的表如何做服务拆分？通过api调用访问 优点：数据表拆分，进而服务拆分 缺点：增加了数据库的调用，会影响性能。需要测试是否在可接受范围内，权衡拆分服务带来的好处 共享表拆分共享表拆分后，如何保证插入数据的一致性？设计之初为了减少数据库的调用，必然会建立基于外键的共享表。拆分之后，如何保证同时插入多张表数据的一致性？（某张表插入失败） 通过事务处理 推荐对及时性较弱的操作，异常捕获后放入队列或者日志文件中进行延迟处理，保证最终一致性 终止整个操作，再发起补偿事务来抵消之前的操作（自动化处理） 分布式事务。通过专门的事务管理器工具来协调底层事务（不推荐，易出错，难扩展） 阅读完感觉云里雾里，可能是自己的水平还没到达那个深度。收获大概是：了解了后端的架构，后期拓展可能会遇到的问题，以及解决这样问题的思路。","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://pengwenwu.github.io/tags/微服务/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2018/01/21/Linux常用命令/","link":"","permalink":"https://pengwenwu.github.io/2018/01/21/Linux常用命令/","excerpt":"","text":"记录一些阅读《鸟哥的Linux私房菜-基础学习篇》中不太熟悉的命令 软连接、硬链接 软连接：连接文件的内容只会写上目标文件的“文件名”，实际是通过记录的目标文件地址去访问实际存储内容。大小就是文件名大小。如果删除目标文件，则当前文件无法访问。(等同于windows的快捷方式) 硬连接：只能针对单个文件，实际会创建一个一模一样的“文件”(权限、大小)，连接数增加。连接到同一个地址，只是使用了不同的文件名，均可以对源文件进行数据修改，删除任意一个，不影响其余文件访问 12345cp -s test test1 ln -s test test1 # 软连接(快捷方式)cp -l demo.php demo1.php ln -l demo.php demo1.php # 硬链接(只支持单个文件) 查看分区1fdisk -l 解压缩123#-z gzip压缩，-j bzip2压缩tar -zcvf [newfilename] filename tar -zxvf filename.tar.gz [-C 目录] 解压要到指定目录 查看命令1type name 命名别名1234alias rm=&apos;rm -i&apos;alias st=&apos;status&apos;unalias rm #取消别名 数据流重定向 标准输入：&lt;或&lt;&lt; (将由键盘输入的数据由文件代替/结束输入)标准输出：&gt;或&gt;&gt; (覆盖/追加)标准错误输出：2&gt;或2&gt;&gt; (覆盖/追加) 1234cat &gt; catfile &lt;&lt; eof&gt;This is a test.&gt;Ok now stop&gt;eof 命令执行判断：; || &amp;&amp;12345678910#依次执行echo 1; echo 2; echo 3 #若cmd1正确执行，则开始执行cmd2#若cmd1执行错误，则cmd2不执行cmd1 &amp;&amp; cmd2 #若cmd1正确执行，则不执行cmd2#若cmd1执行错误，则开始执行cmd2cmd1 || cmd2 选取命令：cut, grep cut: -d：分割字符，与-f一起用 -f：取出第几段 -c：取出固定字符区间 12345# 列出第三段，第五段echo $PATH | cut -d &apos;:&apos; -f 3,5 # 取得第5字符之后echo $PATH | cut -c 5- 排序命令:sort, wc, uniq sort [-fbMnrtuk]uniq [-ic]-c：进行计数 12# 每个人登录的次数last | cut -d &apos; &apos; -f 1 | sort | uniq -c wc [-lwm]-l：仅列出行-w：仅列出多少字-m：多少字符","categories":[{"name":"Linux","slug":"Linux","permalink":"https://pengwenwu.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://pengwenwu.github.io/tags/Linux/"}]},{"title":"hexo + github搭建个人博客教程","slug":"hexo + github搭建个人博客教程","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/01/14/hexo + github搭建个人博客教程/","link":"","permalink":"https://pengwenwu.github.io/2018/01/14/hexo + github搭建个人博客教程/","excerpt":"","text":"前言一年前，临近毕业。为了准备面试，才刻意去准备了github以及blog。自从找到工作后，这两个基本没怎么维护过，想想未免太功利了点。 主要是前几天，又踩到坑了，想去找以前的记录，很麻烦。之前虽然每天都会写工作总结，一些踩过的坑记在为知笔记上，没有分类、标签，后面再想去找很困难。痛定思痛，该记的东西少不掉，索性优雅一点。 之前用的是博客园，但是那个账号密码老记不住，干脆自己搭建一个吧，好歹也是一个码农。然后花了两个晚上加一个上午，通过hexo和github搭建了一个个人博客。网上教程、文档那么多，为什么花这么久时间？当然是踩坑了啊。所以下面会记录一些遇到的问题和坑。如果你看完这边文章，那你只需要两个小时就能搭建成功。欢迎有兴趣的小伙伴尝试一下。 正文环境准备 node.js git 这两个应用windows用户直接搜索下载安装就可以。如果习惯了使用linux命令的朋友，推荐windows神器cmder。可以直接在windows环境下使用linux命令，样式可调，再也不要用黑乎乎的cmd了，而且自带git，完全可以不用下载windows git。 正式安装hexohexo官方中文文档 在node.js安装好的前提下，全局安装hexo如何判断node.js是否安装成功？执行以下命令，如果能够看到版本号则说明安装成功了1node -v 安装hexo1npm install -g hexo-cli 自选合适的目录，新建文件夹&lt;folder&gt;123cd &lt;folder&gt;hexo initnpm install 不再赘述，直接看官方文档。 配置github新建仓库，仓库名必须为[your_name.github.io] 补充：本地配置github ssh连接，方便自动部署，以及clone你喜欢的主题(theme) windows用户直接在c:/用户/youername/.ssh/下查看是否有id_rsa.pub文件。没有的话命令行执行命令ssh-keygen -t rsa -C &quot;your eamil&quot;，会自动生成id_rsa.pub文件，打开后复制。 github-&gt;头像-&gt;Settings→SSH kyes→Add SSH key，粘贴复制的内容。 配置本地账户12git config --global user.name “your_username” #设置用户名git config --global user.email “your_email” #设置邮箱地址,最好使用注册邮箱地址 测试是否配置成功1ssh -T git@github.com hexo配置以及使用有两个配置文件： 一个是根目录下的_config.yml称为站点配置文件 一个是themes/landscape/_config.yml称为主题配置文件(默认主题：landscape) 站点配置如下： 1234567url: https://yourname.github.io/theme: landscape #选择你想用的主题，我用的是indigodeploy: type: git # 不要使用github repo: git@github.com:pengwenwu/pengwenwu.github.io.git # 使用ssh连接 branch: master # 默认master分支 message: add new blog # 自动部署commit备注，可不填 hexo常用命令hexo命令参考 hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate #生成hexo s == hexo server #启动服务本地预览hexo d == hexo deploy #部署hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP 在执行之前，记得安装自动部署 (–save 加不加的区别在于是否写入到依赖文件package.json中)1npm install hexo-deployer-git --save 正常本地预览，直接执行hexo s,如果要发布话最好执行clean命令，会去删除生成的public文件，完整部署命令:hexo clean &amp;&amp; hexo g &amp;&amp; hexo d。或者直接hexo d -g 注意问题安装完自动部署后，是不需要本地git init新建仓库的。执行hexo g会在根目录生成public文件夹，自动部署，本质是将public文件夹内容全部提交到仓库中去，默认会访问编译好的index.html。 如果部署完，访问your_name.github.io 404,可能有下面几个原因 首先检查仓库文件，是不是全都是public的文件内容，如果整个本地blog文件夹都提交了，首先清空仓库，然后删除本地.deploy_git文件夹，再重新部署 文件有报错，本地hexo s观察是否有报错。 不喜欢原主题的朋友，可以github去找喜欢的主题。执行命令1git clone XXXX.next.git themes\\next 这个会将新的主题下载到themes下对应的next目录，next为主题的名字。 主题的配置，可以看文档，修改对应的主题配置文件。我使用的主题是indigo,详细文档indigo markdown不会使用的朋友，参考链接markdown中文文档如果没有ide的话，可以使用在线预览Cmd Markdown","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://pengwenwu.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://pengwenwu.github.io/tags/github/"}]},{"title":"如何将一个数组乱序？","slug":"如何将一个数组乱序？","date":"un66fin66","updated":"un00fin00","comments":true,"path":"2018/01/13/如何将一个数组乱序？/","link":"","permalink":"https://pengwenwu.github.io/2018/01/13/如何将一个数组乱序？/","excerpt":"","text":"这是很久以前博客园的博客，打个小样。 前几天php实习面试，问到一个问题：如何将一个数组乱序？答：使用自带的array_rand()或者shuffle()函数，或者用随机数取值赋值给新的数组。又问：万一一直随机到同一个数怎么办？那就进行判断，如果已经取过的位置，重新选取随机数。这样问题就来了：随着新数组长度增加，原数组中的随机数选取碰撞几率会原来越大，最后几乎是一直碰撞的。也没有想出更好的办法。 后来回家后查了一下，总结一下，有以下几种方法： 使用自带的函数 12345678function shuffle_rand1($arr)&#123; echo \"原来数组为：\"; print_r($arr); shuffle($arr); echo \"&lt;br&gt;乱序数组为：\"; print_r($arr);&#125; 第一时间想到的方法，就是随机取值，赋值给新的数组 12345678910111213141516171819function shuffle_rand2($arr)&#123; echo \"原来数组为：\"; print_r($arr); $len = count($arr); $shuffle_arr = array(); while(count($shuffle_arr)&lt;$len)&#123; $index = rand(0,$len-1); if(!in_array($index, $shuffle_arr))&#123; $shuffle_arr[] = $index; &#125; &#125; $newarr = array(); foreach ($shuffle_arr as $v) &#123; $newarr[] = $arr[$v]; &#125; echo \"&lt;br&gt;新的数组为：\"; print_r($newarr);&#125; 数组中随机取一个元素赋值给新的数组，然后将原数组最后一位赋值到该位置,数组长度减一，继续重复上述步奏 123456789101112131415function shuffle_rand3($arr)&#123; echo \"原来数组为：\"; print_r($arr); $len = count($arr); $shuffle_arr = array(); while($len&gt;0)&#123; $index = rand(0,$len-1); $shuffle_arr[] = $arr[$index]; $arr[$index] = $arr[$len-1]; $len--; &#125; echo \"&lt;br&gt;新的数组为：\"; print_r($shuffle_arr);&#125; 在具有n个元素的数组中，对0到n-1一次进行与一个随机位置元素进行交换,这种方法不需要新建一个数组，直接在原数组中进行 12345678910111213function shuffle_rand4($arr)&#123; echo \"原来数组为：\"; print_r($arr); $len = count($arr); for($i=0;$i&lt;$len;$i++)&#123; $index = rand(0,$len-1); $temp = $arr[$i]; $arr[$i] = $arr[$index]; $arr[$index] = $temp; &#125; echo \"&lt;br&gt;新的数组为：\"; print_r($arr);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://pengwenwu.github.io/categories/算法/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"算法","slug":"算法","permalink":"https://pengwenwu.github.io/tags/算法/"}]},{"title":"Hello World","slug":"hello-world","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2018/01/10/hello-world/","link":"","permalink":"https://pengwenwu.github.io/2018/01/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}