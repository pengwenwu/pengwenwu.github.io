{"meta":{"title":"Pena's Blog","subtitle":"莫道君行早，更有早行人","description":"pengwenwu的个人博客","author":"pengwenwu","url":"https://pengwenwu.github.io"},"pages":[{"title":"categories","date":"un55fin55","updated":"un00fin00","comments":true,"path":"categories/index.html","permalink":"https://pengwenwu.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"un55fin55","updated":"un00fin00","comments":true,"path":"tags/index.html","permalink":"https://pengwenwu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"dokcer入门篇","slug":"dokcer入门篇","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2018/06/07/dokcer入门篇/","link":"","permalink":"https://pengwenwu.github.io/2018/06/07/dokcer入门篇/","excerpt":"","text":"阅读《Docker — 从入门到实践》 windows使用 下载docker for windows，安装 使用镜像加速，我自己使用的是阿里云镜像加速setting-&gt;Daemon-&gt;Registry mirrors-&gt;粘贴自己的加速器地址 可以使用gui界面，Kitematic 常用命令获取镜像可以使用docker pull --help查看1234docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]# etcdocker pull ubuntu:16.04 运行1234docker run -it --rm ubuntu:16.04 bash# 查看当前系统版本cat /etc/os-release -it: -i: 交互式操作, -t: 终端 --rm: 执行退出后删除该容器实例 bash: shell使用的方式 镜像列表1234docker image ls# etcREPOSITORY TAG IMAGE ID CREATED SIZE 各列意义：仓库名, 标签, 镜像id, 创建时间, 解压后文件大小镜像ID 则是镜像的唯一标识，一个镜像可以对应多个标签 镜像大小1docker system df 删除镜像12345678910111213141516171819202122docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]``` ## 启动已终止的container镜像 ```bashdocker [container] start``` ## 后台运行容器 `-d`参数能够让容器后台运行，保证输出结果不会打印出来。但容器是否长久运行（一直后台挂起），跟`-d`参数无关，需要一直有指令执行，才不会“秒退” ```bash# -c exec执行docker run ubuntu:17.10 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"# 后台运行docker run -d ubuntu:17.10 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"``` 可以通过`docker [container] logs`去查看容器输出信息 ## 终止运行 ```bashdocker [contanier] stop 进入容器12345678910111213141516171819202122232425262728293031docker attach # 推荐使用docker exec -it [container id] /bin/bash``` 两者的区别：前者exit退出后，会停止当前容器；而`exec`仍然会保持运行 ## 删除容器 ```bashdocker container rm # 清楚所有处于终止状态的容器docker container prune``` ## commit **为什么不建议使用`docker commit`?** 使用`docker commit`提交后，对于其他使用者而言，这个image镜像是一个黑箱，别人无处得知执行过什么命令、如何生成的镜像 ## Dokcerfile 定制镜像 ### FROM指定基础镜像### RUN执行命令 - shell格式：`RUN &lt;命令&gt;` - exec格式：`RUN [\"可执行文件\", \"参数1\", \"参数2\"]` ## 构建镜像```bashdocker build [选项] &lt;上下文路径/URL/-&gt;# etc, 注意镜像构建上下文(context)docker build -t nginx:v3 . Dockerfile 指令详解CMD 启动命令CMD 指令就是用于指定默认的容器主进程的启动命令的，也分为shell格式以及exec格式 shell格式：CMD &lt;命令&gt; exec格式：CMD [“可执行文件”, “参数1”, “参数2”…] 参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数 一般推荐使用exec格式，这类格式在解析时会被解析成JSON数组，因此要使用双引号 如果是shell格式，实际会被包装成sh -c的格式12345CMD echo $HOME``` 实际执行会变成： ```bashCMD [ \"sh\", \"-c\", \"echo $HOME\" ] 注意：Docker不是虚拟机，容器中的应用都是前台执行，没有后台服务的概念 错误示范：1CMD service nginx start 这里容器执行后会秒退出，因为上面的命令会被转化为CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start]，主进程是sh，当service nginx start执行结束后，sh也就结束了，sh作为主进程结束，所以容器也会退出 正确做法：1CMD [ \"nginx\", \"-g\", \"daemon off;\" ] 这边执行docker run的时候，不需要再跟/bin/bash启动命令，因为会覆盖。否则就是秒结束进程 ENTRYPOINT 入口点如果指定了ENTRYPOINT，CMD就不会直接执行命令，而是讲内容作为参数传给ENTRYPOINT，实际执行指令会变为：1ENTRYPOINT \"&lt;CMD&gt;\" 场景一：让镜像变成像命令一样使用1docker run myip -i 场景二：应用运行前的准备工作在启动主进程之前，需要一些准备工作，比如数据库的配置、初始化 ENV 设置环境变量两种格式： ENV \\ \\ ENV \\=\\ \\=\\ … 123# 含有空格的值使用双引号ENV VERSION=1.0 DEBUG=on \\ NAME=\"Happy Feet\" ARG构建参数格式：ARG &lt;参数名&gt;[=&lt;默认值&gt;] 构建参数和ENV效果一样，都是设置环境变量，唯一的区别是，ARG构建的环境变量，在将来容器运行的时候，不会存储这些环境变量 Dokcerfile中的ARG指令是定义参数名称，以及其默认值。可以通过构建命令docker build中用--build-arg &lt;参数名&gt;=&lt;值&gt;来覆盖 VOLUME 定义匿名卷格式为： VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…] VOLUME &lt;路径&gt; 容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中 1VOLUME /data 这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化 1docker run -d -v mydata:/data xxxx 这里mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置 EXPOSE 声明端口格式为：EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处: 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射 在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口 要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 WORKDIR 指定工作目录格式为: WORKDIR &lt;工作目录路径&gt; 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录 USER 指定当前用户格式：USER &lt;用户名&gt; USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份 HEALTHCHECK 健康检查HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常 格式： HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 ONBUILD格式：ONBUILD &lt;其它指令&gt; NOBUILD指令是别人定制镜像。即使用FROM的时候，才执行的命令 推送镜像12345# 先打标签docker tag ubuntu:17.10 username/ubuntu:17.10# 在pushdocker push username/ubuntu:17.10 配置私有仓库配置私有仓库 数据卷数据卷 是一个可供一个或多个容器使用的特殊目录： 数据卷可以在容器之间共享和重用 对 数据卷 的修改会立马生效 对 数据卷 的更新，不会影响镜像 数据卷 默认会一直存在，即使容器被删除 注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷。 外部访问容器使用- P标记时，Docker会随机映射 49000~49900 的端口到内部容器开放的网络端口 - p可以指定要映射的端口，也可以指定地址ip:hostPort:containerPort 1docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py 查看映射端口配置docker port1docker port nostalgic_morse 5000 容器有自己的内部网络和 ip 地址 -p 标记可以多次使用来绑定多个端口 容器互联查看已有网络1docker network ls 新建网络1docker network create -d bridge my-net -d 可以指定Docker网络类型，有bridge, overlay，其中 overlay 网络类型用于 Swarm mode(集群服务) 连接容器运行一个容器并连接到新建的 my-net 网络123456789101112docker run -it --rm --name busybox1 --network my-net busybox sh# 再运行一个容器docker run -it --rm --name busybox2 --network my-net busybox sh# 测试连接# 在busybox1 容器里，执行# /ping busybox2PING busybox2 (172.19.0.3): 56 data bytes64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.060 ms64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.046 ms64 bytes from 172.19.0.3: seq=2 ttl=64 time=0.075 ms Compose 项目Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。Compose 中有两个重要的概念： 服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。 项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。 Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。 Compose 命令说明命令对象与格式docker-compose 命令的基本的使用格式是:1docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...] 命令选项 -f, –file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。 -p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。 –x-networking 使用 Docker 的可拔插网络后端特性 –x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge –verbose 输出更多调试信息。 -v, –version 打印版本并退出 命令使用说明Tips: 这里的service name是指服务的名称，不是container name 或者 container id build构建（重新构建）项目中的服务容器1docker-compose build [options] [SERVICE...] 服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db选项包括： --force-rm 删除构建过程中的临时容器 --no-cache 构建镜像过程中不使用 cache（这将加长构建过程） --pull 始终尝试通过 pull 来获取更新版本的镜像 config验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因 down此命令将会停止 up 命令所启动的容器，并移除网络 exec进入指定的容器1234567891011121314151617# 如果执行/bin/bash失败，报错OCI runtime exec failed,是因为bash不存在，替换成sh docker-compose exec web /bin/sh``` ### images 列出 Compose 文件中包含的镜像 ### kill格式为 `docker-compose kill [options] [SERVICE...]` 通过发送 SIGKILL 信号来强制停止服务容器 支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号```bash docker-compose kill -s SIGINT logs查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 –no-color 来关闭颜色。 格式为：docker-compose logs [options] [SERVICE...] pause暂停服务格式为：docker-compose pause [SERVICE...] port打印某个容器端口所映射的公共端口 格式为 docker-compose port [options] SERVICE PRIVATE_PORT 选项： –protocol=proto 指定端口协议，tcp（默认值）或者 udp。 –index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1） pspullpushrestartstoprmrun格式为 docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]1docker-compose run ubuntu ping docker.com 默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。 该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。 两个不同点： 给定命令将会覆盖原有的自动运行命令； 不会自动创建端口，以避免冲突。 如果不希望自动启动关联的容器，可以使用 –no-deps 选项，例如:1docker-compose run --no-deps web python manage.py shell 将不会启动 web 容器所关联的其它容器. 选项： -d 后台运行容器。 –name NAME 为容器指定一个名字。 –entrypoint CMD 覆盖默认的容器启动指令。 -e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。 -u, –user=”” 指定运行容器的用户名或者 uid。 –no-deps 不自动启动关联的服务容器。 –rm 运行命令后自动删除容器，d 模式下将忽略。 -p, –publish=[] 映射容器端口到本地主机。 –service-ports 配置服务端口并映射到本地主机。 -T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。 scale设置指定服务运行的容器个数 格式为 docker-compose scale [options] [SERVICE=NUM...] 通过 service=num 的参数来设置数量。例如：1docker-compose scale web=3 db=2 一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。 topunpause启动已暂停的服务 up格式为 docker-compose up [options] [SERVICE...] 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作 链接的服务都将会被自动启动，除非已经处于运行状态 默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试 如果使用 docker-compose up -d，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。 选项： -d 在后台运行服务容器。 –no-color 不使用颜色来区分不同的服务的控制台输出。 –no-deps 不启动服务所链接的容器。 –force-recreate 强制重新创建容器，不能与 –no-recreate 同时使用。 –no-recreate 如果容器已经存在了，则不重新创建，不能与 –force-recreate 同时使用。 –no-build 不自动构建缺失的服务镜像。 -t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒） Compose 模板文件模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 docker run 相关参数的含义都是类似的。 默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。123456789version: '3'services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像 如果使用 build 指令，在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中再次设置。 build指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。 可以使用 context 指令指定 Dockerfile 所在文件夹的路径 使用 dockerfile 指令指定 Dockerfile 文件名 使用 arg 指令指定构建镜像时的变量 使用 cache_from 指定构建镜像的缓存12345build: context: . cache_from: - alpine:latest - corp/web_app:3.14 cap_add, cap_drop指定容器的内核能力（capacity）分配 command覆盖容器启动后默认执行的命令1command: echo \"hello world\" container_name指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式1container_name: docker-web-container 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称 devices指定设备映射关系。12devices: - \"/dev/ttyUSB1:/dev/ttyUSB0\" depends_on解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web1234567891011121314version: '3'services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 注意：web 服务不会等待 redis db 「完全启动」之后才启动。 dns自定义 DNS 服务器。可以是一个值，也可以是一个列表。123456789101112131415161718192021dns: 8.8.8.8dns: - 8.8.8.8 - 114.114.114.114``` ### env_file从文件中获取环境变量，可以为单独的文件路径或列表。 如果通过 `docker-compose -f FILE` 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径 如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准 ```bashenv_file: .envenv_file: - ./common.env - ./apps/web.env - /opt/secrets.env 环境变量文件中每一行必须符合格式，支持 # 开头的注释行。12# common.env: Set development environmentPROG_ENV=development environment设置环境变量。可以使用数组或字典两种格式 只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据 1234567environment: RACK_ENV: development SESSION_SECRET:environment: - RACK_ENV=development - SESSION_SECRET 如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。 expose暴露端口，但不映射到宿主机，只被连接的服务访问 仅可以指定内部端口为参数 123expose: - \"3000\" - \"8000\" image指定为镜像名称或镜像 ID 读取变量Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。 例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。 12345version: \"3\"services:db: image: \"mongo:$&#123;MONGO_VERSION&#125;\" 如果执行 MONGO_VERSION=3.2 docker-compose up 则会启动一个 mongo:3.2 镜像的容器；如果执行 MONGO_VERSION=2.8 docker-compose up 则会启动一个 mongo:2.8 镜像的容器。 若当前目录存在 .env 文件，执行 docker-compose 命令时将从该文件中读取变量。 在当前目录新建 .env 文件并写入以下内容。12# 支持 # 号注释MONGO_VERSION=3.6 执行 docker-compose up 则会启动一个 mongo:3.6 镜像的容器。 附录常见问题总结常见问题总结 资源链接资源链接 进阶深入进阶深入，参考原文档《Docker — 从入门到实践》","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://pengwenwu.github.io/tags/Docker/"}]},{"title":"js和php闭包使用和区别","slug":"js和php闭包使用和区别","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2018/05/25/js和php闭包使用和区别/","link":"","permalink":"https://pengwenwu.github.io/2018/05/25/js和php闭包使用和区别/","excerpt":"","text":"匿名函数 如果只是省去函数名，单纯的当作一个函数式方法返回，只能称为匿名函数（闭包需要将匿名函数当作结果返回），比如： 12345// jsvar foo = function(x, y) &#123; return x + y ;&#125;;console.log(foo(1, 2)); // 3 123456&lt;?php// php$foo = function($a, $b) &#123; return $a + $b;&#125;; // 一定要加分号echo $foo(1, 2); // 3 闭包 闭包通常是用来创建内部变量，使得这些变量不得被外部随意修改，而只能通过指定的函数接口去修改 js闭包这里举一个阮老师博客里的例子，阮老师博客：学习Javascript闭包（Closure） js基础参考链接：深入理解JS中声明提升、作用域（链）和this关键字 js比较特殊的一点是：函数内部可以直接读取到全局变量（对于阮老师的这句话不是很能理解，大概是想表达的意思：父作用域的变量可以在子作用域直接访问，而不需要去声明访问真正的全局变量？） 大部分语言，变量都是先声明在使用，而对于js，具有声明提升的特性（不管在哪里声明，都会在代码执行前处理） 函数和变量的声明总是会隐式地被移动到当前作用域的顶部，函数的声明优先级高于变量的声明 var 会在当前作用域声明一个变量，而未声明的变量，会隐式地创建一个全局变量 123// 声明提升console.log(a); // 1, 未报错var a = 1; 123456789101112131415161718192021// 上文链接中的例子function testOrder(arg) &#123; console.log(arg); // arg是形参，不会被重新定义 console.log(a); // 因为函数声明比变量声明优先级高，所以这里a是函数 var arg = 'hello'; // var arg;变量声明被忽略， arg = 'hello'被执行 var a = 10; // var a;被忽视; a = 10被执行，a变成number function a() &#123; console.log('fun'); &#125; // 被提升到作用域顶部 console.log(a); // 输出10 console.log(arg); // 输出hello&#125;; testOrder('hi');/* 输出：hi function a() &#123; console.log('fun'); &#125;10 hello */ 12345678// 全局作用域var foo = 42;function test() &#123; // 局部作用域 foo = 21;&#125;test();foo; // 21 12345678// 全局作用域foo = 42;function test() &#123; // 局部作用域 var foo = 21;&#125;test();foo; // 42 js变量的查找是从里往外的，直到最顶层（全局作用域），并且一旦找到，即停止向上查找。所有内部函数可以访问函数外部的变量，反之无效 12345678function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log(a, b, c); &#125; bar(b * 3);&#125;foo(2); 1234function foo() &#123; var a = 1;&#125;console.log(a); //a is not defined 123456789101112131415function foo1() &#123; var num = 0; addNum = function() &#123; // 这里未通过var去声明，默认是全局变量 num += 1; &#125;; function foo2() &#123; console.log(num); &#125; return foo2;&#125;var tmp = foo1();tmp(); // 0addNum();tmp(); // 1 这里第二次调用foo2函数，foo1函数的局部变量num并没有被初始化为0，说明打印的是内存中的num。正常函数在每次调用结束后都会销毁局部变量，在重新调用的时候会再次声明变量；而这边没有重新声明的原因是：把foo2函数赋值给了一个全局变量tmp，导致foo2函数一直存在内存中，而foo2函数依赖于foo1函数存在，所以foo1函数也存在内存中，并没有被销毁，所以foo1的局部变量也是存在内存中。 this的上下文基于函数调用的情况。和函数在哪定义无关，而和函数怎么调用有关。 在全局上下文（任何函数以外），this指向全局对象(windows) 在函数内部时，this由函数怎么调用来确定 当函数作为对象方法调用时，this指向该对象 下面是阮老师博客里的两个思考题： 12345678910var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); // The Window 1234567891011var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()());// My Object this的作用域好像一直是个比较奇怪的东西，对于上面两个例子，我的理解是：第一个例子，是在方法里调用的this，而这个this并没有声明，会隐式地创建一个全局变量，所以调用的全局的name；第二个，调用的that的时候，会向顶级链式查找是否声明that，而这个that有this赋值，这里的this又是通过对象方法调用，则该this指向这个object对象，所有最终调用的是object作用域内的name。不知道这么理解是不是有问题，还望大神指正。 那其实js闭包的主要目的：访问函数内部的局部变量，即延长作用域链参考链接：js闭包MDN文档 php闭包php回调函数mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $… ]] )mixed call_user_func_array ( callable $callback , array $param_arr ) 这两个函数都是把第一个参数作为回调函数d调用，后面接收参数，区别就是第二个函数第二参数接收数组；在使用上唯一的区别就是，call_user_func函数无法接收引用传递; 个人觉得同样是使用，call_user_func 相比call_user_func_array完全可以被替代，不知道是不是有一些性能上的优势。具体使用样例，请参考官方文档。 123456789&lt;?php// 引用传递function foo(&amp;$a, &amp;$b) &#123; $a ++; $b --;&#125;;$a = $b = 10;call_user_func_array('foo', [&amp;$a, &amp;$b]);echo $a.\"\\n\", $b; // 11, 9 基本用法基本用法，跟js的闭包类似 普通调用 123456&lt;?phpglobal $tmp = 'hello world';function foo() &#123; var_dump(global $tmp);&#125;foo(); // null, 函数内部无法直接调用上级作用域的变量，除非声明为全局变量 12345678910&lt;?php$foo1 = function() &#123; $a = 10; $foo2 = function() &#123; var_dump($a); &#125;; return $foo2;&#125;;$tmp = $foo1();$tmp(); // null，原因同上 php想要能够获取上级作用域的变量，需要通过use传递 123456789101112&lt;?php$foo1 = function () &#123; $a = 10; $foo2 = function () use ($a) &#123; var_dump($a); $a ++; &#125;; $foo2(); return $foo2;&#125;;$tmp = $foo1();$tmp(); // 10, 10, use并不能实际改变变量的值，只是值传递 123456789101112&lt;?php$foo1 = function () &#123; $a = 10; $foo2 = function () use (&amp;$a) &#123; var_dump($a); $a ++; &#125;; $foo2(); return $foo2;&#125;;$tmp = $foo1();$tmp(); // 10, 11, 通过值传递改变变量的值 下面两段代码的区别，不是很明白，望大佬指点，为什么后一个值传递就可以获取到已经改变后变量的值。好像都是在调用方法之前，已经执行过变量的递增了吧？ 123456789101112&lt;?php// 值传递$foo1 = function () &#123; $a = 10; $foo2 = function () use ($a) &#123; var_dump($a); &#125;; $a ++; return $foo2;&#125;;$tmp = $foo1();$tmp(); // 10 123456789101112&lt;?php// 引用传递$foo1 = function () &#123; $a = 10; $foo2 = function () use (&amp;$a) &#123; var_dump($a); &#125;; $a ++; return $foo2;&#125;;$tmp = $foo1();$tmp(); // 11 正确使用 1234567891011&lt;?php// 值传递$foo = function () &#123; $a = 10; $foo2 = function ($num) use ($a) &#123; var_dump($num + $a); &#125;; return $foo2;&#125;;$tmp = $foo();$tmp(100); // 110 1234567891011121314&lt;?php// 引用传递$foo = function () &#123; $a = 10; $foo2 = function ($num) use (&amp;$a) &#123; var_dump($num + $a); $a ++; &#125;; return $foo2;&#125;;$tmp = $foo();$tmp(100); // 110$tmp(100); // 111$tmp(100); // 112 跟js类似，保证变量常驻内存 php Closure 类 Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域public static Closure Closure::bind ( Closure $closure , object $newthis [, mixed $newscope = ‘static’ ] ) Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域public Closure Closure::bindTo ( object $newthis [, mixed $newscope = ‘static’ ] )对这两个方法不是很能理解。。。求指教 共同点都是为了扩展作用域，获取内部变量 区别js能够在方法内部直接获取到父级作用域的变量，而php需要通过use声明，并且默认是值传递 应用场景 不是很能理解应用场景，搜索了一下，很多只是写了一个闭包实现的购物车，感觉并不是那么的实用。 如果只是单纯的使用匿名函数，感觉还不如封装成一个私有方法 这些只是个人粗鄙的理解，望指正.","categories":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"JS","slug":"JS","permalink":"https://pengwenwu.github.io/tags/JS/"},{"name":"闭包","slug":"闭包","permalink":"https://pengwenwu.github.io/tags/闭包/"}]},{"title":"phpstorm或vscode使用psr2规范","slug":"phpstorm或vscode使用psr2规范","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2018/05/14/phpstorm或vscode使用psr2规范/","link":"","permalink":"https://pengwenwu.github.io/2018/05/14/phpstorm或vscode使用psr2规范/","excerpt":"","text":"安装composer 全局安装phpcs 1composer global require squizlabs/php_codesniffer vscode直接插件搜索phpcs安装phpstorm全局安装phpcs后，会在C:\\Users{user name}\\AppData\\Roaming\\Composer\\vendor\\bin下生成一个phpcs.bat，后面会用到 phpstorm -&gt; setting languages &amp; Frameworks-&gt;PHP-&gt;Code Sniffer点击Configuration右侧的按钮 找到刚才的phpcs.bat，点击Validate，确认 Editor-&gt;Inspection-&gt;PHP 双击PHP Code Sniffer validation，点击Coding standard右侧的刷新按钮，然后选择psr2，确定 参考链接: 如何优雅地使用phpstorm?","categories":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"PSR","slug":"PSR","permalink":"https://pengwenwu.github.io/tags/PSR/"}]},{"title":"array_map, array_walk, array_filter的区别及使用","slug":"array-map-array-walk-array-filter的区别及使用","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2018/05/13/array-map-array-walk-array-filter的区别及使用/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/array-map-array-walk-array-filter的区别及使用/","excerpt":"","text":"array_map, array_walk, array_filter的区别及使用 12345678910111213141516171819202122232425262728&lt;?php// array_map, array_walk, array_filter的区别$arr = [1, 2, 3, 4];function foo($value)&#123; return $value * $value;&#125;function filter($value)&#123; return $value &gt; 2;&#125;function walk(&amp;$value)&#123; $value = $value * $value;&#125;// array_map 会返回新的数组, 不对原数组产生影响$new_arr = array_map('foo', $arr);echo '原数组:'.var_export($arr, 1).\"\\n\", 'array_map修改后的数组：'.var_export($new_arr, 1).\"\\n\".\"&lt;hr/&gt;\";// array_walk 返回bool值，callback需要通过值传递改变原有数组$res = array_walk($arr, 'walk');echo '修改后的数组:'.var_export($arr, 1).\"\\n\", 'array_walk返回结果：'.var_export($res, 1).\"\\n\".\"&lt;hr/&gt;\";// array_filter 返回筛选后的新数组，不对原数组产生影响$new_arr = array_filter($arr, 'filter');echo '原数组:'.var_export($arr, 1).\"\\n\", 'array_filter返回结果：'.var_export($new_arr, 1).\"\\n\".\"&lt;hr/&gt;\";","categories":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"}]},{"title":"windows下cmd/powershell中文乱码解决方法","slug":"windows下cmd-powershell中文乱码解决方法","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/05/13/windows下cmd-powershell中文乱码解决方法/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/windows下cmd-powershell中文乱码解决方法/","excerpt":"","text":"windows下cmd或者powershell运行php文件中文乱码 解决方法执行下面的命令，切换成utf-8编码 chcp 65001 这个指标不治本，查了说是可以修改注册表，但是好像又会带来其他的坑（中文软件乱码、nodejs乱码），未测试过，不予评价。参考链接：https://www.zhihu.com/question/54724102","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://pengwenwu.github.io/categories/环境配置/"}],"tags":[{"name":"中文乱码","slug":"中文乱码","permalink":"https://pengwenwu.github.io/tags/中文乱码/"}]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2018/05/13/hexo常用命令/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/hexo常用命令/","excerpt":"","text":"hexo常用命令123456hexo n &quot;博客名称&quot; =&gt; hexo new &quot;博客名称&quot; hexo clean # 清楚缓存hexo g =&gt; hexo generate #生成hexo p =&gt; hexo publish # 发布hexo s =&gt; hexo server #启动服务预览hexo d =&gt; hexo deploy #部署 发布流程123hexo cleanhexo ghexo d","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"https://pengwenwu.github.io/tags/Hexo/"}]},{"title":"git reset 和 revert 的区别和使用","slug":"git-reset-和-revert-的区别和使用","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/05/13/git-reset-和-revert-的区别和使用/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/git-reset-和-revert-的区别和使用/","excerpt":"","text":"git revert 撤销某次提交, 保留之前的commit, 同时创建一个新的commit(可用于公共分支)git reset 撤销某个提交， 删除之前的commit, head回退 (多用于私有分支)区别: git revert 只是撤销某个commit, 保留该commit之前的提交结果 DEMO commit3: add log3commit2: add log2commit1: add log1 HEAD用法 HEAD^: 指向上一次commit HEAD~100: 指向前第一百个commit HEAD commit_id: 直接指向某个commit –soft、–mixed(默认)、–hard的区别 –soft: 只是重置HEAD到某一个commit, 其余不会有任何变化(缓存区和工作目录都不会被改变) –mixed(默认): 重置HEAD, 文件修改都将保存到缓存区(缓存区和你指定的提交同步，但工作目录不受影响) –hard: 修改当前所有内容, 所有本地修改都将丢失(缓存区和工作目录都同步到你指定的提交). 找回执行命令: git reflow","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"}]},{"title":"git pull更新指定文件","slug":"git-pull更新指定文件","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/05/13/git-pull更新指定文件/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/git-pull更新指定文件/","excerpt":"","text":"经常会遇到，几个文件一起提交了，但是某些文件是要先执行的，不然一起pull下来会加载报错 更新git指定文件git fetchgit checkout origin/master – path/to/file","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"}]},{"title":"阅读《微服务设计》笔记","slug":"阅读《微服务设计》笔记","date":"un66fin66","updated":"un44fin44","comments":true,"path":"2018/03/03/阅读《微服务设计》笔记/","link":"","permalink":"https://pengwenwu.github.io/2018/03/03/阅读《微服务设计》笔记/","excerpt":"","text":"记录阅读《微服务设计》收获的点 什么是微服务？一些协同工作的小而自治的服务 打破外键关系对于有外键关系的表如何做服务拆分？通过api调用访问 优点：数据表拆分，进而服务拆分 缺点：增加了数据库的调用，会影响性能。需要测试是否在可接受范围内，权衡拆分服务带来的好处 共享表拆分共享表拆分后，如何保证插入数据的一致性？设计之初为了减少数据库的调用，必然会建立基于外键的共享表。拆分之后，如何保证同时插入多张表数据的一致性？（某张表插入失败） 通过事务处理 推荐对及时性较弱的操作，异常捕获后放入队列或者日志文件中进行延迟处理，保证最终一致性 终止整个操作，再发起补偿事务来抵消之前的操作（自动化处理） 分布式事务。通过专门的事务管理器工具来协调底层事务（不推荐，易出错，难扩展） 阅读完感觉云里雾里，可能是自己的水平还没到达那个深度。收获大概是：了解了后端的架构，后期拓展可能会遇到的问题，以及解决这样问题的思路。","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://pengwenwu.github.io/tags/微服务/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2018/01/21/Linux常用命令/","link":"","permalink":"https://pengwenwu.github.io/2018/01/21/Linux常用命令/","excerpt":"","text":"记录一些阅读《鸟哥的Linux私房菜-基础学习篇》中不太熟悉的命令 软连接、硬链接 软连接：连接文件的内容只会写上目标文件的“文件名”，实际是通过记录的目标文件地址去访问实际存储内容。大小就是文件名大小。如果删除目标文件，则当前文件无法访问。(等同于windows的快捷方式) 硬连接：只能针对单个文件，实际会创建一个一模一样的“文件”(权限、大小)，连接数增加。连接到同一个地址，只是使用了不同的文件名，均可以对源文件进行数据修改，删除任意一个，不影响其余文件访问 12345cp -s test test1 ln -s test test1 # 软连接(快捷方式)cp -l demo.php demo1.php ln -l demo.php demo1.php # 硬链接(只支持单个文件) 查看分区1fdisk -l 解压缩123#-z gzip压缩，-j bzip2压缩tar -zcvf [newfilename] filename tar -zxvf filename.tar.gz [-C 目录] 解压要到指定目录 查看命令1type name 命名别名1234alias rm=&apos;rm -i&apos;alias st=&apos;status&apos;unalias rm #取消别名 数据流重定向 标准输入：&lt;或&lt;&lt; (将由键盘输入的数据由文件代替/结束输入)标准输出：&gt;或&gt;&gt; (覆盖/追加)标准错误输出：2&gt;或2&gt;&gt; (覆盖/追加) 1234cat &gt; catfile &lt;&lt; eof&gt;This is a test.&gt;Ok now stop&gt;eof 命令执行判断：; || &amp;&amp;12345678910#依次执行echo 1; echo 2; echo 3 #若cmd1正确执行，则开始执行cmd2#若cmd1执行错误，则cmd2不执行cmd1 &amp;&amp; cmd2 #若cmd1正确执行，则不执行cmd2#若cmd1执行错误，则开始执行cmd2cmd1 || cmd2 选取命令：cut, grep cut: -d：分割字符，与-f一起用 -f：取出第几段 -c：取出固定字符区间 12345# 列出第三段，第五段echo $PATH | cut -d &apos;:&apos; -f 3,5 # 取得第5字符之后echo $PATH | cut -c 5- 排序命令:sort, wc, uniq sort [-fbMnrtuk]uniq [-ic]-c：进行计数 12# 每个人登录的次数last | cut -d &apos; &apos; -f 1 | sort | uniq -c wc [-lwm]-l：仅列出行-w：仅列出多少字-m：多少字符","categories":[{"name":"Linux","slug":"Linux","permalink":"https://pengwenwu.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://pengwenwu.github.io/tags/Linux/"}]},{"title":"hexo + github搭建个人博客教程","slug":"hexo + github搭建个人博客教程","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2018/01/14/hexo + github搭建个人博客教程/","link":"","permalink":"https://pengwenwu.github.io/2018/01/14/hexo + github搭建个人博客教程/","excerpt":"","text":"前言一年前，临近毕业。为了准备面试，才刻意去准备了github以及blog。自从找到工作后，这两个基本没怎么维护过，想想未免太功利了点。 主要是前几天，又踩到坑了，想去找以前的记录，很麻烦。之前虽然每天都会写工作总结，一些踩过的坑记在为知笔记上，没有分类、标签，后面再想去找很困难。痛定思痛，该记的东西少不掉，索性优雅一点。 之前用的是博客园，但是那个账号密码老记不住，干脆自己搭建一个吧，好歹也是一个码农。然后花了两个晚上加一个上午，通过hexo和github搭建了一个个人博客。网上教程、文档那么多，为什么花这么久时间？当然是踩坑了啊。所以下面会记录一些遇到的问题和坑。如果你看完这边文章，那你只需要两个小时就能搭建成功。欢迎有兴趣的小伙伴尝试一下。 正文环境准备 node.js git 这两个应用windows用户直接搜索下载安装就可以。如果习惯了使用linux命令的朋友，推荐windows神器cmder。可以直接在windows环境下使用linux命令，样式可调，再也不要用黑乎乎的cmd了，而且自带git，完全可以不用下载windows git。 正式安装hexohexo官方中文文档 在node.js安装好的前提下，全局安装hexo如何判断node.js是否安装成功？执行以下命令，如果能够看到版本号则说明安装成功了1node -v 安装hexo1npm install -g hexo-cli 自选合适的目录，新建文件夹&lt;folder&gt;123cd &lt;folder&gt;hexo initnpm install 不再赘述，直接看官方文档。 配置github新建仓库，仓库名必须为[your_name.github.io] 补充：本地配置github ssh连接，方便自动部署，以及clone你喜欢的主题(theme) windows用户直接在c:/用户/youername/.ssh/下查看是否有id_rsa.pub文件。没有的话命令行执行命令ssh-keygen -t rsa -C &quot;your eamil&quot;，会自动生成id_rsa.pub文件，打开后复制。 github-&gt;头像-&gt;Settings→SSH kyes→Add SSH key，粘贴复制的内容。 配置本地账户12git config --global user.name “your_username” #设置用户名git config --global user.email “your_email” #设置邮箱地址,最好使用注册邮箱地址 测试是否配置成功1ssh -T git@github.com hexo配置以及使用有两个配置文件： 一个是根目录下的_config.yml称为站点配置文件 一个是themes/landscape/_config.yml称为主题配置文件(默认主题：landscape) 站点配置如下： 1234567url: https://yourname.github.io/theme: landscape #选择你想用的主题，我用的是indigodeploy: type: git # 不要使用github repo: git@github.com:pengwenwu/pengwenwu.github.io.git # 使用ssh连接 branch: master # 默认master分支 message: add new blog # 自动部署commit备注，可不填 hexo常用命令hexo命令参考 hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate #生成hexo s == hexo server #启动服务本地预览hexo d == hexo deploy #部署hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP 在执行之前，记得安装自动部署 (–save 加不加的区别在于是否写入到依赖文件package.json中)1npm install hexo-deployer-git --save 正常本地预览，直接执行hexo s,如果要发布话最好执行clean命令，会去删除生成的public文件，完整部署命令:hexo clean &amp;&amp; hexo g &amp;&amp; hexo d。或者直接hexo d -g 注意问题安装完自动部署后，是不需要本地git init新建仓库的。执行hexo g会在根目录生成public文件夹，自动部署，本质是将public文件夹内容全部提交到仓库中去，默认会访问编译好的index.html。 如果部署完，访问your_name.github.io 404,可能有下面几个原因 首先检查仓库文件，是不是全都是public的文件内容，如果整个本地blog文件夹都提交了，首先清空仓库，然后删除本地.deploy_git文件夹，再重新部署 文件有报错，本地hexo s观察是否有报错。 不喜欢原主题的朋友，可以github去找喜欢的主题。执行命令1git clone XXXX.next.git themes\\next 这个会将新的主题下载到themes下对应的next目录，next为主题的名字。 主题的配置，可以看文档，修改对应的主题配置文件。我使用的主题是indigo,详细文档indigo markdown不会使用的朋友，参考链接markdown中文文档如果没有ide的话，可以使用在线预览Cmd Markdown","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://pengwenwu.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://pengwenwu.github.io/tags/Github/"}]},{"title":"如何将一个数组乱序？","slug":"如何将一个数组乱序？","date":"un66fin66","updated":"un00fin00","comments":true,"path":"2018/01/13/如何将一个数组乱序？/","link":"","permalink":"https://pengwenwu.github.io/2018/01/13/如何将一个数组乱序？/","excerpt":"","text":"这是很久以前博客园的博客，打个小样。 前几天php实习面试，问到一个问题：如何将一个数组乱序？答：使用自带的array_rand()或者shuffle()函数，或者用随机数取值赋值给新的数组。又问：万一一直随机到同一个数怎么办？那就进行判断，如果已经取过的位置，重新选取随机数。这样问题就来了：随着新数组长度增加，原数组中的随机数选取碰撞几率会原来越大，最后几乎是一直碰撞的。也没有想出更好的办法。 后来回家后查了一下，总结一下，有以下几种方法： 使用自带的函数 12345678function shuffle_rand1($arr)&#123; echo \"原来数组为：\"; print_r($arr); shuffle($arr); echo \"&lt;br&gt;乱序数组为：\"; print_r($arr);&#125; 第一时间想到的方法，就是随机取值，赋值给新的数组 12345678910111213141516171819function shuffle_rand2($arr)&#123; echo \"原来数组为：\"; print_r($arr); $len = count($arr); $shuffle_arr = array(); while(count($shuffle_arr)&lt;$len)&#123; $index = rand(0,$len-1); if(!in_array($index, $shuffle_arr))&#123; $shuffle_arr[] = $index; &#125; &#125; $newarr = array(); foreach ($shuffle_arr as $v) &#123; $newarr[] = $arr[$v]; &#125; echo \"&lt;br&gt;新的数组为：\"; print_r($newarr);&#125; 数组中随机取一个元素赋值给新的数组，然后将原数组最后一位赋值到该位置,数组长度减一，继续重复上述步奏 123456789101112131415function shuffle_rand3($arr)&#123; echo \"原来数组为：\"; print_r($arr); $len = count($arr); $shuffle_arr = array(); while($len&gt;0)&#123; $index = rand(0,$len-1); $shuffle_arr[] = $arr[$index]; $arr[$index] = $arr[$len-1]; $len--; &#125; echo \"&lt;br&gt;新的数组为：\"; print_r($shuffle_arr);&#125; 在具有n个元素的数组中，对0到n-1一次进行与一个随机位置元素进行交换,这种方法不需要新建一个数组，直接在原数组中进行 12345678910111213function shuffle_rand4($arr)&#123; echo \"原来数组为：\"; print_r($arr); $len = count($arr); for($i=0;$i&lt;$len;$i++)&#123; $index = rand(0,$len-1); $temp = $arr[$i]; $arr[$i] = $arr[$index]; $arr[$index] = $temp; &#125; echo \"&lt;br&gt;新的数组为：\"; print_r($arr);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://pengwenwu.github.io/categories/算法/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"算法","slug":"算法","permalink":"https://pengwenwu.github.io/tags/算法/"}]},{"title":"Hello World","slug":"hello-world","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2018/01/10/hello-world/","link":"","permalink":"https://pengwenwu.github.io/2018/01/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}