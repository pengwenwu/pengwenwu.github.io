{"meta":{"title":"Pena's Blog","subtitle":"莫道君行早，更有早行人","description":"pengwenwu的个人博客","author":"pengwenwu","url":"https://pengwenwu.github.io"},"pages":[{"title":"categories","date":"un55fin55","updated":"un00fin00","comments":true,"path":"categories/index.html","permalink":"https://pengwenwu.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"un55fin55","updated":"un00fin00","comments":true,"path":"tags/index.html","permalink":"https://pengwenwu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"phpstorm或vscode使用psr2规范","slug":"phpstorm或vscode使用psr2规范","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2018/05/14/phpstorm或vscode使用psr2规范/","link":"","permalink":"https://pengwenwu.github.io/2018/05/14/phpstorm或vscode使用psr2规范/","excerpt":"","text":"安装composer 全局安装phpcs 1composer global require squizlabs/php_codesniffer vscode直接插件搜索phpcs安装phpstorm全局安装phpcs后，会在C:\\Users{user name}\\AppData\\Roaming\\Composer\\vendor\\bin下生成一个phpcs.bat，后面会用到 phpstorm -&gt; setting languages &amp; Frameworks-&gt;PHP-&gt;Code Sniffer点击Configuration右侧的按钮 找到刚才的phpcs.bat，点击Validate，确认 Editor-&gt;Inspection-&gt;PHP 双击PHP Code Sniffer validation，点击Coding standard右侧的刷新按钮，然后选择psr2，确定 参考链接: 如何优雅地使用phpstorm?","categories":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"PSR","slug":"PSR","permalink":"https://pengwenwu.github.io/tags/PSR/"}]},{"title":"array_map, array_walk, array_filter的区别及使用","slug":"array-map-array-walk-array-filter的区别及使用","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2018/05/13/array-map-array-walk-array-filter的区别及使用/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/array-map-array-walk-array-filter的区别及使用/","excerpt":"","text":"array_map, array_walk, array_filter的区别及使用 12345678910111213141516171819202122232425262728&lt;?php// array_map, array_walk, array_filter的区别$arr = [1, 2, 3, 4];function foo($value)&#123; return $value * $value;&#125;function filter($value)&#123; return $value &gt; 2;&#125;function walk(&amp;$value)&#123; $value = $value * $value;&#125;// array_map 会返回新的数组, 不对原数组产生影响$new_arr = array_map('foo', $arr);echo '原数组:'.var_export($arr, 1).\"\\n\", 'array_map修改后的数组：'.var_export($new_arr, 1).\"\\n\".\"&lt;hr/&gt;\";// array_walk 返回bool值，callback需要通过值传递改变原有数组$res = array_walk($arr, 'walk');echo '修改后的数组:'.var_export($arr, 1).\"\\n\", 'array_walk返回结果：'.var_export($res, 1).\"\\n\".\"&lt;hr/&gt;\";// array_filter 返回筛选后的新数组，不对原数组产生影响$new_arr = array_filter($arr, 'filter');echo '原数组:'.var_export($arr, 1).\"\\n\", 'array_filter返回结果：'.var_export($new_arr, 1).\"\\n\".\"&lt;hr/&gt;\";","categories":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"}]},{"title":"windows下cmd/powershell中文乱码解决方法","slug":"windows下cmd-powershell中文乱码解决方法","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/05/13/windows下cmd-powershell中文乱码解决方法/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/windows下cmd-powershell中文乱码解决方法/","excerpt":"","text":"windows下cmd或者powershell运行php文件中文乱码 解决方法执行下面的命令，切换成utf-8编码 chcp 65001 这个指标不治本，查了说是可以修改注册表，但是好像又会带来其他的坑（中文软件乱码、nodejs乱码），未测试过，不予评价。参考链接：https://www.zhihu.com/question/54724102","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://pengwenwu.github.io/categories/环境配置/"}],"tags":[{"name":"中文乱码","slug":"中文乱码","permalink":"https://pengwenwu.github.io/tags/中文乱码/"}]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2018/05/13/hexo常用命令/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/hexo常用命令/","excerpt":"","text":"hexo常用命令123456hexo n &quot;博客名称&quot; =&gt; hexo new &quot;博客名称&quot; hexo clean # 清楚缓存hexo g =&gt; hexo generate #生成hexo p =&gt; hexo publish # 发布hexo s =&gt; hexo server #启动服务预览hexo d =&gt; hexo deploy #部署 发布流程123hexo cleanhexo ghexo d","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"},{"name":"hexo","slug":"hexo","permalink":"https://pengwenwu.github.io/tags/hexo/"}]},{"title":"git reset 和 revert 的区别和使用","slug":"git-reset-和-revert-的区别和使用","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/05/13/git-reset-和-revert-的区别和使用/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/git-reset-和-revert-的区别和使用/","excerpt":"","text":"git revert 撤销某次提交, 保留之前的commit, 同时创建一个新的commit(可用于公共分支)git reset 撤销某个提交， 删除之前的commit, head回退 (多用于私有分支)区别: git revert 只是撤销某个commit, 保留该commit之前的提交结果 DEMO commit3: add log3commit2: add log2commit1: add log1 HEAD用法 HEAD^: 指向上一次commit HEAD~100: 指向前第一百个commit HEAD commit_id: 直接指向某个commit –soft、–mixed(默认)、–hard的区别 –soft: 只是重置HEAD到某一个commit, 其余不会有任何变化(缓存区和工作目录都不会被改变) –mixed(默认): 重置HEAD, 文件修改都将保存到缓存区(缓存区和你指定的提交同步，但工作目录不受影响) –hard: 修改当前所有内容, 所有本地修改都将丢失(缓存区和工作目录都同步到你指定的提交). 找回执行命令: git reflow","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"}]},{"title":"git pull更新指定文件","slug":"git-pull更新指定文件","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/05/13/git-pull更新指定文件/","link":"","permalink":"https://pengwenwu.github.io/2018/05/13/git-pull更新指定文件/","excerpt":"","text":"经常会遇到，几个文件一起提交了，但是某些文件是要先执行的，不然一起pull下来会加载报错 更新git指定文件git fetchgit checkout origin/master – path/to/file","categories":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://pengwenwu.github.io/tags/Git/"}]},{"title":"阅读《微服务设计》笔记","slug":"阅读《微服务设计》笔记","date":"un66fin66","updated":"un11fin11","comments":true,"path":"2018/03/03/阅读《微服务设计》笔记/","link":"","permalink":"https://pengwenwu.github.io/2018/03/03/阅读《微服务设计》笔记/","excerpt":"","text":"记录阅读《微服务设计》收获的点 什么是微服务？一些协同工作的小而自治的服务 打破外键关系对于有外键关系的表如何做服务拆分？通过api调用访问 优点：数据表拆分，进而服务拆分 缺点：增加了数据库的调用，会影响性能。需要测试是否在可接受范围内，权衡拆分服务带来的好处 共享表拆分共享表拆分后，如何保证插入数据的一致性？设计之初为了减少数据库的调用，必然会建立基于外键的共享表。拆分之后，如何保证同时插入多张表数据的一致性？（某张表插入失败） 通过事务处理 推荐对及时性较弱的操作，异常捕获后放入队列或者日志文件中进行延迟处理，保证最终一致性 终止整个操作，再发起补偿事务来抵消之前的操作（自动化处理） 分布式事务。通过专门的事务管理器工具来协调底层事务（不推荐，易出错，难扩展） 阅读完感觉云里雾里，可能是自己的水平还没到达那个深度。收获大概是：了解了后端的架构，后期拓展可能会遇到的问题，以及解决这样问题的思路。","categories":[{"name":"后端","slug":"后端","permalink":"https://pengwenwu.github.io/categories/后端/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://pengwenwu.github.io/tags/微服务/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2018/01/21/Linux常用命令/","link":"","permalink":"https://pengwenwu.github.io/2018/01/21/Linux常用命令/","excerpt":"","text":"记录一些阅读《鸟哥的Linux私房菜-基础学习篇》中不太熟悉的命令 软连接、硬链接 软连接：连接文件的内容只会写上目标文件的“文件名”，实际是通过记录的目标文件地址去访问实际存储内容。大小就是文件名大小。如果删除目标文件，则当前文件无法访问。(等同于windows的快捷方式) 硬连接：只能针对单个文件，实际会创建一个一模一样的“文件”(权限、大小)，连接数增加。连接到同一个地址，只是使用了不同的文件名，均可以对源文件进行数据修改，删除任意一个，不影响其余文件访问 12345cp -s test test1 ln -s test test1 # 软连接(快捷方式)cp -l demo.php demo1.php ln -l demo.php demo1.php # 硬链接(只支持单个文件) 查看分区1fdisk -l 解压缩123#-z gzip压缩，-j bzip2压缩tar -zcvf [newfilename] filename tar -zxvf filename.tar.gz [-C 目录] 解压要到指定目录 查看命令1type name 命名别名1234alias rm=&apos;rm -i&apos;alias st=&apos;status&apos;unalias rm #取消别名 数据流重定向 标准输入：&lt;或&lt;&lt; (将由键盘输入的数据由文件代替/结束输入)标准输出：&gt;或&gt;&gt; (覆盖/追加)标准错误输出：2&gt;或2&gt;&gt; (覆盖/追加) 1234cat &gt; catfile &lt;&lt; eof&gt;This is a test.&gt;Ok now stop&gt;eof 命令执行判断：; || &amp;&amp;12345678910#依次执行echo 1; echo 2; echo 3 #若cmd1正确执行，则开始执行cmd2#若cmd1执行错误，则cmd2不执行cmd1 &amp;&amp; cmd2 #若cmd1正确执行，则不执行cmd2#若cmd1执行错误，则开始执行cmd2cmd1 || cmd2 选取命令：cut, grep cut: -d：分割字符，与-f一起用 -f：取出第几段 -c：取出固定字符区间 12345# 列出第三段，第五段echo $PATH | cut -d &apos;:&apos; -f 3,5 # 取得第5字符之后echo $PATH | cut -c 5- 排序命令:sort, wc, uniq sort [-fbMnrtuk]uniq [-ic]-c：进行计数 12# 每个人登录的次数last | cut -d &apos; &apos; -f 1 | sort | uniq -c wc [-lwm]-l：仅列出行-w：仅列出多少字-m：多少字符","categories":[{"name":"Linux","slug":"Linux","permalink":"https://pengwenwu.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://pengwenwu.github.io/tags/Linux/"}]},{"title":"hexo + github搭建个人博客教程","slug":"hexo + github搭建个人博客教程","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/01/14/hexo + github搭建个人博客教程/","link":"","permalink":"https://pengwenwu.github.io/2018/01/14/hexo + github搭建个人博客教程/","excerpt":"","text":"前言一年前，临近毕业。为了准备面试，才刻意去准备了github以及blog。自从找到工作后，这两个基本没怎么维护过，想想未免太功利了点。 主要是前几天，又踩到坑了，想去找以前的记录，很麻烦。之前虽然每天都会写工作总结，一些踩过的坑记在为知笔记上，没有分类、标签，后面再想去找很困难。痛定思痛，该记的东西少不掉，索性优雅一点。 之前用的是博客园，但是那个账号密码老记不住，干脆自己搭建一个吧，好歹也是一个码农。然后花了两个晚上加一个上午，通过hexo和github搭建了一个个人博客。网上教程、文档那么多，为什么花这么久时间？当然是踩坑了啊。所以下面会记录一些遇到的问题和坑。如果你看完这边文章，那你只需要两个小时就能搭建成功。欢迎有兴趣的小伙伴尝试一下。 正文环境准备 node.js git 这两个应用windows用户直接搜索下载安装就可以。如果习惯了使用linux命令的朋友，推荐windows神器cmder。可以直接在windows环境下使用linux命令，样式可调，再也不要用黑乎乎的cmd了，而且自带git，完全可以不用下载windows git。 正式安装hexohexo官方中文文档 在node.js安装好的前提下，全局安装hexo如何判断node.js是否安装成功？执行以下命令，如果能够看到版本号则说明安装成功了1node -v 安装hexo1npm install -g hexo-cli 自选合适的目录，新建文件夹&lt;folder&gt;123cd &lt;folder&gt;hexo initnpm install 不再赘述，直接看官方文档。 配置github新建仓库，仓库名必须为[your_name.github.io] 补充：本地配置github ssh连接，方便自动部署，以及clone你喜欢的主题(theme) windows用户直接在c:/用户/youername/.ssh/下查看是否有id_rsa.pub文件。没有的话命令行执行命令ssh-keygen -t rsa -C &quot;your eamil&quot;，会自动生成id_rsa.pub文件，打开后复制。 github-&gt;头像-&gt;Settings→SSH kyes→Add SSH key，粘贴复制的内容。 配置本地账户12git config --global user.name “your_username” #设置用户名git config --global user.email “your_email” #设置邮箱地址,最好使用注册邮箱地址 测试是否配置成功1ssh -T git@github.com hexo配置以及使用有两个配置文件： 一个是根目录下的_config.yml称为站点配置文件 一个是themes/landscape/_config.yml称为主题配置文件(默认主题：landscape) 站点配置如下： 1234567url: https://yourname.github.io/theme: landscape #选择你想用的主题，我用的是indigodeploy: type: git # 不要使用github repo: git@github.com:pengwenwu/pengwenwu.github.io.git # 使用ssh连接 branch: master # 默认master分支 message: add new blog # 自动部署commit备注，可不填 hexo常用命令hexo命令参考 hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate #生成hexo s == hexo server #启动服务本地预览hexo d == hexo deploy #部署hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP 在执行之前，记得安装自动部署 (–save 加不加的区别在于是否写入到依赖文件package.json中)1npm install hexo-deployer-git --save 正常本地预览，直接执行hexo s,如果要发布话最好执行clean命令，会去删除生成的public文件，完整部署命令:hexo clean &amp;&amp; hexo g &amp;&amp; hexo d。或者直接hexo d -g 注意问题安装完自动部署后，是不需要本地git init新建仓库的。执行hexo g会在根目录生成public文件夹，自动部署，本质是将public文件夹内容全部提交到仓库中去，默认会访问编译好的index.html。 如果部署完，访问your_name.github.io 404,可能有下面几个原因 首先检查仓库文件，是不是全都是public的文件内容，如果整个本地blog文件夹都提交了，首先清空仓库，然后删除本地.deploy_git文件夹，再重新部署 文件有报错，本地hexo s观察是否有报错。 不喜欢原主题的朋友，可以github去找喜欢的主题。执行命令1git clone XXXX.next.git themes\\next 这个会将新的主题下载到themes下对应的next目录，next为主题的名字。 主题的配置，可以看文档，修改对应的主题配置文件。我使用的主题是indigo,详细文档indigo markdown不会使用的朋友，参考链接markdown中文文档如果没有ide的话，可以使用在线预览Cmd Markdown","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://pengwenwu.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://pengwenwu.github.io/tags/github/"}]},{"title":"如何将一个数组乱序？","slug":"如何将一个数组乱序？","date":"un66fin66","updated":"un00fin00","comments":true,"path":"2018/01/13/如何将一个数组乱序？/","link":"","permalink":"https://pengwenwu.github.io/2018/01/13/如何将一个数组乱序？/","excerpt":"","text":"这是很久以前博客园的博客，打个小样。 前几天php实习面试，问到一个问题：如何将一个数组乱序？答：使用自带的array_rand()或者shuffle()函数，或者用随机数取值赋值给新的数组。又问：万一一直随机到同一个数怎么办？那就进行判断，如果已经取过的位置，重新选取随机数。这样问题就来了：随着新数组长度增加，原数组中的随机数选取碰撞几率会原来越大，最后几乎是一直碰撞的。也没有想出更好的办法。 后来回家后查了一下，总结一下，有以下几种方法： 使用自带的函数 12345678function shuffle_rand1($arr)&#123; echo \"原来数组为：\"; print_r($arr); shuffle($arr); echo \"&lt;br&gt;乱序数组为：\"; print_r($arr);&#125; 第一时间想到的方法，就是随机取值，赋值给新的数组 12345678910111213141516171819function shuffle_rand2($arr)&#123; echo \"原来数组为：\"; print_r($arr); $len = count($arr); $shuffle_arr = array(); while(count($shuffle_arr)&lt;$len)&#123; $index = rand(0,$len-1); if(!in_array($index, $shuffle_arr))&#123; $shuffle_arr[] = $index; &#125; &#125; $newarr = array(); foreach ($shuffle_arr as $v) &#123; $newarr[] = $arr[$v]; &#125; echo \"&lt;br&gt;新的数组为：\"; print_r($newarr);&#125; 数组中随机取一个元素赋值给新的数组，然后将原数组最后一位赋值到该位置,数组长度减一，继续重复上述步奏 123456789101112131415function shuffle_rand3($arr)&#123; echo \"原来数组为：\"; print_r($arr); $len = count($arr); $shuffle_arr = array(); while($len&gt;0)&#123; $index = rand(0,$len-1); $shuffle_arr[] = $arr[$index]; $arr[$index] = $arr[$len-1]; $len--; &#125; echo \"&lt;br&gt;新的数组为：\"; print_r($shuffle_arr);&#125; 在具有n个元素的数组中，对0到n-1一次进行与一个随机位置元素进行交换,这种方法不需要新建一个数组，直接在原数组中进行 12345678910111213function shuffle_rand4($arr)&#123; echo \"原来数组为：\"; print_r($arr); $len = count($arr); for($i=0;$i&lt;$len;$i++)&#123; $index = rand(0,$len-1); $temp = $arr[$i]; $arr[$i] = $arr[$index]; $arr[$index] = $temp; &#125; echo \"&lt;br&gt;新的数组为：\"; print_r($arr);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://pengwenwu.github.io/categories/算法/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://pengwenwu.github.io/tags/PHP/"},{"name":"算法","slug":"算法","permalink":"https://pengwenwu.github.io/tags/算法/"}]},{"title":"Hello World","slug":"hello-world","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2018/01/10/hello-world/","link":"","permalink":"https://pengwenwu.github.io/2018/01/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}